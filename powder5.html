<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Powder 5</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

        <script src="rules_spaceGroups.js"></script>
        <script src="numeric.min.js"></script>

    <style>
        :root {
            --system-blue: #007AFF;
            --system-gray-1: #8E8E93;
            --system-gray-2: #AEAEB2;
            --system-gray-3: #C7C7CC;
            --system-gray-4: #D1D1D6;
            --system-gray-5: #E5E5EA;
            --system-gray-6: #F2F2F7;
            --system-background: #FFFFFF;
            --system-grouped-background: #F2F2F7;
            --system-material-thin: rgba(255, 255, 255, 0.7);
            --system-material-regular: rgba(255, 255, 255, 0.8);
            --system-label: #000000;
            --system-secondary-label: rgba(60, 60, 67, 0.6);
            --system-tertiary-label: rgba(60, 60, 67, 0.3);
            --system-separator: rgba(60, 60, 67, 0.29);
            --system-fill: rgba(120, 120, 128, 0.2);
            --system-secondary-fill: rgba(120, 120, 128, 0.16);
            --system-shadow: rgba(0, 0, 0, 0.1);
        }

        #fit-button { width: 100%; }

        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif; 
            margin: 0; 
            background-color: var(--system-grouped-background); 
            display: flex; 
            flex-direction: column; 
            height: 100vh; 
            overflow: hidden; 
            color: var(--system-label);
        }
        #app-container { 
            display: flex; 
            width: 100%; 
            flex-grow: 1; 
            min-height: 0; 
            background-color: var(--system-grouped-background);
        }
        
        #controls-panel { 
            width: 380px; 
            min-width: 320px; 
            max-width: 500px; 
            flex-shrink: 0; 
            padding: 16px; 
            background-color: var(--system-background); 
            border-right: 1px solid var(--system-separator); 
            display: flex; 
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            z-index: 20;
            box-shadow: 0 0 20px rgba(0,0,0,0.05);
            border-radius: 0 12px 12px 0;
        }
        
        #drag-handle { 
            width: 6px; 
            cursor: col-resize; 
            background-color: var(--system-gray-5); 
            flex-shrink: 0; 
            transition: background-color 0.2s; 
        }
        #drag-handle:hover, #drag-handle:active { 
            background-color: var(--system-blue); 
        }
        
        #results-area { 
            flex-grow: 1; 
            position: relative; 
            background-color: var(--system-background); 
            min-width: 0; 
            display: flex; 
            flex-direction: column; 
            padding: 20px; 
            z-index: 10;
            border-radius: 12px 0 0 12px;
            margin: 8px 8px 8px 0;
            box-shadow: 0 4px 20px rgba(0,0,0,0.05);
        }
        
        .control-group { 
            padding: 16px; 
            margin-bottom: 16px;
            background-color: var(--system-background);
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .control-group:first-child { 
            padding-top: 0; 
            margin-top: 0;
        }
        .control-label { 
            display: block; 
            font-weight: 500; 
            color: var(--system-secondary-label); 
            font-size: 13px; 
            margin-bottom: 6px;
        }
        
        .control-input, .control-select { 
            width: 100%; 
            background-color: var(--system-gray-6); 
            border: 1px solid var(--system-gray-4); 
            color: var(--system-label); 
            border-radius: 8px; 
            padding: 10px 14px; 
            transition: all 0.2s ease; 
            box-sizing: border-box;
            font-size: 15px;
            height: 40px;
        }
        .control-input:focus, .control-select:focus { 
            outline: none; 
            border-color: var(--system-blue); 
            box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.2); 
        }
        .control-input:disabled { 
            background-color: var(--system-gray-6);
            color: var(--system-tertiary-label);
            cursor: not-allowed; 
        }
        
        .btn { 
            padding: 12px 20px; 
            border-radius: 10px; 
            font-weight: 600; 
            transition: all 0.2s; 
            cursor: pointer; 
            border: none; 
            text-align: center; 
            font-size: 15px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-primary { 
            background-color: var(--system-blue); 
            color: white; 
            box-shadow: 0 1px 3px rgba(0, 122, 255, 0.3);
        }
        .btn-primary:hover:not(:disabled) { 
            background-color: #006ee6; 
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 122, 255, 0.3);
        }
        .btn-primary:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 122, 255, 0.3);
        }

        .btn-secondary { 
    background-color: var(--system-gray-5); /* Darker background */
    color: var(--system-label); 
    border: 1px solid var(--system-gray-4); /* Add solid border */
    box-shadow: none; /* Remove shadow for a cleaner look */
}

.btn-secondary:hover:not(:disabled) { 
    background-color: var(--system-blue);    /* Change background to blue */
    color: white;                           /* Change text to white for contrast */
    border-color: var(--system-blue);       /* Make the border blue as well */
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0, 122, 255, 0.3); /* Optional: Add a blue glow like the primary buttons */
}

        .btn:disabled { 
            background-color: var(--system-gray-6); 
            color: var(--system-tertiary-label);
            cursor: not-allowed; 
            opacity: 0.7; 
            box-shadow: none;
        }
        
       .file-input-label { 
    display: block; 
    padding: 12px 16px; 
    background-color: var(--system-gray-5); /* Match the secondary buttons */
    color: var(--system-label); 
    border-radius: 10px; 
    text-align: center; 
    cursor: pointer; 
    transition: all 0.2s;
    font-weight: 500;
    border: 1px solid var(--system-gray-4); /* Change from dashed to solid */
}

.file-input-label:hover { 
    background-color: var(--system-blue);    /* Change background to blue */
    color: white;                           /* Change text to white */
    border-color: var(--system-blue);       /* Make the border blue */
}

        
        .results-grid { 
            display: grid; 
            grid-template-columns: repeat(3, minmax(80px, 1fr)); 
            gap: 12px; 
        }
        .result-card { 
            background-color: var(--system-gray-6); 
            padding: 12px; 
            border-radius: 10px; 
            text-align: center; 
            transition: all 0.2s; 
        }
        .result-card-label { 
            font-size: 12px; 
            color: var(--system-secondary-label); 
            margin-bottom: 4px;
        }
        .result-card-value { 
            font-size: 18px; 
            font-weight: 700; 
            color: var(--system-label); 
        }
        
        .fit-checkbox { 
            -webkit-appearance: none; 
            appearance: none; 
            background-color: var(--system-gray-6); 
            width: 22px; 
            height: 22px; 
            border: 1px solid var(--system-gray-4); 
            border-radius: 6px; 
            cursor: pointer; 
            display: inline-block; 
            position: relative; 
            transition: all 0.2s;
        }
        .fit-checkbox:checked { 
            background-color: var(--system-blue); 
            border-color: var(--system-blue); 
        }
        .fit-checkbox:checked::after { 
            content: '✓'; 
            color: white; 
            position: absolute; 
            left: 50%; 
            top: 50%; 
            transform: translate(-50%, -50%); 
            font-size: 14px; 
            font-weight: bold;
        }
        
        .tab-buttons { 
            display: flex; 
            background-color: var(--system-gray-6);
            border-radius: 10px;
            padding: 4px;
            margin-bottom: 16px;
        }
        .tab-btn { 
            flex: 1; 
            padding: 8px 12px; 
            background: none; 
            border: none; 
            color: var(--system-secondary-label); 
            font-weight: 500; 
            cursor: pointer; 
            border-radius: 8px;
            transition: all 0.2s; 
            font-size: 14px; 
        }
        .tab-btn:hover { 
            color: var(--system-label); 
            background-color: rgba(255,255,255,0.5);
        }
        .tab-btn.active { 
            color: var(--system-blue); 
            background-color: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .tab-content-panels { 
            position: relative; 
            padding-top: 0; 
        }
        .tab-content-panel { 
            display: none; 
            flex-direction: column; 
        }
        .tab-content-panel.active { 
            display: flex; 
        }

        .tab-content-panel > .control-group {
            border-top: none;
        }

        #lattice-parameters-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .bottom-actions { 
            margin-top: auto; 
            padding-top: 16px;
        }

        .slider-value-track { 
            display: grid; 
            grid-template-columns: 1fr; 
            grid-template-rows: 1fr; 
            align-items: center; 
        }
        .slider-value-track > * { 
            grid-column: 1; 
            grid-row: 1; 
        }
        .slider-value-display { 
            text-align: center; 
            color: var(--system-secondary-label); 
            font-weight: 500; 
            font-size: 13px; 
            pointer-events: none; 
        }
        input[type="range"].custom-slider { 
            -webkit-appearance: none; 
            appearance: none; 
            width: 100%; 
            height: 36px; 
            background: var(--system-gray-6); 
            border-radius: 6px; 
            outline: none; 
            padding: 0; 
            margin: 0; 
        }
        input[type="range"].custom-slider::-webkit-slider-thumb { 
            -webkit-appearance: none; 
            appearance: none; 
            width: 22px; 
            height: 22px; 
            background: var(--system-blue); 
            border-radius: 50%; 
            cursor: pointer; 
            border: 3px solid white; 
            box-sizing: border-box; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        input[type="range"].custom-slider::-moz-range-thumb { 
            width: 22px; 
            height: 22px; 
            background: var(--system-blue); 
            border-radius: 50%; 
            cursor: pointer; 
            border: 3px solid white; 
            box-sizing: border-box; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        input[type="range"].custom-slider:disabled { 
            background: var(--system-gray-6); 
        }
        input[type="range"].custom-slider:disabled::-webkit-slider-thumb { 
            background: var(--system-gray-3); 
        }
        input[type="range"].custom-slider:disabled::-moz-range-thumb { 
            background: var(--system-gray-3); 
        }

        /* --- UNIFIED UI & SPACING STYLES --- */
        #tab-panel-sample > .control-group, #tab-panel-background > .control-group {
            display: flex; 
            flex-direction: column; 
            gap: 16px; 
        } 
        
        /* Add these styles anywhere inside the <style> tag */
        .anchor-point-item {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
            padding: 8px;
            background-color: var(--system-gray-6);
            border-radius: 8px;
        }

        .anchor-point-item span {
    font-size: 15px;
    padding: 0 4px;
    text-align: right;
}

        .anchor-point-item .control-input {
            height: 36px;
            padding: 8px 12px;
        }

        .anchor-remove-btn {
            background-color: transparent;
            border: none;
            color: var(--system-gray-1);
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            padding: 0 8px;
            line-height: 1;
            transition: color 0.2s;
        }
        .anchor-remove-btn:hover {
            color: #ff453a; /* systemRed */
        }

        .control-group h2, .profile-section-header {
            margin: 0 0 16px 0; 
            padding-bottom: 12px; 
            border-bottom: 1px solid var(--system-separator);
            color: var(--system-label); 
            font-size: 17px; 
            font-weight: 600;
        }

.profile-controls-container + .profile-controls-container {
    margin-top: 24px;
}

        .parameter-grid-3col, .parameter-grid-2col, .slider-group, .form-row {
            display: grid; 
            gap: 12px; 
            align-items: center;
        }
        .parameter-grid-3col { 
            grid-template-columns: minmax(100px, auto) 1fr auto; 
        }
        .parameter-grid-2col, .slider-group, .form-row { 
            grid-template-columns: minmax(100px, auto) 1fr; 
        }
        
        .parameter-grid-3col > .control-label, .parameter-grid-2col > .control-label,
        .slider-group > .control-label, .form-row > .control-label {
            grid-column: 1; 
            margin-bottom: 0;
        }
        
        .parameter-grid-2col > *:not(label), .slider-group > .slider-value-track,
        .form-row > *:not(label) { 
            grid-column: 2; 
        }
        .parameter-grid-3col > .control-input { 
            grid-column: 2; 
        }
        .parameter-grid-3col > .fit-checkbox { 
            grid-column: 3; 
            justify-self: center; 
        }

        .profile-controls-container {
            display: grid; 
            grid-template-columns: minmax(100px, auto) 1fr auto;
            gap: 16px 12px; 
            align-items: center;
        }
        .profile-controls-container > .control-label { 
            grid-column: 1; 
            text-align: left; 
            margin-bottom: 0; 
        }
        .profile-controls-container > input[type="number"] { 
            grid-column: 2; 
        }
        .profile-controls-container > input[type="checkbox"] { 
            grid-column: 3; 
            justify-self: center; 
        }
        .profile-controls-container > .profile-section-header { 
            grid-column: 1 / -1; 
        }
        

        /* CSS for Toast Notifications */
        #toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
            display: flex;
            flex-direction: column-reverse;
            gap: 10px;
            pointer-events: none; /* Allow clicking through the container */
        }
        .toast {
            padding: 12px 20px;
            border-radius: 8px;
            color: white;
            font-size: 15px;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            opacity: 0;
            transform: translateX(100%); /* Start off-screen to the right */
            transition: all 0.4s cubic-bezier(0.21, 1.02, 0.73, 1); /* Smooth slide and fade */
        }
        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }
        .toast.error {
            background-color: #ff453a; /* systemRed */
        }
        .toast.success {
            background-color: #34c759; /* systemGreen */
        }


        
        .bottom-actions > .control-group {
            display: grid; 
            grid-template-columns: minmax(100px, auto) 1fr;
            gap: 16px; 
            align-items: center; 
            border: none; 
            padding: 0;
        }
        .bottom-actions > .control-group > h2,
        .bottom-actions > .control-group > .slider-group,
        .bottom-actions > .control-group > #progress-bar-container,
        .bottom-actions > .control-group > .results-grid {
            grid-column: 1 / -1;
        }
        .bottom-actions > .control-group > label[for="algorithm-select"] {
            grid-column: 1; 
            margin-bottom: 0;
        }
        .bottom-actions > .control-group > #algorithm-select {
            grid-column: 2; 
            margin-bottom: 0;
        }
        
        .help-tooltip-container { 
            position: relative; 
            display: inline-block; 
        }
.help-icon { 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    width: 24px; 
    height: 24px; 
    background-color: #4a5568; /* Darker background for icon */
    color: white; /* White question mark */
    border-radius: 50%; 
    font-weight: 500; 
    font-size: 14px; 
    cursor: help; 
    transition: all 0.2s; 
}
.help-icon:hover { 
    background-color: #2d3748; /* Even darker on hover */
    color: white;
}
        
.tooltip-content {
    visibility: hidden; 
    opacity: 0; 
    width: 280px;
    background-color: #2d3748; /* Darker background for better contrast */
    color: #f7fafc; /* Light text color */
    text-align: left;
    border-radius: 10px; 
    padding: 16px;
    position: absolute; 
    z-index: 1001;
    top: -15px;
    right: 115%;
    margin-right: 10px;
    transition: opacity 0.3s; 
    font-size: 15px; 
    border: 1px solid #4a5568; /* Darker border */
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); /* Stronger shadow */
}
.tooltip-content::after {
    content: ""; 
    position: absolute;
    top: 20px;
    left: 100%;
    margin-top: -5px; 
    border-width: 5px; 
    border-style: solid;
    border-color: transparent transparent transparent #2d3748; /* Match tooltip background */
}

.tooltip-content.visible {
    visibility: visible;
    opacity: 1;
}

.tooltip-content h4 { 
    color: #fff; /* White for headings */
    font-size: 15px; 
    margin-top: 0; 
    margin-bottom: 8px; 
    font-weight: 600; 
}
.tooltip-content p { 
    margin-top: 0; 
    margin-bottom: 6px; 
    line-height: 1.4; 
    color: #e2e8f0; /* Lighter gray for paragraph text */
}
.tooltip-content hr { 
    border: none; 
    border-top: 1px solid #4a5568; /* Darker separator */
    margin: 12px 0; 
}
        .hidden { 
            display: none !important; 
        }

        #controls-panel::-webkit-scrollbar { 
            width: 5px; 
        }
        #controls-panel::-webkit-scrollbar-track { 
            background: transparent; 
        }
        #controls-panel::-webkit-scrollbar-thumb { 
            background: var(--system-gray-4); 
            border-radius: 3px; 
        }
        #controls-panel::-webkit-scrollbar-thumb:hover { 
            background: var(--system-gray-3); 
        }

        /* Apple-style progress bar */
        #progress-bar-container {
            height: 5px;
            background-color: var(--system-gray-5);
            border-radius: 3px;
            overflow: hidden;
        }
        #progress-bar {
            height: 100%;
            background-color: var(--system-blue);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        /* Apple-style placeholder */
        #placeholder {
            background-color: var(--system-background);
            border-radius: 12px;
            padding: 40px;
        }
        #placeholder svg {
            color: var(--system-gray-3);
        }

        /* Subtle animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .control-group {
            animation: fadeIn 0.3s ease;
        }

        /* Improved focus states for accessibility */
        .btn:focus-visible,
        .control-input:focus-visible,
        .control-select:focus-visible,
        .fit-checkbox:focus-visible {
            outline: 2px solid var(--system-blue);
            outline-offset: 2px;
        }

    </style>
</head>

<body>

    <div id="app-container">
        <div id="controls-panel">
            
            <div class="control-group" style="padding-top: 16px;">
                 <div style="display: flex; align-items: center; gap: 10px;">
                    
                    <label for="file-input" class="file-input-label" style="flex-grow: 1;">
                        <span id="file-name">Select Data File</span>
                    </label>
                     
                    <div class="help-tooltip-container">
    <span class="help-icon">?</span>

    <div class="tooltip-content">
    <h4>Powder 5 Fit</h4>
    <p>Analyze powder XRD using the LeBail or Pawley method. <a href="powder5_help.html" target="_blank" style="color: #6495ED;">Method Guide &rarr;</a></p>
    <hr>
    <h4>Supported File Formats:</h4>
    <p>Generic 2-column (2θ intensity), .xrdml, .brml, .ras, .uxd, .udf, GSAS .esd/.xra</p>
    <hr>
    <h4>Chart Interaction:</h4>
    <p><b>Zoom:</b> Use the mouse wheel over the chart or an axis.</p>
    <p><b>Pan:</b> Click and drag the chart to pan.</p>
    <p><b>Reset View:</b> Right-click on the chart.</p>
    <p><b>Add BG Anchor:</b> Hold <b>Ctrl</b> and click on the chart to manually add an anchor point.</p>
</div>
</div>




                </div>
                <input type="file" id="file-input" class="hidden" accept=".brml,.csv,.ras,.txt,.esd,.gsa,.std,.udf,.xra,.xrdml,.xy">
            </div>

            <div class="tab-buttons">
                <button class="tab-btn active" data-tab="sample">Sample</button>
                <button class="tab-btn" data-tab="background">Background</button>
                <button class="tab-btn" data-tab="profile">Profile</button>
            </div>

            <div class="tab-content-panels">
                <div id="tab-panel-sample" class="tab-content-panel active">
                    <div class="control-group">
                        <h2>Structural Parameters</h2>
                        <div class="parameter-grid-2col">
                            <label for="bravais-lattice" class="control-label">System</label>
                            <select id="bravais-lattice" class="control-select">
                                <option value="cubic_F" selected>Cubic (F)</option>
                                <option value="cubic_I">Cubic (I)</option>
                                <option value="cubic_P">Cubic (P)</option>
                                <option value="hexagonal_P">Hexagonal (P)</option>
                                <option value="tetragonal_I">Tetragonal (I)</option>
                                <option value="tetragonal_P">Tetragonal (P)</option>
                                <option value="orthorhombic_F">Orthorhombic (F)</option>
                                <option value="orthorhombic_I">Orthorhombic (I)</option>
                                <option value="orthorhombic_C">Orthorhombic (C)</option>
                                <option value="orthorhombic_P">Orthorhombic (P)</option>
                                <option value="monoclinic_C">Monoclinic (C)</option>
                                <option value="monoclinic_P">Monoclinic (P)</option>
                            </select>
                        </div>
<div class="parameter-grid-2col">
    <label for="space-group-select" class="control-label">Space Group</label>
    <select id="space-group-select" class="control-select"></select>
</div>

                        <div id="lattice-parameters-container">
                        </div>
                    </div>

                    <div class="control-group">
                        <h2>Instrumental Parameters</h2>

                        <div class="parameter-grid-3col">
                            <label for="zero-shift" class="control-label">Zero (°)</label>
                            <input type="number" id="zero-shift" value="0.0" step="0.001" class="control-input">
                            <input type="checkbox" id="fit-zero-shift" class="fit-checkbox" title="Fit this parameter" >
                        </div>

                        <div class="form-row">
                            <label for="wavelength" class="control-label">Radiation 1 (Å)</label>
                            <input type="number" id="wavelength" value="1.54056" step="0.0001" class="control-input" min="0.01" title="Cu K-alpha 1">
                        </div>

                        <div class="form-row">
                            <label for="wavelength2" class="control-label">Radiation 2 (Å)</label>
                            <input type="number" id="wavelength2" value="1.54439" step="0.0001" class="control-input" min="0.01" title="Cu K-alpha 2">
                        </div>

                        <div class="form-row">
                            <label for="ratio21" class="control-label">Ratio (I₂/I₁)</label>
                            <input type="number" id="ratio21" value="0.497" step="0.01" class="control-input" min="0">
                        </div>
                    </div>

                </div>



                <div id="tab-panel-background" class="tab-content-panel">
                    <div class="control-group">
                        <h2>Background (Chebyshev Polynomial)</h2>
                        <div id="background-params-container" class="profile-controls-container">
                            </div>
                                                    
                        <h2>Background (Amorphous Hump)</h2>
                        <div class="profile-controls-container">
                             <label class="control-label">Hump Height</label>
                             <input type="number" id="param-hump-h" value="50" step="10" class="control-input">
                             <input type="checkbox" id="fit-hump-h" class="fit-checkbox"checked>
                             
                             <label class="control-label">Hump Position (°2θ)</label>
                             <input type="number" id="param-hump-p" value="25" step="0.1" class="control-input">
                             <input type="checkbox" id="fit-hump-p" class="fit-checkbox" checked>

                             <label class="control-label">Hump FWHM (°2θ)</label>
                             <input type="number" id="param-hump-w" value="12" step="0.1" class="control-input" min="0.01">
                             <input type="checkbox" id="fit-hump-w" class="fit-checkbox" checked>
                        </div>

                       <div style="padding-top: 16px; border-top: 1px solid var(--system-separator);">
                            <h2 style="margin-bottom: 6px;">Background Anchor Points</h2>
                            <p class="control-label" style="margin-bottom: 16px;">Use <b>Ctrl+Click</b> on the chart to select an experimental data point as a background anchor. This gives the point a higher weight during refinement.</p>
                            
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                                 <label for="show-anchors-checkbox" class="control-label" style="margin-bottom:0;">Show Anchors on Chart</label>
                                 <input type="checkbox" id="show-anchors-checkbox" class="fit-checkbox" checked>
                            </div>

                            <div id="anchor-points-list">
                                </div>
                        </div>
                      
                    </div>



                </div>

                <div id="tab-panel-profile" class="tab-content-panel">
                     <div class="control-group">
                        <div class="parameter-grid-2col" style="margin-bottom: 24px;">
                             <label for="profile-function-select" class="control-label">Profile Function</label>
<select id="profile-function-select" class="control-select">
   <option value="4" selected>Simple pVoigt</option>
   <option value="3">Anisotropy</option>
</select>
                        </div>

                        <div id="simple-pvoigt-params-container" class="profile-controls-container">
    <h3 class="profile-section-header">Gaussian Broadening</h3>
    <label class="control-label">GU</label>
    <input type="number" id="param-gu" value="0.035" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-gu" class="fit-checkbox">
    <label class="control-label">GV</label>
    <input type="number" id="param-gv" value="-0.03" step="0.01" class="control-input">
    <input type="checkbox" id="fit-gv" class="fit-checkbox" >
    <label class="control-label">GW</label>
    <input type="number" id="param-gw" value="0.02" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-gw" class="fit-checkbox" >
     <label class="control-label">GP</label>
    <input type="number" id="param-gp" value="0.0" step="0.001" class="control-input">
    <input type="checkbox" id="fit-gp" class="fit-checkbox">
    <h3 class="profile-section-header">Lorentzian Broadening</h3>
    <label class="control-label">LX</label>
    <input type="number" id="param-lx" value="0.05" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-lx" class="fit-checkbox" >
     <h3 class="profile-section-header">Peak Shape & Position</h3>
     <label class="control-label">eta (Mixing)</label>
    <input type="number" id="param-eta" value="0.74" step="0.01" min="0" max="1" class="control-input">
    <input type="checkbox" id="fit-eta" class="fit-checkbox">
     <label class="control-label">shft (Displ.)</label>
    <input type="number" id="param-shft" value="0" step="0.01" class="control-input">
    <input type="checkbox" id="fit-shft" class="fit-checkbox" >
     <label class="control-label">trns (Transp.)</label>
    <input type="number" id="param-trns" value="0" step="0.01" class="control-input">
    <input type="checkbox" id="fit-trns" class="fit-checkbox">
</div>

<div id="anisotropy-params-container" class="profile-controls-container hidden">
    <h3 class="profile-section-header">Isotropic Gaussian (TCH)</h3>
    <label class="control-label">U</label>
    <input type="number" id="param-u" value="0.04" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-u" class="fit-checkbox">
    <label class="control-label">V</label>
    <input type="number" id="param-v" value="-0.03" step="0.01" class="control-input">
    <input type="checkbox" id="fit-v" class="fit-checkbox" >
    <label class="control-label">W</label>
    <input type="number" id="param-w" value="0.02" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-w" class="fit-checkbox" >
    
    <h3 class="profile-section-header">Isotropic Lorentzian (TCH)</h3>
    <label class="control-label">X</label>
    <input type="number" id="param-x" value="0.001" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-x" class="fit-checkbox" >
    <label class="control-label">Y</label>
    <input type="number" id="param-y" value="0.005" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-y" class="fit-checkbox" >

        <h3 class="profile-section-header">Peak Asymmetry</h3>
    <label class="control-label">S/L</label>
    <input type="number" id="param-sl" value="0.0" step="0.001" class="control-input">
    <input type="checkbox" id="fit-sl" class="fit-checkbox">
    <label class="control-label">H/L</label>
    <input type="number" id="param-hl" value="0.0" step="0.001" class="control-input">
    <input type="checkbox" id="fit-hl" class="fit-checkbox" >


    <h3 class="profile-section-header">Anisotropic Broadening (Stephens)</h3>
    <label class="control-label">S400</label>
    <input type="number" id="param-s400" value="0.0" step="0.1" class="control-input">
    <input type="checkbox" id="fit-s400" class="fit-checkbox">
    <label class="control-label">S040</label>
    <input type="number" id="param-s040" value="0.0" step="0.1" class="control-input">
    <input type="checkbox" id="fit-s040" class="fit-checkbox">
    <label class="control-label">S004</label>
    <input type="number" id="param-s004" value="0.0" step="0.1" class="control-input">
    <input type="checkbox" id="fit-s004" class="fit-checkbox">
    <label class="control-label">S220</label>
    <input type="number" id="param-s220" value="0.0" step="0.1" class="control-input">
    <input type="checkbox" id="fit-s220" class="fit-checkbox">
     <label class="control-label">S202</label>
    <input type="number" id="param-s202" value="0.0" step="0.1" class="control-input">
    <input type="checkbox" id="fit-s202" class="fit-checkbox">
    <label class="control-label">S022</label>
    <input type="number" id="param-s022" value="0.0" step="0.1" class="control-input">
    <input type="checkbox" id="fit-s022" class="fit-checkbox">
    

</div>

                    </div>
                </div>
            </div>

            <div class="bottom-actions"> 
                 <div class="control-group" style="border-top: none; padding-top: 0;">
                     <h2>Refinement</h2>
                     <label for="algorithm-select" class="control-label">Method</label>
                     <select id="algorithm-select" class="control-select">
                        <option value="lm">Levenberg-Marquardt</option>
                        <option value="sa" selected>Simulated Annealing</option>
                        <option value="pt" selected>Parallel Tempering</option> </select>
                     </select>
                     
                     <div class="slider-group">
                         <label class="control-label">2θ Min</label>
                         <div class="slider-value-track">
                            <input type="range" id="tth-min-slider" class="custom-slider" disabled>
                            <span id="tth-min-value" class="slider-value-display">10.0</span>
                         </div>
                     </div>
                     
                     <div class="slider-group">
                         <label class="control-label">2θ Max</label>
                         <div class="slider-value-track">
                             <input type="range" id="tth-max-slider" class="custom-slider" disabled>
                             <span id="tth-max-value" class="slider-value-display">80.0</span>
                         </div>
                     </div>

                     <div class="slider-group">
                         <label class="control-label">Max Iterations</label>
                         <div class="slider-value-track">
                            <input type="range" id="iterations-slider" min="1" max="80" value="20" step="1" class="custom-slider">
                            <span id="iterations-value" class="slider-value-display">20</span>
                         </div>
                     </div>

                     <div id="progress-bar-container" class="hidden" style="width: 100%; border-radius: 3px; height: 5px;">
                        <div id="progress-bar" style="height: 100%; width: 0%; border-radius: 3px;"></div>
                     </div>
                     <div class="results-grid">
                        <div class="result-card">
                            <div class="result-card-label">Rp (%)</div>
                            <div id="rp-result" class="result-card-value">-</div>
                        </div>
                        <div class="result-card">
                            <div class="result-card-label">Rwp (%)</div>
                            <div id="rwp-result" class="result-card-value">-</div>
                        </div>
                        <div class="result-card">
                            <div class="result-card-label">χ² (GOF)</div>
                            <div id="chi2-result" class="result-card-value">-</div>
                        </div>
                     </div>
                </div>
                <div style="display: flex; flex-direction: column; gap: 16px; margin-top: 16px;">


                    <div style="display: flex; flex-direction: column; gap: 16px; margin-top: 16px;">
    <div style="display: flex; gap: 10px;">
        <button id="le-bail-button" class="btn btn-primary" style="flex: 1;" disabled>Run Le Bail</button>
        <button id="pawley-button" class="btn btn-primary" style="flex: 1;" disabled>Run Pawley</button>
    </div>

    <div style="display: flex; gap: 10px;">
        <button id="save-data-button" class="btn btn-secondary" style="flex: 1;" disabled>Save Report</button>
        <button id="report-button" class="btn btn-secondary" style="flex: 1;" disabled>Generate PDF</button>
    </div>
</div>
                </div>
            </div>
        </div>


        <div id="drag-handle"></div>

<div id="results-area" style="position: relative; flex-grow: 1; min-height: 0;">
    <div id="placeholder" style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; color: var(--system-secondary-label);">
        <svg xmlns="http://www.w3.org/2000/svg" style="width: 64px; height: 64px; margin-bottom: 16px;" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>
        <h2 style="font-size: 22px; font-weight: 600; margin-bottom: 8px;">Awaiting Data</h2>
        <p style="font-size: 16px; color: var(--system-secondary-label);">Load a data file to begin.</p>
    </div>

    <div id="results-container" style="width: 100%; height: 100%; display: none; flex-direction: column; position: relative;">
        <canvas id="main-chart"></canvas>
    </div>

    <div style="position: absolute; bottom: 6px; right: 12px; font-size: 10px; color: var(--system-secondary-label);">
        Powder 5, version 112, 25 Oct 2025
    </div>
</div>




<script>
    document.addEventListener('DOMContentLoaded', () => {      

        const NUM_BACKGROUND_PARAMS = 9;
        const CALCULATION_WINDOW_MULTIPLIER = 6.0; //avant 109 c'estai 8
        const PEAK_HEIGHT_CUTOFF = 0.002; // 0.01 Corresponds to 1%
 
const tooltipContainer = document.querySelector('.help-tooltip-container');
const tooltipContent = document.querySelector('.tooltip-content');
let tooltipTimer;

if (tooltipContainer && tooltipContent) {
    tooltipContainer.addEventListener('mouseenter', () => {
        // If a timer is set to hide the tooltip, cancel it
        clearTimeout(tooltipTimer);
        // Add the 'visible' class to show the tooltip
        tooltipContent.classList.add('visible');
    });

    tooltipContainer.addEventListener('mouseleave', () => {
        // Start a new timer to hide the tooltip after 1 second
        tooltipTimer = setTimeout(() => {
            tooltipContent.classList.remove('visible');
        }, 1000); //  milliseconds 
    });
}


        const controls = {
            fileInput: document.getElementById('file-input'),
            fileName: document.getElementById('file-name'),
            bravaisLattice: document.getElementById('bravais-lattice'),
            spaceGroupSelect: document.getElementById('space-group-select'),

            latticeParamsContainer: document.getElementById('lattice-parameters-container'),
            wavelength: document.getElementById('wavelength'),
      wavelength2: document.getElementById('wavelength2'), // le 29 sept 25, dublet Ka
        ratio21: document.getElementById('ratio21'),      
            zeroShift: document.getElementById('zero-shift'),
            fitZeroShift: document.getElementById('fit-zero-shift'),
            profileSelect: document.getElementById('profile-function-select'),
            simplePVoigtParamsContainer: document.getElementById('simple-pvoigt-params-container'),
            anisotropyParamsContainer: document.getElementById('anisotropy-params-container'),
            paramGU: document.getElementById('param-gu'), fitGU: document.getElementById('fit-gu'),
            paramGV: document.getElementById('param-gv'), fitGV: document.getElementById('fit-gv'),
            paramGW: document.getElementById('param-gw'), fitGW: document.getElementById('fit-gw'),
            paramGP: document.getElementById('param-gp'), fitGP: document.getElementById('fit-gp'),
            paramLX: document.getElementById('param-lx'), fitLX: document.getElementById('fit-lx'),
            paramEta: document.getElementById('param-eta'), fitEta: document.getElementById('fit-eta'),
            paramShft: document.getElementById('param-shft'), fitShft: document.getElementById('fit-shft'),
            paramTrns: document.getElementById('param-trns'), fitTrns: document.getElementById('fit-trns'),
            paramU: document.getElementById('param-u'), fitU: document.getElementById('fit-u'),
            paramV: document.getElementById('param-v'), fitV: document.getElementById('fit-v'),
            paramW: document.getElementById('param-w'), fitW: document.getElementById('fit-w'),
            paramX: document.getElementById('param-x'), fitX: document.getElementById('fit-x'),
            paramY: document.getElementById('param-y'), fitY: document.getElementById('fit-y'),
            paramSL: document.getElementById('param-sl'), fitSL: document.getElementById('fit-sl'),
            paramHL: document.getElementById('param-hl'), fitHL: document.getElementById('fit-hl'),
            paramS400: document.getElementById('param-s400'), fitS400: document.getElementById('fit-s400'),
            paramS040: document.getElementById('param-s040'), fitS040: document.getElementById('fit-s040'),
            paramS004: document.getElementById('param-s004'), fitS004: document.getElementById('fit-s004'),
            paramS220: document.getElementById('param-s220'), fitS220: document.getElementById('fit-s220'),
            paramS202: document.getElementById('param-s202'), fitS202: document.getElementById('fit-s202'),
            paramS022: document.getElementById('param-s022'), fitS022: document.getElementById('fit-s022'),
            algorithmSelect: document.getElementById('algorithm-select'),
            iterationsSlider: document.getElementById('iterations-slider'),
            iterationsValue: document.getElementById('iterations-value'),
            tthMinSlider: document.getElementById('tth-min-slider'),
            tthMinValue: document.getElementById('tth-min-value'),
            tthMaxSlider: document.getElementById('tth-max-slider'),
            tthMaxValue: document.getElementById('tth-max-value'),
            fitButton: document.getElementById('fit-button'),
            reportButton: document.getElementById('report-button'),
            saveDataButton: document.getElementById('save-data-button'),
            progressBar: document.getElementById('progress-bar'),
            progressBarContainer: document.getElementById('progress-bar-container'),
            rpResult: document.getElementById('rp-result'),
            rwpResult: document.getElementById('rwp-result'),
            chi2Result: document.getElementById('chi2-result'),
            mainChartCanvas: document.getElementById('main-chart'),
            placeholder: document.getElementById('placeholder'),
            resultsContainer: document.getElementById('results-container'),
                    };

const bgContainer = document.getElementById('background-params-container');
        if (bgContainer) { 
            let bgHtml = '';
            const initialBgValues = [100, 5, ...Array(NUM_BACKGROUND_PARAMS - 2).fill(0)];
            for (let i = 0; i < NUM_BACKGROUND_PARAMS; i++) {
                bgHtml += `
                    <label class="control-label">B${i}</label>
                    <input type="number" id="param-b${i}" value="${initialBgValues[i] || 0}" step="1" class="control-input">
                    <input type="checkbox" id="fit-b${i}" class="fit-checkbox" checked>
                `;
            }
            bgContainer.innerHTML = bgHtml;
        }


        // --- Global State ---
        let profileParamCache = { "3": {}, "4": {} };
        let currentProfile = "4";
       
        let isFitting = false;
        let lastGeneratedHklList = [];
        let backgroundAnchors = []; // Stores {tth, y} objects
        const HIGH_WEIGHT_MULTIPLIER = 50.0
         let masterHklList = [];
         let hklIndexCache = {}; //ajouté le 8 oct 25, on met en cache les hkl

        let fullExperimentalData = { tth: new Float64Array(), intensity: new Float64Array() };
        let calculatedBackground = new Float64Array();
        let workingDataCache = { tth: new Float64Array(), intensity: new Float64Array(), background: new Float64Array(), isValid: false };

        let fitResults = null;
        let lastFitResultsCache = null;
        let mainChart;


        // --- Worker Setup --- ADD THIS BLOCK ---
        let refinementWorker = null;
        try {
            refinementWorker = new Worker('refinement_worker.js');
            console.log("Refinement worker created.");

            // --- Worker Message Handler --- ADD THIS ---
            refinementWorker.onmessage = function(e) {
                const { type, value, message, results } = e.data;

                if (type === 'progress') {
                    // Update progress bar smoothly
                    controls.progressBar.style.transition = 'width 0.1s linear'; // Faster transition during updates
                    controls.progressBar.style.width = `${Math.min(100, value * 100)}%`;
                    // Optionally display messages:
                    // if (message) { /* Update a status label */ }
                } else if (type === 'result') {
                    console.log("Worker finished, received results:", results);
                    fitResults = results; // Store the complete results object
                    lastFitResultsCache = JSON.parse(JSON.stringify(fitResults)); // Update cache

                    // Calculate display patterns based on worker results
                    // Need to recalculate background and net pattern here for display
                    const displayParams = fitResults.params;
                    const displayHklList = fitResults.hklList;
                    const displayScaleFactor = fitResults.stats.scaleFactor;

                    if (!workerWorkingData) {
                         console.error("Main thread doesn't have workerWorkingData to display results!");
                         showToast("Error displaying results: Data mismatch.", "error");
                         setUIState(false); // Make sure UI unlocks
                         return;
                    }

                     try {
                         // Recalculate background and net pattern using the worker results
                         // Use the SAME working data slice the worker used
                         const finalBackgroundDisplay = calculateTotalBackground(workerWorkingData.tth, displayParams);
                         const finalNetPatternDisplay = calculatePattern(workerWorkingData.tth, displayHklList, displayParams);

                         // Pass the *correct* sliced data to updateUI/updateChart
                         updateUI(
                             displayParams,
                             fitResults.stats,
                             finalNetPatternDisplay, // Net pattern for the *slice*
                             finalBackgroundDisplay, // Background for the *slice*
                             displayScaleFactor,
                             displayHklList
                         );
                     } catch (displayError) {
                          console.error("Error updating UI with worker results:", displayError);
                          showToast(`Error displaying results: ${displayError.message}`, "error");
                     }


                    setUIState(false); // Re-enable UI
                    controls.progressBar.style.transition = 'width 0.3s ease'; // Restore normal transition
                    controls.progressBar.style.width = '100%'; // Ensure it shows 100%

                } else if (type === 'error') {
                    console.error("Worker reported error:", message);
                    showToast(`Refinement Error: ${message}`, 'error');
                    setUIState(false); // Unlock UI on error
                    controls.progressBar.style.width = '0%'; // Reset progress bar
                }
            };

            refinementWorker.onerror = function(e) {
                console.error("Error initializing or communicating with worker:", e.message, e);
                showToast(`Worker Initialization Error: ${e.message}`, 'error');
                isFitting = false; // Ensure fitting state is reset
                setUIState(false);
                refinementWorker = null; // Disable worker functionality
            };

        } catch (e) {
            console.error("Failed to create Web Worker:", e);
            alert("Could not create the refinement Web Worker. Heavy calculations will freeze the browser. Check browser compatibility and file paths.");
            refinementWorker = null;
        }


         updateSpaceGroupUI();


         


// ANCHORs MANAGEMENT
        function updateAnchorPointsOnChart() {
            if (!mainChart) return;

            const anchorDataset = mainChart.data.datasets.find(d => d.label === 'Anchor Points');
            if (anchorDataset) {
                // Map the anchors to the {x, y} format required by Chart.js scatter plots
                anchorDataset.data = backgroundAnchors.map(anchor => ({
                    x: anchor.tth,
                    y: anchor.y
                }));
               mainChart.update('none'); // Redraw the chart without animation
            }
        }

        // function to find the nearest data point to a click
        function findClosestExperimentalPoint(targetTth) {
            if (!fullExperimentalData || fullExperimentalData.tth.length === 0) {
                return null;
            }

            let closestIndex = -1;
            let minDiff = Infinity;

            // This is a simple linear search. .. j'aurais pu utiliser la librairie JS.. mais bon, c'est autonome
            for (let i = 0; i < fullExperimentalData.tth.length; i++) {
                const diff = Math.abs(fullExperimentalData.tth[i] - targetTth);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestIndex = i;
                }
            }

            return {
                index: closestIndex,
                tth: fullExperimentalData.tth[closestIndex],
                y: fullExperimentalData.intensity[closestIndex]
            };
        }

        // display non-editable points
        function renderAnchorList() {
            const listContainer = document.getElementById('anchor-points-list');
            listContainer.innerHTML = ''; 

            if (backgroundAnchors.length === 0) {
                listContainer.innerHTML = '<p class="control-label" style="text-align: center;">No anchor points defined.</p>';
            } else {
                backgroundAnchors.forEach((anchor, index) => {
                    const item = document.createElement('div');
                    item.className = 'anchor-point-item';
                    // Display values as text, not inputs
                    item.innerHTML = `
                        <span title="2-theta">${anchor.tth.toFixed(3)}</span>
                        <span title="Intensity">${anchor.y.toFixed(1)}</span>
                        <button class="anchor-remove-btn" data-index="${index}" title="Remove point">&times;</button>
                    `;
                    listContainer.appendChild(item);
                });
            }
            updateAnchorPointsOnChart();
        }

        // Simplified function to only handle removing points
        function handleAnchorListInteraction(e) {
            if (e.target.classList.contains('anchor-remove-btn')) {
                const index = parseInt(e.target.dataset.index, 10);
                if (!isNaN(index)) {
                    backgroundAnchors.splice(index, 1);
                    renderAnchorList();
                    updateBackgroundForPreview();
                }
            }
        }
    



        function updateStephensAnisotropyUI() {
            const { system } = getSystemAndCentering();
            const sParams = { s400: { input: controls.paramS400, fit: controls.fitS400 }, s040: { input: controls.paramS040, fit: controls.fitS040 }, s004: { input: controls.paramS004, fit: controls.fitS004 }, s220: { input: controls.paramS220, fit: controls.fitS220 }, s202: { input: controls.paramS202, fit: controls.fitS202 }, s022: { input: controls.paramS022, fit: controls.fitS022 }, };
            for (const key in sParams) { sParams[key].input.disabled = false; sParams[key].fit.disabled = false; sParams[key].input.style.backgroundColor = ''; }
            switch (system) {
                case 'cubic':
                    sParams.s040.input.value = sParams.s400.input.value; sParams.s004.input.value = sParams.s400.input.value; sParams.s040.fit.checked = sParams.s400.fit.checked; sParams.s004.fit.checked = sParams.s400.fit.checked; sParams.s202.input.value = sParams.s220.input.value; sParams.s022.input.value = sParams.s220.input.value; sParams.s202.fit.checked = sParams.s220.fit.checked; sParams.s022.fit.checked = sParams.s220.fit.checked;
                    [sParams.s040, sParams.s004, sParams.s202, sParams.s022].forEach(p => { p.input.disabled = true; p.fit.disabled = true; p.input.style.backgroundColor = 'var(--system-gray-5)'; });
                    break;
                case 'hexagonal': case 'tetragonal': case 'rhombohedral':
                    sParams.s040.input.value = sParams.s400.input.value; sParams.s040.fit.checked = sParams.s400.fit.checked; sParams.s022.input.value = sParams.s202.input.value; sParams.s022.fit.checked = sParams.s202.fit.checked;
                    [sParams.s040, sParams.s022].forEach(p => { p.input.disabled = true; p.fit.disabled = true; p.input.style.backgroundColor = 'var(--system-gray-5)'; });
                    break;
            }
        }

        const verticalCursorLine = { id: 'verticalCursorLine', afterDraw: chart => { if (chart.tooltip?._active?.length) { let x = chart.tooltip._active[0].element.x, yAxis = chart.scales.y, ctx = chart.ctx; ctx.save(); ctx.beginPath(); ctx.moveTo(x, yAxis.top); ctx.lineTo(x, yAxis.bottom); ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(156, 163, 175, 0.7)'; ctx.setLineDash([4, 4]); ctx.stroke(); ctx.restore(); } } };
        Chart.register(verticalCursorLine);
        Chart.Tooltip.positioners.experimentalAnchor = function(items) { if (!items.length) return false; const experimentalItem = items.find(item => item.datasetIndex === 0) || items[0]; return { x: experimentalItem.element.x, y: experimentalItem.element.y }; };
        
                function getSystemAndCentering() {
            let [system, centering] = controls.bravaisLattice.value.split('_');
            // 9. r Rhombohedral, maille hex
            if (system === "rhombohedral") {
                centering = "R"; // Force centering to 'R' for rhombohedral system
            }
            return { system, centering };
        }

        function saveProfileState(profileId) { const state = {}; const container = document.getElementById((profileId === '4') ? 'simple-pvoigt-params-container' : 'anisotropy-params-container'); if (container) container.querySelectorAll('input[type="number"], input[type="checkbox"]').forEach(input => { state[input.id] = (input.type === 'checkbox') ? input.checked : input.value; }); profileParamCache[profileId] = state; }
        function restoreProfileState(profileId) { const state = profileParamCache[profileId]; if (!state || Object.keys(state).length === 0) return; const container = document.getElementById((profileId === '4') ? 'simple-pvoigt-params-container' : 'anisotropy-params-container'); if (container) container.querySelectorAll('input[type="number"], input[type="checkbox"]').forEach(input => { if (state[input.id] !== undefined) input.type === 'checkbox' ? (input.checked = state[input.id]) : (input.value = state[input.id]); }); }
        
        // Data mapping systems to their possible Laue classes...peut etre mieux de les mettres dans la const spaceGroups ?
        const laueClassMap = {
            'cubic': [{ value: 'm-3m', text: 'm-3m' }, { value: 'm-3', text: 'm-3' }],
            'hexagonal': [{ value: '6/mmm', text: '6/mmm' }, { value: '6/m', text: '6/m' }],
            'rhombohedral': [{ value: '-3m', text: '-3m (Rhom. axes)' }, { value: '-3', text: '-3 (Rhom. axes)' }],
            'tetragonal': [{ value: '4/mmm', text: '4/mmm' }, { value: '4/m', text: '4/m' }],
            'orthorhombic': [{ value: 'mmm', text: 'mmm' }],
            'monoclinic': [{ value: '2/m', text: '2/m' }],
        };


function getSpaceGroupCentering(spaceGroupName) {
    const firstLetter = spaceGroupName.charAt(0).toUpperCase();
    if (firstLetter === "R") return "R"; // rhombohedral, mais en axes hex, à vérifier
    return firstLetter; // P, I, F, C, A, etc.
}

    //  updateSpaceGroupUI, v 108
    // les rhombo dans les axes hexa
function updateSpaceGroupUI() {
    const { system } = getSystemAndCentering();
    if (!spaceGroups.length) return; // Wait until data is defined

    const filteredGroups = spaceGroups.filter(sg => {
        // -
        // Create a special case for the hexagonal system to include rhombohedral ('R') groups.
        if (system === 'hexagonal') {
            // Show any group that is either 'hexagonal' OR is 'trigonal' with an 'R' name.
            return sg.system === 'hexagonal' || sg.system === 'trigonal';
        }
        
        // The original logic works correctly for all other systems.
        const selectedCentering = controls.bravaisLattice.value.split('_')[1];
        const sgCentering = sg.name.charAt(0).toUpperCase();
        return sg.system === system && sgCentering === selectedCentering;
    });

    controls.spaceGroupSelect.innerHTML = "";
    filteredGroups.forEach(sg => {
        const opt = document.createElement("option");
        opt.value = sg.number;
        opt.textContent = `${sg.number} – ${sg.name}`;
        controls.spaceGroupSelect.appendChild(opt);
    });
}

        function updateLatticeParamUI() {
            const currentValues = {}; const container = controls.latticeParamsContainer;
            container.querySelectorAll('input[type="number"]').forEach(input => { const name = input.id.replace('lattice-param-', ''); if (input.value) currentValues[name] = input.value; });
            const { system } = getSystemAndCentering(); container.innerHTML = '';
            const createInput = (name, label, defaultValue, step, isAngle = false) => {
                const valueToUse = currentValues[name] !== undefined ? currentValues[name] : defaultValue; const id_base = `lattice-param-${name}`; const unit = isAngle ? '°' : 'Å'; const minAttribute = isAngle ? '' : 'min="0.001"';
                const row = document.createElement('div'); row.className = 'parameter-grid-3col'; row.innerHTML = `<label for="${id_base}" class="control-label">${label} (${unit})</label><input type="number" id="${id_base}" value="${valueToUse}" step="${step}" class="control-input" ${minAttribute}><input type="checkbox" id="fit-lattice-${name}" class="fit-checkbox" title="Fit this parameter" checked>`; container.appendChild(row);
            };
            const params = { cubic: [{ name: 'a', label: 'a', value: 4.23, step: 0.001 }], tetragonal: [{ name: 'a', label: 'a', value: 4.0, step: 0.001 }, { name: 'c', label: 'c', value: 5.0, step: 0.001 }], orthorhombic: [{ name: 'a', label: 'a', value: 4.0, step: 0.001 }, { name: 'b', label: 'b', value: 5.0, step: 0.001 }, { name: 'c', label: 'c', value: 6.0, step: 0.001 }], hexagonal: [{ name: 'a', label: 'a', value: 4.0, step: 0.001 }, { name: 'c', label: 'c', value: 6.0, step: 0.001 }], rhombohedral: [{ name: 'a', label: 'a', value: 5.5, step: 0.001 }, { name: 'c', label: 'c', value: 15.0, step: 0.001 }], monoclinic: [{ name: 'a', label: 'a', value: 4.0, step: 0.001 }, { name: 'b', label: 'b', value: 5.0, step: 0.001 }, { name: 'c', label: 'c', value: 6.0, step: 0.001 }, { name: 'beta', label: 'β', value: 105.0, step: 0.01, isAngle: true }] };
            if(params[system]) params[system].forEach(p => createInput(p.name, p.label, p.value, p.step, p.isAngle));
        }


        function updateUIForSystemChange() {
            updateLatticeParamUI();
            updateSpaceGroupUI();
            updateStephensAnisotropyUI();
        }

        // This event listener triggers all UI updates.
        controls.bravaisLattice.addEventListener('change', updateUIForSystemChange);

/**
         * Smart file detector. It checks for known headers and extensions
         * and falls back to a generic 2-column parser.
         */
        const detectAndParseFile = (fileName, fileContent) => {
            const name = fileName.toLowerCase();
            const lines = fileContent.trim().split(/\r?\n/);
            const firstLine = lines.length > 0 ? lines[0].trim() : '';
            const upperContent = fileContent.substring(0, 500).toUpperCase(); // Check first 500 chars

            // --- Parser Registry ---
            const PARSER_REGISTRY = [
                { // XRDML
                    test: (name, content) => name.endsWith('.xrdml') || (content.includes('<?xml') && content.includes('<xrdMeasurement')),
                    parser: parseXrdmlFile
                },
                { // BRML
                    test: (name, content) => name.endsWith('.brml') || (content.includes('<?xml') && content.includes('<RawDataFile')),
                    parser: parseBrukerBrmlFile
                },
                { // Rigaku RASX (try brml parser)
                    test: (name, content) => name.endsWith('.rasx') && content.includes('<?xml'),
                    parser: parseBrukerBrmlFile
                },
                { // UXD
                    test: (name, content, firstLine) => name.endsWith('.uxd') || firstLine.startsWith('_FILEVERSION'),
                    parser: parseUxdFile
                },
                { // Rigaku RAS
                    test: (name, content, firstLine, upper) => name.endsWith('.ras') || upper.includes('*RAS_HEADER_START'),
                    parser: parseRigakuRasFile
                },
                { // Philips UDF/RD/SD
                    test: (name) => name.endsWith('.udf') || name.endsWith('.rd') || name.endsWith('.sd'),
                    parser: parsePhilipsUdfFile
                },
                { // GSAS ESD/XRA
                    test: (name, content, firstLine, upper, allLines) => allLines.some(line => line.trim().toUpperCase().startsWith('BANK')),
                    parser: (content, allLines) => {
                        const bankLine = allLines.find(line => line.trim().toUpperCase().startsWith('BANK'));
                        if (bankLine.toUpperCase().includes('STD')) {
                            return parseGsasXraFile(content);
                        }
                        return parseGsasEsdFile(content);
                    }
                },
                { // Jade MDI (treat as 2-column)
                     test: (name, content, firstLine, upper) => name.endsWith('.mdi') && (upper.includes('2-THETA, INTENSITY') || upper.startsWith('(SAMPLE')),
                     parser: parseDataFile
                }
            ];
            
            // --- Iterate Registry ---
            for (const rule of PARSER_REGISTRY) {
                try {
                    if (rule.test(name, fileContent, firstLine, upperContent, lines)) {
                        // Pass 'content' to parser, but 'lines' to the special GSAS one
                        if (rule.parser.length > 1) {
                             return rule.parser(fileContent, lines); // For GSAS parser
                        }
                        return rule.parser(fileContent);
                    }
                } catch (e) {
                    console.warn(`Parser ${rule.parser.name} failed, trying next...`, e.message);
                }
            }

            // --- Fallback for all other 2-column-like formats ---
            // This will attempt to parse: .xy, .csv, .txt, .dat, .asc, etc.
            return parseDataFile(fileContent, fileName);
        };
    
        /**
         * Generic 2-column parser. This is the fallback for most text files.
         * Includes validation logic for 2-theta (X) and step size (dX).
         */
        const parseDataFile = (text, fileName = "") => {
            const lines = text.trim().split(/\r?\n/);
            const tth = [], intensity = [];
            let last_x = -Infinity;
            let suspicious_steps = 0;
            let positive_x_values = 0;
            let negative_steps = 0;
            let headerLines = 0;
            let dataStarted = false;

            lines.forEach(line => {
                // Skip commented or empty lines
                if (line.startsWith('#') || line.startsWith('//') || line.startsWith('!') || line.startsWith(';') || line.trim() === '') {
                    if (!dataStarted) headerLines++;
                    return;
                }
                
                // Skip non-commented header lines (that contain letters)
                if (!dataStarted) {
                    if (/[a-zA-Z]/.test(line)) { 
                        headerLines++;
                        return;
                    }
                }

                const parts = line.trim().split(/[\s,;]+/);
                if (parts.length < 2) return;

                const x = parseFloat(parts[0]);
                const y = parseFloat(parts[1]);

                // If we get non-numeric data, it's either a header or a bad line
                if (isNaN(x) || isNaN(y)) {
                    if (!dataStarted) headerLines++; // Still in the header
                    return;
                }
                
                dataStarted = true; // First valid numeric pair found

                // --- vérif
                if (x > 0) positive_x_values++;

                if (last_x !== -Infinity) {
                    const dX = x - last_x;
                    if (dX < 0) {
                        negative_steps++; // Data is descending
                    } else if (dX > 0 && (dX < 0.0001 || dX > 0.2)) { 
                        suspicious_steps++; // Step size is weird
                    }
                }
                last_x = x;
                

                tth.push(x);
                intensity.push(y);
            });

            // --- Final checks (log warnings to console) ---
            if (tth.length > 10) { 
                if (positive_x_values / tth.length < 0.5) {
                    console.warn(`Data File (${fileName}) Warning: Most 2-theta (X) values are zero or negative. This is unusual for XRD data.`);
                }
                if (negative_steps / tth.length > 0.8) {
                     console.warn(`Data File (${fileName}) Warning: Data appears to be sorted in descending 2-theta order.`);
                }
                if (suspicious_steps / tth.length > 0.2) {
                    console.warn(`Data File (${fileName}) Warning: Many data points have a step size outside the typical range (0.0001° - 0.2°). Check file format.`);
                }
            } else if (tth.length === 0) {
                 throw new Error(`Could not parse any 2-column data from ${fileName}. File may be binary or have an unknown header.`);
            }

            return { tth, intensity };
        };

        const parseXrdmlFile = (xmlString) => { const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlString, "application/xml"); if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing XRDML file."); } let wavelength = null; const kAlpha1Node = xmlDoc.querySelector("kAlpha1"); if (kAlpha1Node?.textContent) wavelength = parseFloat(kAlpha1Node.textContent); const intensityNode = xmlDoc.querySelector("intensities") || xmlDoc.querySelector("counts"); if (!intensityNode) throw new Error("Could not find <intensities> or <counts> in XRDML file."); const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number); const positionsNode = xmlDoc.querySelector('positions[axis="2Theta"]'); if (!positionsNode) throw new Error("Could not find <positions> in XRDML file."); const startPosNode = positionsNode.querySelector("startPosition"); const endPosNode = positionsNode.querySelector("endPosition"); if (!startPosNode || !endPosNode) throw new Error("Could not find start/end positions in XRDML."); const startPos = parseFloat(startPosNode.textContent); const endPos = parseFloat(endPosNode.textContent); const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * (endPos - startPos) / (intensity.length - 1)); return { tth, intensity, wavelength }; };
        const parseBrukerBrmlFile = (xmlString) => { const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlString, "application/xml"); if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing BRML file."); } let wavelength = null; const wlNode = xmlDoc.querySelector('usedWavelength'); if (wlNode) { const kAlpha1 = wlNode.getAttribute('kAlpha1'); if (kAlpha1) wavelength = parseFloat(kAlpha1); } const intensityNode = xmlDoc.querySelector("dataPoints > counts"); if (!intensityNode) throw new Error("No <counts> data found in BRML file."); const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number); const startPosNode = xmlDoc.querySelector('startPosition[axis="TwoTheta"]'); const stepSizeNode = xmlDoc.querySelector('increment[axis="TwoTheta"]'); if (!startPosNode || !stepSizeNode) throw new Error("Could not find scan parameters in BRML file."); const startPos = parseFloat(startPosNode.textContent); const stepSize = parseFloat(stepSizeNode.textContent); const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * stepSize); return { tth, intensity, wavelength }; };
        const parseRigakuRasFile = (text) => { const lines = text.trim().split(/\r?\n/); const tth = [], intensity = []; let inDataSection = false; let wavelength = null; for (const line of lines) { const upperLine = line.toUpperCase(); if (upperLine.startsWith('*WAVE_LENGTH') || upperLine.startsWith('*MEAS_COND_XG_WAVE_LENGTH')) { const parts = line.trim().split(/\s+/); if (parts.length > 1) { const wl = parseFloat(parts[1]); if (!isNaN(wl)) wavelength = wl; } } if (upperLine.startsWith('*RAS_INT_START')) { inDataSection = true; continue; } if (upperLine.startsWith('*RAS_INT_END')) break; if (inDataSection) { const parts = line.trim().split(/[\s,]+/); if (parts.length >= 2) { const x = parseFloat(parts[0]); const y = parseFloat(parts[1]); if (!isNaN(x) && !isNaN(y)) { tth.push(x); intensity.push(y); } } } } if (tth.length === 0) throw new Error("No data found in RAS file data section."); return { tth, intensity, wavelength }; };
        const parseGsasEsdFile = (text) => { const lines = text.trim().split(/\r?\n/); let wavelength = null; let startTth, stepSize; let dataStartIndex = -1; lines.forEach((line, index) => { const upperLine = line.toUpperCase(); if (upperLine.includes('WAVELENGTH')) { const match = line.match(/wavelength\s+([0-9.]+)/i); if (match && match[1]) wavelength = parseFloat(match[1]); } if (upperLine.startsWith('BANK')) { const parts = line.trim().split(/\s+/); if (parts.length >= 6 && parts[4].toUpperCase() === 'CONST') { startTth = parseFloat(parts[5]) / 100.0; stepSize = parseFloat(parts[6]) / 100.0; dataStartIndex = index + 1; } } }); if (startTth === undefined || stepSize === undefined) throw new Error("GSAS Parse Error: Could not find a valid 'BANK' line with CONST scan parameters."); if (dataStartIndex !== -1 && lines[dataStartIndex]?.toUpperCase().includes('STD')) dataStartIndex++; if (dataStartIndex === -1 || dataStartIndex >= lines.length) throw new Error("GSAS Parse Error: Found scan parameters but no subsequent data lines."); const intensity = []; for (let i = dataStartIndex; i < lines.length; i++) { const parts = lines[i].trim().split(/\s+/); for (let j = 1; j < parts.length; j += 2) { const val = parseFloat(parts[j]); if (!isNaN(val)) intensity.push(val); } } if (intensity.length === 0) throw new Error("GSAS Parse Error: No intensity data could be parsed."); const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize); return { tth, intensity, wavelength }; };
        
        const parseGsasXraFile = (text) => {
    const lines = text.trim().split(/\r?\n/);
    let wavelength = null;
    let startTth, stepSize;
    let dataStartIndex = -1;
    lines.forEach((line, index) => {
        const upperLine = line.toUpperCase();
        if (upperLine.includes('WAVELENGTH')) {
            const match = line.match(/wavelength\s+([0-9.]+)/i);
            if (match && match[1]) wavelength = parseFloat(match[1]);
        }
        if (upperLine.startsWith('BANK')) {
            const parts = line.trim().split(/\s+/);
            if (parts.length >= 7 && parts[4].toUpperCase() === 'CONST') {
                startTth = parseFloat(parts[5]) / 100.0;
                stepSize = parseFloat(parts[6]) / 100.0;
                dataStartIndex = index + 1;
            }
        }
    });

    if (startTth === undefined || stepSize === undefined) throw new Error("GSAS XRA Parse Error: Could not find a valid 'BANK' line with CONST scan parameters.");
    if (dataStartIndex === -1 || dataStartIndex >= lines.length) throw new Error("GSAS XRA Parse Error: Found scan parameters but no subsequent data lines.");

    const intensity = [];
    for (let i = dataStartIndex; i < lines.length; i++) {
        if (lines[i].trim() === '') continue;
        const parts = lines[i].trim().split(/\s+/);
        for (let j = 0; j < parts.length; j++) {
            const val = parseFloat(parts[j]);
            if (!isNaN(val)) intensity.push(val);
        }
    }
    if (intensity.length === 0) throw new Error("GSAS XRA Parse Error: No intensity data could be parsed.");
    const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize);
    return { tth, intensity, wavelength };
};
        
        const parseUxdFile = (text) => { const lines = text.trim().split(/\r?\n/); const intensity = []; let startTth, stepSize, wavelength; let inDataSection = false; for (const line of lines) { const trimmedLine = line.trim(); if (inDataSection) { const parts = trimmedLine.split(/\s+/); parts.forEach(part => { const val = parseFloat(part); if (!isNaN(val)) intensity.push(val); }); } else { if (trimmedLine.toUpperCase().startsWith('_START=')) startTth = parseFloat(trimmedLine.substring(7)); else if (trimmedLine.toUpperCase().startsWith('_STEPSIZE=')) stepSize = parseFloat(trimmedLine.substring(10)); else if (trimmedLine.toUpperCase().startsWith('_WL1=')) wavelength = parseFloat(trimmedLine.substring(5)); else if (trimmedLine.toUpperCase() === '_COUNTS') inDataSection = true; } } if (startTth === undefined || stepSize === undefined) throw new Error("Could not find _START and _STEPSIZE in UXD file."); if (intensity.length === 0) throw new Error("No intensity data found after _COUNTS in UXD file."); const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize); return { tth, intensity, wavelength }; };
        const parsePhilipsUdfFile = (text) => { const lines = text.trim().split(/\r?\n/); const tth = [], intensity = []; let inDataSection = false; let wavelength = null; for (const line of lines) { const trimmedLine = line.trim(); if (trimmedLine.toUpperCase().startsWith('LAMBDA')) { const parts = trimmedLine.split('='); if (parts.length > 1) wavelength = parseFloat(parts[1]); } if (trimmedLine.toUpperCase() === '[DATA]') { inDataSection = true; continue; } if (trimmedLine.startsWith('[') && trimmedLine.toUpperCase() !== '[DATA]') inDataSection = false; if (inDataSection) { const parts = trimmedLine.split(/,/).map(p => p.trim()); if(parts.length >= 2) { const x = parseFloat(parts[0]); const y = parseFloat(parts[1]); if (!isNaN(x) && !isNaN(y)) { tth.push(x); intensity.push(y); } } } } if (tth.length === 0) throw new Error("No [Data] section found in UDF file."); return { tth, intensity, wavelength }; };



        // Global cache for the data used in fitting, 
        let workingData = {
            tth: [],
            intensity: [],
            weights: [],
            startIndex: 0, // Store the starting index from the full dataset
            lastRawDifference: [],
            isValid: false
        };

        /**
         * This function is the single source of truth for refinement data.
         * It slices the fullExperimentalData based on slider values and, critically,
         * pre-calculates the weights array using Float64Array for performance.
         */
        function updateWorkingData() {
            if (fullExperimentalData.tth.length === 0) {
                workingData.isValid = false;
                return;
            }
            const minTth = parseFloat(controls.tthMinSlider.value);
            const maxTth = parseFloat(controls.tthMaxSlider.value);

            // Find the start and end indices in the master 'fullExperimentalData' array
            let startIndex = fullExperimentalData.tth.findIndex(t => t >= minTth);
            if (startIndex === -1) startIndex = 0;

            let endIndex = fullExperimentalData.tth.findIndex(t => t > maxTth);
            if (endIndex === -1) endIndex = fullExperimentalData.tth.length;

            // Slice the master typed arrays; .slice() on a typed array returns a new typed array
            workingData.tth = fullExperimentalData.tth.slice(startIndex, endIndex);
            workingData.intensity = fullExperimentalData.intensity.slice(startIndex, endIndex);
            workingData.startIndex = startIndex; // Store the offset

            // Pre-calculate weights into a new Float64Array for performance
            const n = workingData.intensity.length;
            workingData.weights = new Float64Array(n);
            const anchorIndices = new Set(backgroundAnchors.map(a => a.index));
            
            const yMax = Math.max(...workingData.intensity);
            const floor = 0.001 * yMax; // Floor is 0.1% of maximum, similar to GSAS

            for (let i = 0; i < n; i++) {
                let weight = 1 / Math.max(floor, workingData.intensity[i]);
                if (anchorIndices.has(startIndex + i)) {
                    weight *= HIGH_WEIGHT_MULTIPLIER;
                }
                workingData.weights[i] = weight;
            }

            workingData.isValid = true;
        }



        function evaluateExpression(expr, h, k, l) {
            switch (expr.trim()) {
                case 'h+k': return h + k;
                case 'k+l': return k + l;
                case 'h+l': return h + l;
                case 'h+k+l': return h + k + l;
                case '-h+k+l': return -h + k + l;
                case 'h-k+l': return h - k + l;
                case '2h+l': return 2 * h + l;
                case 'h': return h;
                case 'k': return k;
                case 'l': return l;
                default: return NaN; // Return NaN for unknown expressions
            }
        }

        /**
 * Main entry point to check if a reflection is allowed by the space group rules.
 * @returns {boolean} True if the reflection is allowed.
 */
function isReflectionAllowed(h, k, l, spaceGroup) {
    const ruleTree = spaceGroup.rule_tree;

    // If no rules, all reflections are allowed
    if (!ruleTree || Object.keys(ruleTree).length === 0) {
        return true;
    }

    return evaluateRuleTree(h, k, l, ruleTree);
}

/**
 * Recursively evaluates the rule tree for a given reflection.
 * @returns {boolean} The result of the rule evaluation.
 */
function evaluateRuleTree(h, k, l, node) {
    // Handle logical operators (AND/OR)
    if (node.logic) {
        if (node.logic === "AND") {
            return node.rules.every(rule => evaluateRuleTree(h, k, l, rule));
        } else if (node.logic === "OR") {
            return node.rules.some(rule => evaluateRuleTree(h, k, l, rule));
        }
    }

    // Handle individual rule types
    if (node.type === "family_check") {
        const inFamily = isInFamily(h, k, l, node.family);
        // The 'inverse' flag means the rule applies if the reflection is NOT in the family
        return node.inverse ? !inFamily : inFamily;
    }

    if (node.type === "expression_check") {
        const value = evaluateExpression(h, k, l, node.expression);
        // The condition is met if the expression result is an even multiple of the divisor
        return !isNaN(value) && value % node.divisor === 0;
    }

    if (node.type === "parity") {
        if (node.rule === "all_even") {
            return h % 2 === 0 && k % 2 === 0 && l % 2 === 0;
        } else if (node.rule === "all_odd") {
            return h % 2 !== 0 && k % 2 !== 0 && l % 2 !== 0;
        }
    }

    // If a node doesn't match any known type, it's considered a pass
    return true;
}

/**
 * Checks if a given hkl triplet belongs to a specific reflection family.
 * @returns {boolean} True if the hkl is in the family.
 */
function isInFamily(h, k, l, family) {
    switch (family) {
        case "h00": return k === 0 && l === 0;
        case "0k0": return h === 0 && l === 0;
        case "00l": return h === 0 && k === 0;
        case "h0l": return k === 0;
        case "hk0": return l === 0;
        case "0kl": return h === 0;
        case "hhl": return h === k;
        case "hkk": return k === l;
        case "hhh": return h === k && k === l;
        default:    return false;
    }
}

/**
 * Safely evaluates a predefined crystallographic expression.
 * @returns {number|NaN} The result of the expression, or NaN if unknown.
 */
function evaluateExpression(h, k, l, expr) {
    switch (expr.trim()) {
        case 'h+k':   return h + k;
        case 'k+l':   return k + l;
        case 'h+l':   return h + l;
        case 'h+k+l': return h + k + l;
        case '-h+k+l':return -h + k + l;
        case '2h+l':  return 2 * h + l;
        case 'h':     return h;
        case 'k':     return k;
        case 'l':     return l;
        default:      return NaN; // Return NaN for unknown expressions
    }
}


// --- HKL Generation Functions (Needed for Preview in Main Thread) ---

        /**
         * Checks if a given hkl triplet belongs to a specific reflection family.
         * @returns {boolean} True if the hkl is in the family.
         */
        function isInFamily(h, k, l, family) {
            switch (family) {
                case "h00": return k === 0 && l === 0;
                case "0k0": return h === 0 && l === 0;
                case "00l": return h === 0 && k === 0;
                case "h0l": return k === 0;
                case "hk0": return l === 0;
                case "0kl": return h === 0;
                case "hhl": return h === k;
                case "hkk": return k === l;
                case "hhh": return h === k && k === l;
                default:    return false;
            }
        }

        /**
         * Safely evaluates a predefined crystallographic expression.
         * @returns {number|NaN} The result of the expression, or NaN if unknown.
         */
        function evaluateExpression(h, k, l, expr) {
            // Ensure expr is a string before calling trim
            const expression = typeof expr === 'string' ? expr.trim() : '';
            switch (expression) {
                case 'h+k':   return h + k;
                case 'k+l':   return k + l;
                case 'h+l':   return h + l;
                case 'h+k+l': return h + k + l;
                case '-h+k+l':return -h + k + l;
                 case 'h-k+l': return h - k + l; // Added missing case
                case '2h+l':  return 2 * h + l;
                case 'h':     return h;
                case 'k':     return k;
                case 'l':     return l;
                default:      return NaN; // Return NaN for unknown expressions
            }
        }

        /**
         * Recursively evaluates the rule tree for a given reflection.
         * @returns {boolean} The result of the rule evaluation.
         */
        function evaluateRuleTree(h, k, l, node) {
            // Handle logical operators (AND/OR)
            if (node.logic) {
                if (node.logic === "AND") {
                    // Ensure node.rules exists and is an array
                    return Array.isArray(node.rules) && node.rules.every(rule => evaluateRuleTree(h, k, l, rule));
                } else if (node.logic === "OR") {
                    // Ensure node.rules exists and is an array
                    return Array.isArray(node.rules) && node.rules.some(rule => evaluateRuleTree(h, k, l, rule));
                }
            }

            // Handle individual rule types
            if (node.type === "family_check") {
                const inFamily = isInFamily(h, k, l, node.family);
                // The 'inverse' flag means the rule applies if the reflection is NOT in the family
                return node.inverse ? !inFamily : inFamily;
            }

            if (node.type === "expression_check") {
                const value = evaluateExpression(h, k, l, node.expression);
                 // Check if divisor is valid before modulo operation
                 if (node.divisor === undefined || node.divisor === 0) return false; // Rule cannot be satisfied
                // The condition is met if the expression result is an even multiple of the divisor
                return !isNaN(value) && value % node.divisor === 0;
            }

            if (node.type === "parity") {
                if (node.rule === "all_even") {
                    return h % 2 === 0 && k % 2 === 0 && l % 2 === 0;
                } else if (node.rule === "all_odd") {
                     // Check absolute values for oddness if negative indices are possible
                    return Math.abs(h) % 2 !== 0 && Math.abs(k) % 2 !== 0 && Math.abs(l) % 2 !== 0;
                }
            }

            return true; // Default to allowing reflection if rule is unhandled/malformed
        }


        /**
         * Main entry point to check if a reflection is allowed by the space group rules.
         * @returns {boolean} True if the reflection is allowed.
         */
        function isReflectionAllowed(h, k, l, spaceGroup) {
             if (!spaceGroup || !spaceGroup.rule_tree) {
                 // console.warn("isReflectionAllowed: Invalid spaceGroup or missing rule_tree for SG:", spaceGroup?.number);
                 return true; // Allow if rules are missing
             }
            const ruleTree = spaceGroup.rule_tree;

            // If no rules defined in the tree, allow all reflections
            if (Object.keys(ruleTree).length === 0) {
                return true;
            }

            return evaluateRuleTree(h, k, l, ruleTree);
        }

        // --- Multiplicity Calculation (Keep in Main Thread for Preview) ---
        // (This function was previously removed, add it back)
        function getMultiplicityAndCanonicalHKL(h, k, l, laue_class) {
            if (h === 0 && k === 0 && l === 0) {
                return { multiplicity: 1, canonical_hkl_obj: [0, 0, 0] };
            }

            let m = 0;
             // Use absolute values for comparisons to handle negative indices correctly
             const abs_h = Math.abs(h);
             const abs_k = Math.abs(k);
             const abs_l = Math.abs(l);

             // Sort absolute values: h' >= k' >= l'
             let [h_p, k_p, l_p] = [abs_h, abs_k, abs_l].sort((a, b) => b - a);


            switch (laue_class) {
                 case 'm-3m':
                     if (h_p > k_p && k_p > l_p && l_p >= 0) m = 48;        // h > k > l > 0
                     else if (h_p === k_p && k_p > l_p && l_p >= 0) m = 24;  // h = k > l >= 0
                     else if (h_p > k_p && k_p === l_p && l_p >= 0) m = 24;  // h > k = l >= 0
                     // else if (h_p > l_p && k_p > l_p && h_p === k_p) m = 24; // Redundant with h=k>l
                     else if (h_p === k_p && k_p === l_p && l_p > 0) m = 8;   // h = k = l > 0
                     else if (h_p > 0 && k_p === 0 && l_p === 0) m = 6;       // h00
                     else if (h_p === k_p && l_p === 0 && h_p > 0) m = 12;      // hh0
                     else if (h_p > k_p && k_p > 0 && l_p === 0) m = 24;      // hk0 (h>k>0)
                     else m = 1; // Should not happen for non-zero hkl
                     break;
                 case 'm-3':
                      if (h_p > k_p && k_p > l_p && l_p >= 0) m = 24;        // h > k > l >= 0
                      else if ((h_p === k_p && k_p > l_p && l_p >= 0) || (h_p > k_p && k_p === l_p && l_p >= 0)) m = 12; // h=k>l>=0 or h>k=l>=0
                      else if (h_p === k_p && k_p === l_p && l_p > 0) m = 8;   // h=k=l>0
                      else if (h_p > 0 && k_p === 0 && l_p === 0) m = 6;       // h00
                      else if (h_p === k_p && l_p === 0 && h_p > 0) m = 12;      // hh0 - Correction: m-3 has 12 for hh0
                      else if (h_p > k_p && k_p > 0 && l_p === 0) m = 12;      // hk0 (h>k>0) - Correction: m-3 has 12 for hk0
                      else m = 1;
                      break;
                 case '6/mmm':
                     if (l_p > 0) { // l != 0
                          if (abs_h === 0 && abs_k === 0) m = 2; // 00l
                          else if (abs_h > 0 && abs_k === 0) m = 12; // h0l
                          else if (abs_h === abs_k && abs_k > 0) m = 12; // hhl
                          else if (abs_h > abs_k && abs_k >= 0) m = 24; // hkl, h>k>=0
                           // Need to consider 2hk.l, h h 2h .l etc for hexagonal? Usually handled by checking h,k,i=-h-k
                           // Assuming standard 3-index notation for now.
                          else m = 24; // Fallback general
                      } else { // l=0 plane
                          if (abs_h === 0 && abs_k === 0) m = 1; // Origin
                          else if (abs_h > 0 && abs_k === 0) m = 6; // h00
                          else if (abs_h === abs_k && abs_k > 0) m = 6; // hh0
                          else if (abs_h > abs_k && abs_k >= 0) m = 12; // hk0, h>k>=0
                          else m = 12; // Fallback general hk0
                      }
                      break;
                 case '6/m':
                      if (l_p > 0) m = (abs_h > 0 || abs_k > 0) ? 12 : 2; // 00l vs hkl/h0l/hhl etc.
                      else m = (abs_h > 0 || abs_k > 0) ? 6 : 1; // Origin vs hk0/h00/hh0
                      break;
                case '-3m': // Needs careful check for rhombohedral vs hexagonal indexing
                     // Using hexagonal axes convention
                     if (l_p !== 0) { // l != 0
                         if (abs_h === 0 && abs_k === 0) { m = 2; } // 00l
                         // Special conditions like h-k+l = 3n or -h+k+l = 3n might matter for R centering, handled by isReflectionAllowed
                         // Multiplicity based purely on Laue group symmetry:
                         else if (abs_h === 0 || abs_k === 0 || abs_h === abs_k) { m = 12; } // h0l, hhl, 0kl forms
                         else { m = 24; } // General hkl
                     } else { // l=0 plane
                         if (abs_h === 0 && abs_k === 0) { m = 1; } // Origin
                         else if (abs_h === 0 || abs_k === 0 || abs_h === abs_k) { m = 6; } // h00, hh0 forms
                         else { m = 12; } // General hk0
                     }
                     break;
                 case '-3':
                     if (abs_h === 0 && abs_k === 0 && l_p === 0) m = 1; // Origin
                     else if (abs_h === 0 && abs_k === 0) m = 2; // 00l
                     else m = 6; // General hkl and hk0
                     break;
                 case '4/mmm':
                     if (l_p > 0) { // l != 0
                         if (abs_h === 0 && abs_k === 0) m = 2; // 00l
                         else if (abs_h === 0 || abs_k === 0 || abs_h === abs_k) m = 8; // h0l, hhl forms
                         else m = 16; // General hkl
                     } else { // l=0 plane
                         if (abs_h === 0 && abs_k === 0) m = 1; // Origin
                         else if (abs_h === 0 || abs_k === 0 || abs_h === abs_k) m = 4; // h00, hh0 forms
                         else m = 8; // General hk0
                     }
                     break;
                 case '4/m':
                      if (l_p > 0) m = (abs_h > 0 || abs_k > 0) ? 8 : 2; // 00l vs hkl/h0l/hhl
                      else m = (abs_h > 0 || abs_k > 0) ? 4 : 1; // Origin vs hk0/h00/hh0
                      break;
                 case 'mmm':
                      if (abs_h > 0 && abs_k > 0 && l_p > 0) m = 8; // hkl
                      else if ((abs_h > 0 && abs_k > 0 && l_p === 0) || (abs_h > 0 && abs_k === 0 && l_p > 0) || (abs_h === 0 && abs_k > 0 && l_p > 0)) m = 4; // hk0, h0l, 0kl
                      else if (abs_h > 0 || abs_k > 0 || l_p > 0) m = 2; // h00, 0k0, 00l
                      else m = 1; // Origin
                      break;
                 case '2/m': // Assumes unique axis b
                      if (abs_k > 0) m = 4; // hkl, 0kl
                      else if (abs_k === 0 && (abs_h !== 0 || l_p !== 0)) m = 2; // h0l (including h00, 00l)
                      else m = 1; // Origin
                      break;
                 case '-1':
                      if (abs_h === 0 && abs_k === 0 && l_p === 0) m = 1; // Origin
                      else m = 2; // General hkl
                      break;
                default:
                    console.warn("Unknown Laue class in getMultiplicity:", laue_class, "- assuming multiplicity 1");
                    m = 1;
                    break;
            }
            // Simple canonical: return original h,k,l for now
            return { multiplicity: m, canonical_hkl_obj: [h, k, l] };
        }


        /**
         * Generates the list of raw HKL indices {h, k, l, multiplicity} for PREVIEW.
         * This version runs in the main thread and does NOT use the worker's cache.
         * @returns {Array} A list of raw HKL reflection objects.
         */
        function generateAndCacheHklIndices(spaceGroup, maxTth, params) {
            // NOTE: This version runs in the main thread for PREVIEW ONLY.
            // It does NOT interact with the worker's cache.

            if (!spaceGroup || !spaceGroup.number) {
                 console.error("Preview HKL Gen: Invalid spaceGroup object provided.");
                 return [];
            }
            const sgNumber = spaceGroup.number;

            const { a, b, c, lambda } = params;
            const { system, laue_class } = spaceGroup;
             if (!lambda || lambda <= 0 || !laue_class || !a || a <=0) {
                 console.error("Preview HKL Gen: Missing lambda, laue_class or invalid 'a'.");
                 return [];
             }

             const maxDim = Math.max(a || 0, b || a || 0, c || a || 0);
             if (maxDim <= 0) return [];

             const sinThetaMax = Math.sin(maxTth * Math.PI / 360);
              if (sinThetaMax <= 0) return []; // Avoid division by zero/negative dMin
             const dMinEstimate = lambda / (2 * sinThetaMax);
             const maxIndex = Math.ceil(maxDim / dMinEstimate) + 5;


            let rawReflections = [];
            const addedHKLs = new Set();
            const getKey = (h, k, l) => `${h},${k},${l}`;

            const loopAndAdd = (h, k, l) => {
                if (h === 0 && k === 0 && l === 0) return;
                const key = getKey(h, k, l);
                if (addedHKLs.has(key)) return;

                if (isReflectionAllowed(h, k, l, spaceGroup)) {
                    const { multiplicity } = getMultiplicityAndCanonicalHKL(h, k, l, laue_class);
                     if (multiplicity > 0) {
                         rawReflections.push({
                            h_orig: h,
                            k_orig: k,
                            l_orig: l,
                            hkl_list: [`(${h},${k},${l})`],
                            multiplicity: multiplicity
                        });
                        addedHKLs.add(key);
                     }
                }
            };

            // Simplified loops (adjust as needed per system for full coverage)
            const maxI = maxIndex;
            if (system === 'monoclinic' || system === 'triclinic') {
                for (let h = -maxI; h <= maxI; h++) for (let k = 0; k <= maxI; k++) for (let l = -maxI; l <= maxI; l++) loopAndAdd(h, k, l);
            } else if (system === 'orthorhombic') {
                for (let h = 0; h <= maxI; h++) for (let k = 0; k <= maxI; k++) for (let l = 0; l <= maxI; l++) loopAndAdd(h, k, l);
            } else if (system === 'hexagonal' || system === 'trigonal' || system === 'rhombohedral') {
                for (let h = 0; h <= maxI; h++) for (let k = 0; k <= maxI; k++) for (let l = -maxI; l <= maxI; l++) loopAndAdd(h, k, l);
            } else { // Cubic, Tetragonal
                for (let h = 0; h <= maxI; h++) for (let k = 0; k <= h; k++) for (let l = 0; l <= k; l++) loopAndAdd(h, k, l);
            }

            // --- IMPORTANT: DO NOT use hklIndexCache here ---
            // This function is only for the main thread's preview generation.
            return rawReflections;
        }

        // --- HKL Position Calculation (Needed for Preview in Main Thread) ---
        function updateHklPositions(hklList, params, system) {
            const { a, b, c, alpha, beta, lambda } = params;
            // Add validation checks at the beginning
            if (!hklList || hklList.length === 0) return; // No HKLs to update
            if (!params || !lambda || lambda <= 0 || !a || a <= 0) {
                 // console.warn("updateHklPositions: Invalid parameters (lambda or a).");
                 // Set all tth/d to null if params are bad
                 hklList.forEach(peak => { if(peak) { peak.tth = null; peak.d = null; } });
                 return;
             }


            const deg2rad = Math.PI / 180;
            const lambda_sq_over_4 = (lambda * lambda) / 4.0;
            const a_sq = a * a;

            let b_sq, c_sq, sin_beta_sq, cos_beta;
            if (system === 'monoclinic') {
                const beta_rad = (beta || 90) * deg2rad; // Default to 90 if undefined
                sin_beta_sq = Math.sin(beta_rad);
                sin_beta_sq *= sin_beta_sq;
                cos_beta = Math.cos(beta_rad);
                // Use 'a' as default if b or c are missing/invalid
                b_sq = (b && b > 0) ? (b * b) : a_sq;
                c_sq = (c && c > 0) ? (c * c) : a_sq;
                 // Add check for sin_beta_sq being too small (beta near 0 or 180)
                 if (Math.abs(sin_beta_sq) < 1e-9) {
                     // console.warn("updateHklPositions: Monoclinic beta angle is too close to 0 or 180.");
                     hklList.forEach(peak => { if(peak) { peak.tth = null; peak.d = null; } });
                     return;
                 }
            } else if (system === 'tetragonal' || system === 'hexagonal' || system === 'rhombohedral' || system === 'trigonal') {
                 c_sq = (c && c > 0) ? (c * c) : a_sq; // Use 'a' if c is invalid
            } else if (system === 'orthorhombic') {
                 b_sq = (b && b > 0) ? (b * b) : a_sq;
                 c_sq = (c && c > 0) ? (c * c) : a_sq;
            }


            hklList.forEach(peak => {
                if (!peak || peak.h_orig === undefined || peak.k_orig === undefined || peak.l_orig === undefined) {
                     if(peak) { peak.tth = null; peak.d = null; } // Invalidate if indices missing
                     return;
                }
                const h = peak.h_orig;
                const k = peak.k_orig;
                const l = peak.l_orig;
                const h2 = h * h;
                const k2 = k * k;
                const l2 = l * l;

                let inv_d_sq = 0;
                try { // Add try-catch for safety
                    switch(system) {
                        case 'cubic':
                            inv_d_sq = (h2 + k2 + l2) / a_sq;
                            break;
                        case 'tetragonal':
                            inv_d_sq = (h2 + k2) / a_sq + l2 / c_sq;
                            break;
                        case 'orthorhombic':
                            inv_d_sq = h2/a_sq + k2/b_sq + l2/c_sq;
                            break;
                        case 'hexagonal':
                        case 'rhombohedral': // Using hexagonal axes
                        case 'trigonal':     // Using hexagonal axes
                             // Check for division by zero
                             if (a_sq <= 0 || c_sq <= 0) throw new Error("Invalid lattice param");
                            inv_d_sq = 4 * (h2 + h*k + k2) / (3 * a_sq) + l2 / c_sq;
                            break;
                        case 'monoclinic':
                             // Check for division by zero (already checked sin_beta_sq)
                             if (a_sq <= 0 || b_sq <= 0 || c_sq <= 0 || a <= 0 || c <= 0) throw new Error("Invalid lattice param");
                            inv_d_sq = (1/sin_beta_sq) * (h2/a_sq + k2*sin_beta_sq/b_sq + l2/c_sq - (2*h*l*cos_beta)/(a*c));
                            break;
                         // Add triclinic if needed, complex formula
                         // case 'triclinic': ...
                        default:
                            throw new Error(`Unknown system: ${system}`);
                    }

                    // Validate inv_d_sq
                    if (!isFinite(inv_d_sq) || inv_d_sq <= 1e-12) { // Allow slightly negative due to float errors? No, should be positive.
                        peak.tth = null;
                        peak.d = null;
                    } else {
                        const sinThetaSq = lambda_sq_over_4 * inv_d_sq;
                        if (sinThetaSq <= 1 && sinThetaSq > 0) {
                             const thetaRad = Math.asin(Math.sqrt(sinThetaSq));
                             peak.tth = 2 * thetaRad / deg2rad; // Convert back to degrees
                            peak.d = 1 / Math.sqrt(inv_d_sq);
                        } else {
                            peak.tth = null; // Cannot calculate angle (sin^2 > 1 or <= 0)
                            peak.d = null;
                        }
                    }
                } catch (error) {
                     // console.error(`Error calculating d-spacing for HKL (${h},${k},${l}) in ${system}: ${error.message}`);
                     peak.tth = null;
                     peak.d = null;
                }

            }); // end forEach peak
        }
        // --- END HKL Position Calculation ---


        // --- Calculation Functions (Needed for Preview/Tooltips in Main Thread) ---

        /**
         * Calculates the total background contribution from Chebyshev polynomials and an amorphous hump.
         * Runs in the main thread for preview updates.
         * @param {Float64Array} tthAxis - The array of 2-theta values.
         * @param {object} params - The object containing all refinement parameters.
         * @returns {Float64Array} A new array containing the calculated background intensity at each point.
         */
        function calculateTotalBackground(tthAxis, params) {
            // --- 1. Pre-computation and setup ---
            const n = tthAxis.length;
            if (n === 0) {
                return new Float64Array();
            }

            const background = new Float64Array(n); // Allocate the typed array upfront

            // Extract and check Chebyshev parameters
            const chebyshevCoefficients = [];
            let hasChebyshev = false;
            // Use the global constant NUM_BACKGROUND_PARAMS defined in the main script
            for (let i = 0; i < NUM_BACKGROUND_PARAMS; i++) {
                const coeff = params[`B${i}`] || 0;
                chebyshevCoefficients[i] = coeff;
                if (Math.abs(coeff) > 1e-9) hasChebyshev = true;
            }

            // Extract and pre-calculate for Amorphous Hump
            const humpHeight = params.hump_H || 0;
            let hasHump = humpHeight > 1e-9;
            let humpPosition, hwhm_sq;
            if (hasHump) {
                humpPosition = params.hump_P || 0;
                const fwhm = params.hump_W || 1;
                hwhm_sq = (fwhm / 2) * (fwhm / 2);
                if (hwhm_sq < 1e-9) hasHump = false; // Avoid division by zero
            }

            // Pre-calculate scaling factors for Chebyshev
            let tthMin, tthRange;
            if (hasChebyshev && n > 0) { // Check length
                tthMin = tthAxis[0];
                tthRange = tthAxis[tthAxis.length - 1] - tthMin;
                if (tthRange <= 0) hasChebyshev = false; // Avoid division by zero
            } else {
                hasChebyshev = false;
            }


            // Early exit if there's nothing to calculate
            if (!hasChebyshev && !hasHump) {
                return background; // Return the zero-filled Float64Array
            }

            // --- 2. Single loop calculation ---
            for (let i = 0; i < n; i++) {
                const tth = tthAxis[i];
                let totalBackgroundValue = 0;

                // Calculate Chebyshev part if needed
                if (hasChebyshev) {
                    const x_prime = (2 * (tth - tthMin) / tthRange) - 1;

                    let t_n_minus_1 = 1; // T_0(x)
                    let t_n = x_prime; // T_1(x)

                    let chebyshevValue = chebyshevCoefficients[0] * t_n_minus_1;
                    if (chebyshevCoefficients.length > 1) {
                        chebyshevValue += (chebyshevCoefficients[1] || 0) * t_n;
                    }

                    for (let n = 2; n < chebyshevCoefficients.length; n++) {
                        const t_n_plus_1 = 2 * x_prime * t_n - t_n_minus_1;
                        chebyshevValue += (chebyshevCoefficients[n] || 0) * t_n_plus_1;
                        t_n_minus_1 = t_n;
                        t_n = t_n_plus_1;
                    }
                    totalBackgroundValue += chebyshevValue;
                }

                // Calculate Amorphous Hump part if needed
                if (hasHump) {
                    const diff = tth - humpPosition;
                    const humpValue = humpHeight / (1 + (diff * diff) / hwhm_sq);
                    totalBackgroundValue += humpValue;
                }

                background[i] = totalBackgroundValue;
            }

            return background;
        }

        // --- Profile Shape & Width (Needed for Preview/Tooltips) ---
        function calculatePeakShift(tth, params) {
             // Ensure params and profileType exist
             if (!params || !params.profileType) return 0;
            const profileType = String(params.profileType || "4"); // Ensure string

            if (profileType === "4") {
                const thetaRad = tth * (Math.PI / 180) / 2;
                // Handle edge case near 90 degrees 2theta (theta near PI/2)
                if (Math.abs(thetaRad - Math.PI / 2.0) < 1e-6) {
                     return 0; // Avoid potential division by zero or large shifts
                }
                const cosTheta = Math.cos(thetaRad);
                const sin2Theta = Math.sin(2 * thetaRad);
                // Ensure parameters exist, default to 0
                const shftParam = params.shft || 0;
                const trnsParam = params.trns || 0;

                const displacementShift = -(shftParam / 1000) * cosTheta * (180 / Math.PI);
                const transparencyShift = trnsParam * sin2Theta * (180 / Math.PI);
                 const totalShift = displacementShift + transparencyShift;
                 return isFinite(totalShift) ? totalShift : 0; // Ensure finite result
            } else {
                return 0; // No shift for TCH profile in this implementation
            }
        }

        function calculateProfileWidths(tth, hkl, params) {
             // Ensure params and profileType exist
             if (!params || !params.profileType) return { gamma_G: 1e-4, gamma_L: 1e-4 };
            const profileType = String(params.profileType || "4"); // Ensure string type
            const thetaRad = tth * (Math.PI / 180) / 2;

            // Prevent division by zero or tan(Infinity) at 90 degrees
            const MAX_ANGLE_RAD = Math.PI / 2.0 - 1e-6;
            const safeThetaRad = Math.min(thetaRad, MAX_ANGLE_RAD);
             if (safeThetaRad < 1e-6) { // Also handle angles near zero if needed
                 return { gamma_G: 1e-4, gamma_L: 1e-4 };
             }

            const tanTheta = Math.tan(safeThetaRad);
            const cosTheta = Math.cos(safeThetaRad);

            let gamma_G = 1e-4; // Default tiny width, strictly positive
            let gamma_L = 1e-4; // Default tiny width, strictly positive

            if (profileType === "4") {
                // --- Robust Simple pVoigt Calculation ---
                const GU = params.GU || 0;
                const GV = params.GV || 0;
                const GW = params.GW || 0;
                const GP = params.GP || 0;
                const LX = params.LX || 0;

                // Ensure cosTheta is not zero before dividing
                const cosThetaSq_safe = Math.max(cosTheta * cosTheta, 1e-9);
                const gamma_G_sq = GU * tanTheta * tanTheta + GV * tanTheta + GW + GP / cosThetaSq_safe;

                if (gamma_G_sq > 0 && isFinite(gamma_G_sq)) {
                    gamma_G = Math.sqrt(gamma_G_sq);
                } else {
                    gamma_G = 1e-4; // Fallback width
                }

                const cosTheta_safe = Math.max(cosTheta, 1e-9);
                const calculated_L = LX / cosTheta_safe;

                if (calculated_L > 0 && isFinite(calculated_L)) {
                    gamma_L = calculated_L;
                } else {
                     gamma_L = 1e-4; // Fallback width
                }

            } else { // Profile 3 (TCH)
                // --- TCH Profile Calculation ---
                 const U = params.U || 0;
                 const V = params.V || 0;
                 const W = params.W || 0;
                 const X = params.X || 0;
                 const Y = params.Y || 0;

                const gamma_G_sq = U * tanTheta * tanTheta + V * tanTheta + W;

                if (gamma_G_sq > 0 && isFinite(gamma_G_sq)) {
                    gamma_G = Math.sqrt(gamma_G_sq);
                } else {
                    gamma_G = 1e-4; // Fallback
                }

                const cosTheta_safe = Math.max(cosTheta, 1e-9);
                const calculated_L = X * tanTheta + Y / cosTheta_safe;

                if (calculated_L > 0 && isFinite(calculated_L)) {
                    gamma_L = calculated_L;
                } else {
                     gamma_L = 1e-4; // Fallback
                }

                // Anisotropic broadening (Stephens) - Profile 3 only
                 if (hkl && hkl.d && hkl.h_orig !== undefined) {
                     const d_sq = hkl.d * hkl.d;
                     if (d_sq > 1e-9) { // Avoid division by zero
                        const d_inv_sq = 1 / d_sq;
                        const h_val = hkl.h_orig;
                        const k_val = hkl.k_orig;
                        const l_val = hkl.l_orig;
                        const h2 = h_val * h_val, k2 = k_val * k_val, l2 = l_val * l_val;
                        const h4 = h2*h2, k4 = k2*k2, l4 = l2*l2;

                        const S400 = params.S400 || 0;
                        const S040 = params.S040 || 0;
                        const S004 = params.S004 || 0;
                        const S220 = params.S220 || 0;
                        const S202 = params.S202 || 0;
                        const S022 = params.S022 || 0;

                        let H_aniso = S400 * h4 + S040 * k4 + S004 * l4 +
                                      S220 * h2 * k2 + S202 * h2 * l2 + S022 * k2 * l2;
                        H_aniso *= d_inv_sq * d_inv_sq; // Example using d^-4 scaling

                        if(isFinite(H_aniso) && H_aniso > 0) {
                              gamma_L += H_aniso / 1000.0;
                        }
                    }
                }
            }

            // Final safeguard: ensure widths are always positive and finite
            return {
                gamma_G: Math.max(1e-4, isFinite(gamma_G) ? gamma_G : 1e-4),
                gamma_L: Math.max(1e-4, isFinite(gamma_L) ? gamma_L : 1e-4)
            };
        }

        /**
         * Calculates the total FWHM of a pseudo-Voigt peak from its Gaussian and Lorentzian components.
         * Runs in main thread for previews.
         */
        function getPeakFWHM(gamma_G, gamma_L) {
            // Ensure inputs are positive numbers
            const gG = Math.max(1e-9, gamma_G || 1e-9);
            const gL = Math.max(1e-9, gamma_L || 1e-9);

            // Thompson-Cox-Hastings approximation
            const fwhm_g_5 = Math.pow(gG, 5);
            const fwhm_l_5 = Math.pow(gL, 5);
            const fwhm_g_4_l = Math.pow(gG, 4) * gL;
            const fwhm_g_3_l_2 = Math.pow(gG, 3) * Math.pow(gL, 2);
            const fwhm_g_2_l_3 = Math.pow(gG, 2) * Math.pow(gL, 3);
            const fwhm_g_l_4 = gG * Math.pow(gL, 4);

            const fwhm_pow5 = fwhm_g_5 +
                              2.69269 * fwhm_g_4_l +
                              2.42843 * fwhm_g_3_l_2 +
                              4.47163 * fwhm_g_2_l_3 +
                              0.07842 * fwhm_g_l_4 +
                              fwhm_l_5;

             if (fwhm_pow5 < 0 || !isFinite(fwhm_pow5)) return Math.max(gG, gL, 1e-6); // Fallback

             const fwhm = Math.pow(fwhm_pow5, 0.2);
             return Math.max(1e-6, fwhm); // Ensure minimum positive FWHM
        }

        /**
         * Calculates the integrated area under a pseudo-Voigt peak shape.
         * Runs in main thread for previews.
         */
        function getPseudoVoigtArea(gamma_G, gamma_L, params) {
            const GAUSS_AREA_CONST = 1.0644677; // sqrt(pi / (4*ln(2)))
            const LORENTZ_AREA_CONST = 1.5707963; // pi / 2

            // Ensure params and profileType exist
             if (!params || !params.profileType) return 1.0; // Default area? Or throw error?
            const profileType = String(params.profileType || "4");
            const gG = Math.max(1e-9, gamma_G || 1e-9); // Ensure positive widths
            const gL = Math.max(1e-9, gamma_L || 1e-9);


            if (profileType === "4") {
                const area_G = gG * GAUSS_AREA_CONST;
                const area_L = gL * LORENTZ_AREA_CONST;
                const currentEta = Math.max(0, Math.min(1, params.eta || 0.5));
                const totalArea = currentEta * area_L + (1 - currentEta) * area_G;
                 return isFinite(totalArea) && totalArea > 0 ? totalArea : 1.0; // Ensure positive finite area

            } else { // TCH Profile (Type 3)
                const fwhm = getPeakFWHM(gG, gL);

                const ratio = (fwhm > 1e-9) ? gL / fwhm : 0;
                const eta_calc = 1.36603 * ratio - 0.47719 * (ratio * ratio) + 0.11116 * Math.pow(ratio, 3);
                const currentEta = Math.max(0, Math.min(1, eta_calc));

                const area_G_combined = fwhm * GAUSS_AREA_CONST;
                const area_L_combined = fwhm * LORENTZ_AREA_CONST;
                const totalArea = currentEta * area_L_combined + (1 - currentEta) * area_G_combined;
                 return isFinite(totalArea) && totalArea > 0 ? totalArea : 1.0; // Ensure positive finite area
            }
        }

        /**
         * Applies asymmetry correction. Runs in main thread for previews.
         */
        function applyAsymmetry(x, x0, tth_peak, params) {
            // Ensure params exist
            if (!params) return x - x0;
            const profileType = String(params.profileType || "4");

            // No asymmetry for profile 4 or if SL/HL are zero/missing
            if (profileType === "4" || (!params.SL && !params.HL)) {
                return x - x0;
            }

            const delta_2theta = x - x0;
            if (Math.abs(delta_2theta) < 1e-9) return 0;
            if (tth_peak < 0.1 || tth_peak >= 180) return delta_2theta; // Invalid peak position

            const theta_rad = tth_peak * (Math.PI / 180) / 2.0;
            const safe_theta_rad = Math.max(1e-6, Math.min(Math.PI / 2.0 - 1e-6, theta_rad));
            const tan_theta = Math.tan(safe_theta_rad);
            if (Math.abs(tan_theta) < 1e-9) return delta_2theta;
            const cot_theta = 1.0 / tan_theta;

            const SL = params.SL || 0;
            const HL = params.HL || 0;
            const asymmetry_param = SL * cot_theta + HL;
            if (!isFinite(asymmetry_param)) return delta_2theta;

            const correction_term = asymmetry_param * Math.abs(delta_2theta);
            const MAX_CORRECTION_EFFECT = 0.95;
            // Ensure factor is positive and not too close to zero
            const asymmetry_factor = Math.max(1e-6, 1.0 - Math.min(Math.abs(correction_term), MAX_CORRECTION_EFFECT));

            const corrected = delta_2theta / asymmetry_factor;
             return isFinite(corrected) ? corrected : delta_2theta; // Fallback if calculation fails
        }

        /**
         * Calculates the pseudo-Voigt peak shape value. Runs in main thread for previews.
         */
        function pseudoVoigt(x, x0, tth_peak, gamma_G, gamma_L, params) {
             // Ensure params exist
             if (!params) return 0.0;
             const H_G = Math.max(1e-9, gamma_G || 1e-9);
             const H_L = Math.max(1e-9, gamma_L || 1e-9);

            const corrected_delta = applyAsymmetry(x, x0, tth_peak, params);
            if (Math.abs(corrected_delta) > 10 * (H_G + H_L)) return 0.0;

            const profileType = String(params.profileType || "4");
            const Cg = 2.772588722239781; // 4 * ln(2)

            let result = 0.0;
            try { // Add try-catch for safety during calculation
                 if (profileType === "4") {
                     const currentEta = Math.max(0, Math.min(1, params.eta || 0.5));
                     const delta_over_Hg_sq = Math.pow(corrected_delta / H_G, 2);
                     const delta_over_Hl_sq = Math.pow(corrected_delta / H_L, 2);
                     const gaussianShape = Math.exp(-Cg * delta_over_Hg_sq);
                     const lorentzianShape = 1 / (1 + 4 * delta_over_Hl_sq);
                     result = currentEta * lorentzianShape + (1 - currentEta) * gaussianShape;
                 } else { // TCH (Profile 3)
                     const fwhm = getPeakFWHM(H_G, H_L);
                     if (fwhm <= 1e-9) return Math.abs(corrected_delta) < 1e-6 ? 1.0 : 0.0; // Approx delta

                     const ratio = H_L / fwhm;
                     const eta_calc = 1.36603 * ratio - 0.47719 * (ratio * ratio) + 0.11116 * Math.pow(ratio, 3);
                     const currentEta = Math.max(0, Math.min(1, eta_calc));

                     const delta_over_fwhm_sq = Math.pow(corrected_delta / fwhm, 2);
                     const gaussianShape = Math.exp(-Cg * delta_over_fwhm_sq);
                     const lorentzianShape = 1 / (1 + 4 * delta_over_fwhm_sq);
                     result = currentEta * lorentzianShape + (1 - currentEta) * gaussianShape;
                 }
            } catch (calcError) {
                 console.warn("Error in pseudoVoigt calculation:", calcError);
                 return 0.0; // Return 0 if any math error occurs
            }

             return (isFinite(result) && result >= 0) ? result : 0.0; // Ensure non-negative finite result
        }

        /**
         * Calculates the overall diffraction pattern. Runs in main thread for previews.
         */
        function calculatePattern(tthAxis, hklList, params) {
             // Ensure params exist
             if (!params) return new Float64Array(tthAxis ? tthAxis.length : 0);

            const n_points = tthAxis ? tthAxis.length : 0;
            if (n_points === 0 || !hklList || hklList.length === 0) {
                return new Float64Array(n_points);
            }

            const pattern = new Float64Array(n_points);
            const deg2rad = Math.PI / 180;
            const lambda1 = params.lambda || 1.54056;
            const lambda2 = params.lambda2 || 0;
            const ratio21 = params.ratio || 0;
            const zeroShift = params.zeroShift || 0;
            // Use global constants for calculation window and cutoff
            const WINDOW_MULT = CALCULATION_WINDOW_MULTIPLIER;
            const HEIGHT_CUTOFF = PEAK_HEIGHT_CUTOFF;


            // --- K-alpha 1 ---
            hklList.forEach(peak => {
                if (!peak || !peak.intensity || peak.intensity <= 0 || !peak.tth || peak.tth < 0 || peak.tth > 180) return;

                const basePos1 = peak.tth + zeroShift;
                const shift1 = calculatePeakShift(basePos1, params);
                const peakPos1 = basePos1 + shift1;
                const { gamma_G, gamma_L } = calculateProfileWidths(basePos1, peak, params);
                const shapeArea1 = getPseudoVoigtArea(gamma_G, gamma_L, params);
                if (shapeArea1 <= 1e-9 || !isFinite(shapeArea1)) return;

                const fwhm_approx1 = getPeakFWHM(gamma_G, gamma_L);
                const window1 = WINDOW_MULT * Math.max(0.01, fwhm_approx1);
                const min_tth1 = peakPos1 - window1;
                const max_tth1 = peakPos1 + window1;

                let startIndex = 0;
                while (startIndex < n_points && tthAxis[startIndex] < min_tth1) startIndex++;
                if (startIndex === n_points) return;

                for (let i = startIndex; i < n_points; i++) {
                    const current_tth = tthAxis[i];
                    if (current_tth > max_tth1) break;
                    const intensityAtPoint = pseudoVoigt(current_tth, peakPos1, basePos1, gamma_G, gamma_L, params);
                    if (intensityAtPoint > HEIGHT_CUTOFF) {
                        pattern[i] += peak.intensity * (intensityAtPoint / shapeArea1);
                    }
                }
            });

            // --- K-alpha 2 ---
            const doubletEnabled = ratio21 > 1e-6 && lambda2 > 1e-6 && Math.abs(lambda1 - lambda2) > 1e-6;
            if (doubletEnabled) {
                const lambdaRatio = lambda2 / lambda1;
                hklList.forEach(peak => {
                    if (!peak || !peak.intensity || peak.intensity <= 0 || !peak.tth || peak.tth <= 0 || peak.tth >= 180) return;

                    const sinTheta1 = Math.sin(peak.tth * deg2rad / 2.0);
                    const sinTheta2 = sinTheta1 * lambdaRatio;
                    if (Math.abs(sinTheta2) >= 1) return;

                    const tth2 = 2 * Math.asin(sinTheta2) / deg2rad;
                    const basePos2 = tth2 + zeroShift;
                    const shift2 = calculatePeakShift(basePos2, params);
                    const peakPos2 = basePos2 + shift2;
                    const { gamma_G: gG2, gamma_L: gL2 } = calculateProfileWidths(basePos2, peak, params);
                    const shapeArea2 = getPseudoVoigtArea(gG2, gL2, params);
                    if (shapeArea2 <= 1e-9 || !isFinite(shapeArea2)) return;

                    const fwhm_approx2 = getPeakFWHM(gG2, gL2);
                    const window2 = WINDOW_MULT * Math.max(0.01, fwhm_approx2);
                    const min_tth2 = peakPos2 - window2;
                    const max_tth2 = peakPos2 + window2;

                    let startIndex2 = 0;
                    while (startIndex2 < n_points && tthAxis[startIndex2] < min_tth2) startIndex2++;
                    if (startIndex2 === n_points) return;

                    for (let i = startIndex2; i < n_points; i++) {
                        const current_tth = tthAxis[i];
                        if (current_tth > max_tth2) break;
                        const intensityAtPoint = pseudoVoigt(current_tth, peakPos2, basePos2, gG2, gL2, params);
                        if (intensityAtPoint > HEIGHT_CUTOFF) {
                            pattern[i] += peak.intensity * ratio21 * (intensityAtPoint / shapeArea2);
                        }
                    }
                });
            }

            // Final check for NaNs/Infinities in the pattern
            for (let i = 0; i < n_points; i++) {
                if (!isFinite(pattern[i])) {
                    pattern[i] = 0; // Replace invalid numbers with zero
                }
            }

            return pattern;
        }


        // --- END Calculation Functions for Main Thread ---

        // master HKL, 1.0.3 et ensuite
        // This function now uses the cache to get raw indices and then calculates positions.
function generateMasterHklList() {
    if (fullExperimentalData.tth.length === 0 || spaceGroups.length === 0) {
        masterHklList = [];
        updatePreviewPattern();
        return;
    }

    const selectedSgNumber = parseInt(controls.spaceGroupSelect.value, 10);
    const selectedSg = spaceGroups.find(sg => sg.number === selectedSgNumber);
    if (!selectedSg) {
        masterHklList = [];
        console.error("Cannot generate HKL list: selected space group not found.");
        updatePreviewPattern();
        return;
    }

    const maxTth = Math.max(...fullExperimentalData.tth) + 2.0;
    const params = getAllParams();

    // 1. Get raw HKL indices. This is the key step that uses the new caching function.
    const rawHklIndices = generateAndCacheHklIndices(selectedSg, maxTth, params);

    // 2. Create a deep copy to work with, so we don't modify the cached version.
    let workingHklList = JSON.parse(JSON.stringify(rawHklIndices));

    // 3. Calculate the 2-theta positions for the current parameters.
    updateHklPositions(workingHklList, params, selectedSg.system);

    // 4. Filter out peaks that are outside the range, sort them, and assign to the global list.
    masterHklList = workingHklList
        .filter(peak => peak.tth !== null && peak.tth <= maxTth)
        .sort((a, b) => a.tth - b.tth);

    // Add a default intensity property for preview purposes
    masterHklList.forEach(peak => {
        peak.intensity = peak.intensity || 0;
    });

    updatePreviewPattern();
}



        function updateBackgroundForPreview() {
            if (fullExperimentalData.tth.length === 0 || isFitting) return;

            const params = getAllParams();
            calculatedBackground = calculateTotalBackground(fullExperimentalData.tth, params);

            if (mainChart) {
                // ---Save the current Y-axis zoom state ---
                const currentYMin = mainChart.scales.y.min;
                const currentYMax = mainChart.scales.y.max;

                const backgroundDataset = mainChart.data.datasets.find(d => d.label === 'Background');
                if (backgroundDataset) {
                    backgroundDataset.data = fullExperimentalData.tth.map((t, i) => ({ x: t, y: calculatedBackground[i] }));
                }
                
                updatePreviewPattern(); 
                
                // --Restore the Y-axis zoom state before updating ---
                mainChart.options.scales.y.min = currentYMin;
                mainChart.options.scales.y.max = currentYMax;
                
                mainChart.update('none');
            }
        }





/**
 * Performs a Williamson-Hall analysis using the refined TCH profile parameters.
 * @param {object} params - The final refined parameters object (containing U, X, Y, lambda).
 * @param {Array<object>} hklList - The list of HKL reflections with their 2-theta positions.
 * @returns {object|null} An object with size, strain, and R-squared, or null if calculation fails.
 */
function calculateWilliamsonHall(params, hklList) {
    // This analysis is only valid for the TCH profile which separates size/strain contributions.
    if (params.profileType === "4" || params.U === undefined || params.X === undefined || params.Y === undefined) {
        return null;
    }

    const points = [];
    const deg2rad = Math.PI / 180;
    const workingTthMin = workingData.tth[0];
    const workingTthMax = workingData.tth[workingData.tth.length - 1];

    hklList.forEach(peak => {
        // Only include peaks within the currently fitted range for the analysis.
        if (!peak.tth || peak.tth < workingTthMin || peak.tth > workingTthMax) {
            return;
        }

        const theta_rad = peak.tth * deg2rad / 2.0;
        const cosTheta = Math.cos(theta_rad);
        const tanTheta = Math.tan(theta_rad);

        // Step 1: Calculate sample-only breadth components (in degrees) by ignoring instrumental V and W.
        const beta_G_sq = (params.U || 0) * tanTheta * tanTheta;
        const beta_G = beta_G_sq > 0 ? Math.sqrt(beta_G_sq) : 0;
        const beta_L = (params.X || 0) * tanTheta + (params.Y || 0) / cosTheta;
        
        // Step 2: Combine them using the TCH FWHM approximation to get the total sample breadth.
        const fwhm_g_5 = Math.pow(beta_G, 5);
        const fwhm_l_5 = Math.pow(beta_L, 5);
        const fwhm_g_4_l = 2.69269 * Math.pow(beta_G, 4) * beta_L;
        const fwhm_g_3_l_2 = 2.42843 * Math.pow(beta_G, 3) * Math.pow(beta_L, 2);
        const fwhm_g_2_l_3 = 4.47163 * Math.pow(beta_G, 2) * Math.pow(beta_L, 3);
        const fwhm_g_l_4 = 0.07842 * beta_G * Math.pow(beta_L, 4);
        const beta_sample_deg = Math.pow(fwhm_g_5 + fwhm_g_4_l + fwhm_g_3_l_2 + fwhm_g_2_l_3 + fwhm_g_l_4 + fwhm_l_5, 0.2);

        if (beta_sample_deg <= 1e-6) return; // Ignore zero-width peaks.

        // Step 3: Convert breadth to radians for the W-H equation.
        const beta_sample_rad = beta_sample_deg * deg2rad;

        // Step 4: Calculate the coordinates for the W-H plot.
        const x = Math.sin(theta_rad);          // x-axis is sin(theta)
        const y = beta_sample_rad * cosTheta;   // y-axis is beta * cos(theta)
        points.push({ x, y });
    });

    if (points.length < 2) return null; // Need at least 2 points for a linear fit.

    // Step 5: Perform a linear regression (y = mx + c) to find slope (m) and intercept (c).
    let sum_x = 0, sum_y = 0, sum_xy = 0, sum_x_sq = 0, sum_y_sq = 0;
    const n = points.length;
    points.forEach(p => {
        sum_x += p.x;
        sum_y += p.y;
        sum_xy += p.x * p.y;
        sum_x_sq += p.x * p.x;
        sum_y_sq += p.y * p.y;
    });

    const m_slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x_sq - sum_x * sum_x);
    const c_intercept = (sum_y - m_slope * sum_x) / n;

    // Calculate R-squared for goodness of fit.
    const ss_xx = sum_x_sq - (sum_x * sum_x) / n;
    const ss_yy = sum_y_sq - (sum_y * sum_y) / n;
    const ss_xy = sum_xy - (sum_x * sum_y) / n;
    const r_squared = (ss_xx === 0 || ss_yy === 0) ? 1 : Math.pow(ss_xy, 2) / (ss_xx * ss_yy);

    // Step 6: Extract physical parameters from the slope and intercept.
    const K_scherrer = 0.9; // Scherrer constant, typically 0.9.
    const lambda = params.lambda;

    // From intercept: c = K * lambda / L  => L = K * lambda / c
    const crystallite_size_A = (c_intercept > 1e-9) ? (K_scherrer * lambda) / c_intercept : Infinity;
    const crystallite_size_nm = crystallite_size_A / 10.0;

    // From slope: m = 4 * epsilon => epsilon = m / 4
    const microstrain = m_slope / 4.0;
    const microstrain_percent = microstrain * 100;

    return {
        size_nm: crystallite_size_nm,
        strain_percent: microstrain_percent,
        r_squared: r_squared
    };
}


        function redrawFitForNewRange() {
            if (!mainChart) return; 

            const currentYMin = mainChart.scales.y.min;
            const currentYMax = mainChart.scales.y.max;

            updateWorkingData();

            if (!fitResults) {
                updatePreviewPattern();
            } else {
                const params = fitResults.params;
                const scaleFactor = fitResults.stats.scaleFactor;
                
                const background_sliced = calculateTotalBackground(workingData.tth, params);
                const unscaledPeakPattern_sliced = calculatePattern(workingData.tth, fitResults.hklList, params);
                
                const totalCalcPattern = numeric.add(numeric.mul(unscaledPeakPattern_sliced, scaleFactor), background_sliced);

                
    const diff = numeric.sub(workingData.intensity, totalCalcPattern);

                workingData.lastRawDifference = diff;
                
                const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
                
                const calculatedData = [];
                const backgroundData = [];
                for(let i = 0; i < workingData.tth.length; i++) {
                    calculatedData.push({ x: workingData.tth[i], y: totalCalcPattern[i] });
                    backgroundData.push({ x: workingData.tth[i], y: background_sliced[i] });
                }

                findDataset('Calculated').data = calculatedData;
                findDataset('Background').data = backgroundData;
                findDataset('Simulation (Manual)').data = [];
            }
            
            rescalePlot(false);
            
            mainChart.options.scales.x.min = parseFloat(controls.tthMinSlider.value);
            mainChart.options.scales.x.max = parseFloat(controls.tthMaxSlider.value);
            mainChart.options.scales.y.min = currentYMin;
            mainChart.options.scales.y.max = currentYMax;
            
            mainChart.update('none');
        }

// pour pas commencer avec un bruit de fond débile
function estimateBackgroundParameters(tth, intensity) {
    if (tth.length < 100) return null; // Not enough data for a reliable estimate

    // --- 1. Identify background points by finding the minimum in chunks ---
    const backgroundPoints = [];
    // Divide the pattern into roughly 50 chunks to find local minima
    const chunkSize = Math.max(50, Math.floor(tth.length / 50)); 
    for (let i = 0; i < tth.length; i += chunkSize) {
        const chunkIntensity = intensity.slice(i, i + chunkSize);
        const chunkTth = tth.slice(i, i + chunkSize);
        if (chunkIntensity.length === 0) continue;

        let minVal = Infinity;
        let minIndex = -1;
        for (let j = 0; j < chunkIntensity.length; j++) {
            if (chunkIntensity[j] < minVal) {
                minVal = chunkIntensity[j];
                minIndex = j;
            }
        }
        if (minIndex !== -1) {
            backgroundPoints.push({ x: chunkTth[minIndex], y: minVal });
        }
    }

    if (backgroundPoints.length < NUM_BACKGROUND_PARAMS+1) return null; // Need N+1 points for N-degree polynomial

    // --- 2. Perform a 5-term Chebyshev polynomial fit on these points ---
    const N = NUM_BACKGROUND_PARAMS; // Fit B0 to...
    const M = backgroundPoints.length;
    const tthMin = tth[0];
    const tthMax = tth[tth.length - 1];
    const tthRange = tthMax - tthMin;
    if (tthRange <= 0) return null;

    const A = []; // Matrix for normal equations
    const b = []; // Vector for normal equations

    backgroundPoints.forEach(point => {
        const x_prime = (2 * (point.x - tthMin) / tthRange) - 1;
        const row = [];
        let T_prev = 1;       // T0
        let T_curr = x_prime; // T1
        row.push(T_prev);
        if (N > 1) row.push(T_curr);

        for (let n = 2; n < N; n++) {
            const T_next = 2 * x_prime * T_curr - T_prev;
            row.push(T_next);
            T_prev = T_curr;
            T_curr = T_next;
        }
        A.push(row);
        b.push(point.y);
    });

    try {

        const At = numeric.transpose(A);
    const AtA = numeric.dot(At, A);
    const Atb = numeric.dot(At, b);
    const coeffs = numeric.solve(AtA, Atb);

        if (coeffs && coeffs.length === N) {
            const bgParams = {};
            coeffs.forEach((c, i) => bgParams[`B${i}`] = c);
            return bgParams;
        }
    } catch (error) {
        console.error("Background estimation fit failed:", error);
        return null;
    }

    return null;
}


        // runFit function - NOW SENDS DATA TO WORKER, depuis le 24 oct 2025
        let workerWorkingData = null; // Store the data sent to the worker for result display

        function runFit(refinementMode) {
            if (isFitting) {
                 console.warn("Fit already in progress.");
                 return;
            }
             if (!refinementWorker) {
                 showToast("Refinement worker is not available. Cannot start fit.", "error");
                 return; // Prevent running if worker failed to load
             }


            isFitting = true;
            setUIState(true);
            updateWorkingData(); // Prepare the data slice

            if (masterHklList.length === 0) {
                 showToast("Could not find a list of reflections. Please select a space group first. Aborting fit.", "error");
                 isFitting = false; setUIState(false); return;
            }

            const currentParams = getAllParams();
            const fitFlags = getFitFlags();
            const selectedSgNumber = parseInt(controls.spaceGroupSelect.value, 10);
            const selectedSg = spaceGroups.find(sg => sg.number === selectedSgNumber);
            if (!selectedSg) {
                 showToast("Error: Could not find selected space group data.", "error");
                 isFitting = false; setUIState(false); return;
             }

            const system = selectedSg.system; // Make sure this matches worker logic
            const maxIterations = parseInt(controls.iterationsSlider.value);
            const algorithm = controls.algorithmSelect.value;

            if (!workingData.isValid || workingData.tth.length === 0) {
                showToast("No data in the selected 2-theta range. Aborting fit.", "error");
                isFitting = false; setUIState(false); return;
            }

             // Store the data being sent FOR LATER when displaying results
             workerWorkingData = {
                 tth: workingData.tth.slice(), // Send copies
                 intensity: workingData.intensity.slice(),
                 weights: workingData.weights.slice(),
                 startIndex: workingData.startIndex
             };

            // --- Prepare data payload for the worker ---
             const workerPayload = {
                 initialParams: currentParams,
                 fitFlags: fitFlags,
                 workingData: workerWorkingData, // Send the sliced data
                 masterHklList: JSON.parse(JSON.stringify(masterHklList)), // Send a deep copy
                 spaceGroupsData: spaceGroups, // Send all space group definitions
                 selectedSgNumber: selectedSgNumber,
                 system: system,
                 maxIterations: maxIterations,
                 algorithm: algorithm,
                 refinementMode: refinementMode
             };

            // --- Send data to worker ---
            try {
                 console.log("Sending data to worker:", { // Log subset for brevity
                     algorithm: algorithm,
                     mode: refinementMode,
                     numPoints: workerPayload.workingData.tth.length,
                     numHkls: workerPayload.masterHklList.length,
                     params: Object.keys(workerPayload.initialParams).length
                 });
                 refinementWorker.postMessage(workerPayload);
                 controls.progressBar.style.width = '0%'; // Reset progress bar visually
                 controls.progressBar.style.transition = 'none'; // Disable transition for reset
            } catch (error) {
                console.error("Error sending message to worker:", error);
                showToast(`Error starting refinement: ${error.message}`, "error");
                isFitting = false;
                setUIState(false);
            }
        }



        const getAllParams = () => {
            const profileType = controls.profileSelect.value;
            let params = {
                lambda: parseFloat(controls.wavelength.value),
                lambda2: parseFloat(controls.wavelength2.value), 
                ratio: parseFloat(controls.ratio21.value),       
                zeroShift: parseFloat(controls.zeroShift.value),
                profileType: profileType
            };
            
            document.querySelectorAll('#lattice-parameters-container input[type="number"]').forEach(input => {
                if (input.id.startsWith('lattice-param-')) {
                    const paramName = input.id.replace('lattice-param-', '');
                    params[paramName] = parseFloat(input.value);
                }
            });

            const { system } = getSystemAndCentering();

            switch(system) {
                case 'cubic': case 'tetragonal': case 'orthorhombic': 
                    params.alpha = params.beta = params.gamma = 90; 
                    break;
                case 'rhombohedral':
                case 'hexagonal': 
                    params.alpha = params.beta = 90; params.gamma = 120; 
                    break;
                case 'monoclinic': 
                    params.alpha = params.gamma = 90; 
                    break;
            }

            if (profileType === "4") {
                Object.assign(params, { 
                    GU: parseFloat(controls.paramGU.value), GV: parseFloat(controls.paramGV.value), 
                    GW: parseFloat(controls.paramGW.value), GP: parseFloat(controls.paramGP.value), 
                    LX: parseFloat(controls.paramLX.value), eta: parseFloat(controls.paramEta.value), 
                    shft: parseFloat(controls.paramShft.value), trns: parseFloat(controls.paramTrns.value) 
                });
            } else {
                Object.assign(params, { 
                    U: parseFloat(controls.paramU.value), V: parseFloat(controls.paramV.value), 
                    W: parseFloat(controls.paramW.value), X: parseFloat(controls.paramX.value), 
                    Y: parseFloat(controls.paramY.value), SL: parseFloat(controls.paramSL.value), 
                    HL: parseFloat(controls.paramHL.value), S400: parseFloat(controls.paramS400.value), 
                    S040: parseFloat(controls.paramS040.value), S004: parseFloat(controls.paramS004.value), 
                    S220: parseFloat(controls.paramS220.value), S202: parseFloat(controls.paramS202.value), 
                    S022: parseFloat(controls.paramS022.value) 
                });
            }

            // Add Chebyshev and Hump parameters
            for (let i = 0; i < NUM_BACKGROUND_PARAMS; i++) {
                const input = document.getElementById(`param-b${i}`);
                if (input) params[`B${i}`] = parseFloat(input.value);
            }
            params['hump_H'] = parseFloat(document.getElementById('param-hump-h').value);
            params['hump_P'] = parseFloat(document.getElementById('param-hump-p').value);
            params['hump_W'] = parseFloat(document.getElementById('param-hump-w').value);

            return params;
        };
       
        const getFitFlags = () => {
            const profileType = controls.profileSelect.value;
            let flags = {
                a: document.getElementById('fit-lattice-a')?.checked ?? false,
                b: document.getElementById('fit-lattice-b')?.checked ?? false,
                c: document.getElementById('fit-lattice-c')?.checked ?? false,
                alpha: document.getElementById('fit-lattice-alpha')?.checked ?? false,
                beta: document.getElementById('fit-lattice-beta')?.checked ?? false,
                gamma: document.getElementById('fit-lattice-gamma')?.checked ?? false,
                zeroShift: controls.fitZeroShift.checked,
            };
            if (profileType === "4") {
                Object.assign(flags, { GU: controls.fitGU.checked, GV: controls.fitGV.checked, GW: controls.fitGW.checked, GP: controls.fitGP.checked, LX: controls.fitLX.checked, eta: controls.fitEta.checked, shft: controls.fitShft.checked, trns: controls.fitTrns.checked });
            } else {
                Object.assign(flags, { U: controls.fitU.checked, V: controls.fitV.checked, W: controls.fitW.checked, X: controls.fitX.checked, Y: controls.fitY.checked, SL: controls.fitSL.checked, HL: controls.fitHL.checked });
                if (profileType === "3") {
                    Object.assign(flags, { S400: controls.fitS400.checked, S040: controls.fitS040.checked, S004: controls.fitS004.checked, S220: controls.fitS220.checked, S202: controls.fitS202.checked, S022: controls.fitS022.checked });
                    const { system } = getSystemAndCentering();
                    switch (system) {
                        case 'cubic': flags.S040 = flags.S004 = flags.S202 = flags.S022 = false; break;
                        case 'hexagonal': case 'tetragonal': case 'rhombohedral': flags.S040 = flags.S022 = false; break;
                    }
                }
            }

            // Add Chebyshev and Hump flags
            for (let i = 0; i < NUM_BACKGROUND_PARAMS; i++) {
                const checkbox = document.getElementById(`fit-b${i}`);
                if (checkbox) flags[`B${i}`] = checkbox.checked;
            }
            flags['hump_H'] = document.getElementById('fit-hump-h').checked;
            flags['hump_P'] = document.getElementById('fit-hump-p').checked;
            flags['hump_W'] = document.getElementById('fit-hump-w').checked;

            return flags;
        };



/**
 * Clears the cached HKL index list for the currently selected space group.
 * This forces a full recalculation on the next request.
 */
function invalidateHklCache() {
    const selectedSgNumber = parseInt(controls.spaceGroupSelect.value, 10);
    if (selectedSgNumber && hklIndexCache[selectedSgNumber]) {
        delete hklIndexCache[selectedSgNumber];
    }
}


/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was invoked.
 * @param {Function} func The function to debounce.
 * @param {number} wait The number of milliseconds to delay.
 * @returns {Function} Returns the new debounced function.
 */
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
};



        function enforceSymmetryConstraints(params) { const { system } = getSystemAndCentering(); switch (system) { case 'cubic': if (params.S400 !== undefined) params.S040 = params.S004 = params.S400; if (params.S220 !== undefined) params.S202 = params.S022 = params.S220; break; case 'hexagonal': case 'tetragonal': case 'rhombohedral': if (params.S400 !== undefined) params.S040 = params.S400; if (params.S202 !== undefined) params.S022 = params.S202; break; } }


        function updatePreviewPattern() {
            if (!mainChart || !workingData.isValid || isFitting) return;

            const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
            const params = getAllParams();
            if (isNaN(params.lambda) || params.lambda <= 0 || isNaN(params.a) || params.a <= 0) return;
            
            const selectedSg = spaceGroups.find(sg => sg.number === parseInt(controls.spaceGroupSelect.value, 10));
            if (!selectedSg) return;

            let hklList = JSON.parse(JSON.stringify(masterHklList));
            updateHklPositions(hklList, params, selectedSg.system);
            lastGeneratedHklList = hklList; 

            if (lastFitResultsCache && lastFitResultsCache.hklList) {
                const intensityMap = new Map(
                    lastFitResultsCache.hklList.map(p => [p.hkl_list[0], p.intensity])
                );
                hklList.forEach(p => {
                    p.intensity = intensityMap.get(p.hkl_list[0]) || 0;
                });
            } else {
                hklList.forEach(p => p.intensity = 1000); 
            }
            
            const minTth = parseFloat(controls.tthMinSlider.value); 
            const maxTth = parseFloat(controls.tthMaxSlider.value);

            findDataset('HKL Markers').data = hklList
                .filter(hkl => {
                    if (!hkl.tth) return false;
                    const peakPos = hkl.tth + params.zeroShift;
                    return peakPos >= minTth && peakPos <= maxTth;
                })
                .map(hkl => ({
                    x: hkl.tth + params.zeroShift,
                    hkl: `${hkl.hkl_list[0]} [m=${hkl.multiplicity}]`
                }));

            const background_sliced = calculateTotalBackground(workingData.tth, params);
            const unscaledPeakPattern_sliced = calculatePattern(workingData.tth, hklList, params);
            const y_obs_net_sliced = new Float64Array(workingData.intensity.length);
            for(let i = 0; i < y_obs_net_sliced.length; i++) {
                y_obs_net_sliced[i] = Math.max(0, workingData.intensity[i] - background_sliced[i]);
            }
            
            const sum_obs_calc = numeric.dot(y_obs_net_sliced, unscaledPeakPattern_sliced);
    const sum_calc_sq = numeric.dot(unscaledPeakPattern_sliced, unscaledPeakPattern_sliced);
            const scaleFactor = (sum_calc_sq > 1e-9) ? sum_obs_calc / sum_calc_sq : 1.0;

            const totalCalcPattern = numeric.add(numeric.mul(unscaledPeakPattern_sliced, scaleFactor), background_sliced);
            
    const diff = numeric.sub(workingData.intensity, totalCalcPattern);

            workingData.lastRawDifference = diff;

            const simulationData = [];
            for (let i = 0; i < workingData.tth.length; i++) {
                simulationData.push({ x: workingData.tth[i], y: totalCalcPattern[i] });
            }
            findDataset('Simulation (Manual)').data = simulationData;
            findDataset('Calculated').data = [];
        }


        function updatePawleyButtonState() {
    if (!controls || !controls.algorithmSelect || !document.getElementById('pawley-button')) {
         console.error("Cannot update Pawley button: Controls not ready.");
         return; // Safety check
    }
    const selectedAlgorithm = controls.algorithmSelect.value;
    const pawleyButton = document.getElementById('pawley-button');
    const fileLoaded = fullExperimentalData && fullExperimentalData.tth.length > 0;

    // Disable Pawley if algorithm is SA or PT, OR if no file is loaded, OR if currently fitting
    if (selectedAlgorithm === 'sa' || selectedAlgorithm === 'pt' || !fileLoaded || isFitting) {
        pawleyButton.disabled = true;
        if (selectedAlgorithm === 'sa' || selectedAlgorithm === 'pt') {
             // Optionally add a title to explain why it's disabled
             pawleyButton.title = "Pawley refinement is recommended only with Levenberg-Marquardt.";
        } else {
             pawleyButton.title = ""; // Clear title if disabled for other reasons
        }
    } else {
        // Enable Pawley only for LM when a file is loaded and not fitting
        pawleyButton.disabled = false;
        pawleyButton.title = ""; // Clear title
    }
}



        // setUIState function
        function setUIState(fitting) {
        isFitting = fitting;
        const leBailButton = document.getElementById('le-bail-button');
        // const pawleyButton = document.getElementById('pawley-button'); // We handle this in updatePawleyButtonState

        // Disable Le Bail if fitting OR no file loaded
        leBailButton.disabled = fitting || (fullExperimentalData && fullExperimentalData.tth.length === 0);

        // Disable Report/Save if fitting OR no results exist
        controls.reportButton.disabled = fitting || !fitResults;
        controls.saveDataButton.disabled = fitting || !fitResults;

        // Update text content during refinement
        if (fitting) {
            leBailButton.textContent = 'Refining...';
            // Update Pawley button text too, even if disabled
            document.getElementById('pawley-button').textContent = 'Refining...';
            controls.rpResult.textContent = '...';
            controls.rwpResult.textContent = '...';
            controls.chi2Result.textContent = '...';
        } else {
            // Restore button text when not fitting
            leBailButton.textContent = 'Run Le Bail';
            document.getElementById('pawley-button').textContent = 'Run Pawley';
            if(fitResults) {
                 // Report/Save enabled state handled above based on !fitting and fitResults
            }
             // Clear background color highlights for results
            controls.rwpResult.parentElement.parentElement.querySelectorAll('.result-card').forEach(c => c.style.background = '');
        }

        controls.progressBarContainer.classList.toggle('hidden', !fitting);
        document.body.style.cursor = fitting ? 'wait' : 'default';
        if (!fitting) {
            controls.progressBar.style.width = '0%';
        }

   
        // Update Pawley button based on algorithm AND current fitting state
        updatePawleyButtonState();
    }
        
    function updateUI(params, stats, netPeakPattern_full, background_full, scaleFactor, hklList) {
            const safeUpdate = (paramValue, controlElement, digits) => { 
                if (controlElement && typeof paramValue === 'number' && isFinite(paramValue)) {
                    controlElement.value = paramValue.toFixed(digits);
                }
            };
            
            if (stats && typeof stats.r_p === 'number') controls.rpResult.textContent = stats.r_p.toFixed(2);
            if (stats && typeof stats.rwp === 'number') controls.rwpResult.textContent = stats.rwp.toFixed(2);
            if (stats && typeof stats.chi2 === 'number') controls.chi2Result.textContent = stats.chi2.toFixed(3);
            
            // Update lattice, zero shift, and profile parameters
            safeUpdate(params.a, document.getElementById('lattice-param-a'), 4);
            safeUpdate(params.b, document.getElementById('lattice-param-b'), 4);
            safeUpdate(params.c, document.getElementById('lattice-param-c'), 4);
            safeUpdate(params.alpha, document.getElementById('lattice-param-alpha'), 3);
            safeUpdate(params.beta, document.getElementById('lattice-param-beta'), 3);
            safeUpdate(params.gamma, document.getElementById('lattice-param-gamma'), 3);
            safeUpdate(params.zeroShift, controls.zeroShift, 4);
            
            const profileType = params.profileType || controls.profileSelect.value;
            if (profileType === "4") {
                safeUpdate(params.GU, controls.paramGU, 4); safeUpdate(params.GV, controls.paramGV, 4);
                safeUpdate(params.GW, controls.paramGW, 4); safeUpdate(params.GP, controls.paramGP, 4);
                safeUpdate(params.LX, controls.paramLX, 4); safeUpdate(params.eta, controls.paramEta, 4);
                safeUpdate(params.shft, controls.paramShft, 4); safeUpdate(params.trns, controls.paramTrns, 4);
            } else {
                safeUpdate(params.U, controls.paramU, 4); safeUpdate(params.V, controls.paramV, 4);
                safeUpdate(params.W, controls.paramW, 4); safeUpdate(params.X, controls.paramX, 4);
                safeUpdate(params.Y, controls.paramY, 4); safeUpdate(params.SL, controls.paramSL, 4);
                safeUpdate(params.HL, controls.paramHL, 4);
                if (profileType === "3") {
                    safeUpdate(params.S400, controls.paramS400, 4); safeUpdate(params.S040, controls.paramS040, 4);
                    safeUpdate(params.S004, controls.paramS004, 4); safeUpdate(params.S220, controls.paramS220, 4);
                    safeUpdate(params.S202, controls.paramS202, 4); safeUpdate(params.S022, controls.paramS022, 4);
                }
            }
            
            // --- Update background parameter inputs 
            for (let i = 0; i < NUM_BACKGROUND_PARAMS; i++) {
                safeUpdate(params[`B${i}`], document.getElementById(`param-b${i}`), 4);
            }
            safeUpdate(params.hump_H, document.getElementById('param-hump-h'), 4);
            safeUpdate(params.hump_P, document.getElementById('param-hump-p'), 4);
            safeUpdate(params.hump_W, document.getElementById('param-hump-w'), 4);

            if (netPeakPattern_full && background_full && hklList && mainChart) {
                updateChart(netPeakPattern_full, background_full, hklList, params, scaleFactor);
            }
        }

        //updateChart, sans Y auto zoom, le 7 oct 25
        function updateChart(netPeakPattern_sliced, background_sliced, hklList, params, scaleFactor = 1.0) {
            if (!mainChart || !workingData.isValid) return;

            // Store the current Y-axis zoom state BEFORE making any changes
            const currentYMin = mainChart.scales.y.min;
            const currentYMax = mainChart.scales.y.max;
            
            // --- ADDED THIS BLOCK ---
            // Store the current X-axis zoom state as well
            const currentXMin = mainChart.scales.x.min;
            const currentXMax = mainChart.scales.x.max;
            // --- END OF ADDED BLOCK ---

            const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
            
            // 1. Hide the manual simulation line, as we now have a real fit
            findDataset('Simulation (Manual)').data = [];

            // 2. Calculate the total pattern and the raw difference array
            const totalCalcPattern = numeric.add(numeric.mul(netPeakPattern_sliced, scaleFactor), background_sliced);
            
            const diff = numeric.sub(workingData.intensity, totalCalcPattern);

            // This global variable is now ready for rescalePlot to use
            workingData.lastRawDifference = diff; 

            // 3. Prepare the data for the 'Calculated' and 'Background' datasets
            const calculatedData = [];
            const backgroundData = [];
            for(let i = 0; i < workingData.tth.length; i++) {
                calculatedData.push({ x: workingData.tth[i], y: totalCalcPattern[i] });
                backgroundData.push({ x: workingData.tth[i], y: background_sliced[i] });
            }
            findDataset('Calculated').data = calculatedData;
            findDataset('Background').data = backgroundData;


            // 4. Restore the Y-axis zoom state FIRST. This sets the final "frame" for the chart.
            mainChart.options.scales.y.min = currentYMin;
            mainChart.options.scales.y.max = currentYMax;

           
            // 4b. Restore the X-axis zoom state.
            mainChart.options.scales.x.min = currentXMin;
            mainChart.options.scales.x.max = currentXMax;
           
            rescalePlot(false); 
            
            mainChart.update('none');
        }

        function getPeakInfoAt(tth) {
            if (!lastGeneratedHklList || lastGeneratedHklList.length === 0 || !mainChart) return { peak: null, inRegion: false };
            let closestPeak = null, minDiff = Infinity; const currentParams = getAllParams(); const zeroShift = currentParams.zeroShift || 0;
            for (const hkl of lastGeneratedHklList) { const peakShift = calculatePeakShift(hkl.tth, currentParams); const peakPos = hkl.tth + zeroShift + peakShift; const diff = Math.abs(tth - peakPos); if (diff < minDiff) { minDiff = diff; closestPeak = hkl; } }
            if (closestPeak) { 
                const threshold = 0.2;
                   if (minDiff < threshold) return { peak: closestPeak, inRegion: true }; }
            return { peak: null, inRegion: false };
        }


        function initializeChart() {
            if (mainChart) mainChart.destroy();

            const experimentalPoints = [];
            for (let i = 0; i < fullExperimentalData.tth.length; i++) {
                experimentalPoints.push({ x: fullExperimentalData.tth[i], y: fullExperimentalData.intensity[i] });
            }
            
            const yMax = Math.max(...fullExperimentalData.intensity) || 1000;
            mainChart = new Chart(controls.mainChartCanvas, {
                type: 'line',
                data: { 
                    datasets: [
                        { label: 'Experimental', data: experimentalPoints, borderColor: 'rgba(107, 114, 128, 0.7)', borderWidth: 0.5, pointRadius: 1, pointBackgroundColor: 'rgba(107, 114, 128, 0.7)', order: 1 },
                        { label: 'Simulation (Manual)', data: [], borderColor: 'rgba(249, 115, 22, 0.8)', borderWidth: 2, pointRadius: 0, borderDash: [8, 4], order: 2 },
                        { label: 'Calculated', data: [], borderColor: 'rgba(59, 130, 246, 1)', borderWidth: 2, pointRadius: 0, order: 3 },
                        { label: 'Background', data: [], borderColor: 'rgba(2, 9, 206, 0.8)', borderWidth: 1.5, pointRadius: 0, borderDash: [5, 5], order: 4 },
                        { label: 'Difference', data: [], borderColor: 'rgba(239, 68, 68, 0.8)', borderWidth: 1.5, pointRadius: 0, order: 5 },
                        { label: 'Difference Zero', data: [], borderColor: 'rgba(156, 163, 175, 0.8)', borderWidth: 1, pointRadius: 0, borderDash: [2, 2], order: 6 },
                        { type: 'bar', label: 'HKL Markers', data: [], backgroundColor: 'rgba(22, 163, 74, 0.9)', barThickness: 1, categoryPercentage: 1.0, barPercentage: 1.0, order: 0 },
                        {
                            label: 'Anchor Points',
                            type: 'scatter',
                            data: [], // Initially empty
                            showLine: false,
                            pointBackgroundColor: 'rgba(34, 197, 94, 1)', // A vibrant green
                            pointBorderColor: 'rgba(255, 255, 255, 0.9)',
                            pointRadius: 5,
                            pointHoverRadius: 7,
                            pointBorderWidth: 1.5,
                            order: -1 // Render on top of everything
                        }
                    ]
                },
                options: {
                    responsive: true, maintainAspectRatio: false, animation: false,
                    scales: {
                        x: { type: 'linear', title: { display: true, text: '2θ (degrees)', font: { size: 14 }}},
                        y: { type: 'linear', position: 'left', title: { display: true, text: 'Intensity (a.u.)', font: { size: 14 }},
                            min: -yMax * 0.3, max: Math.ceil(yMax * 1.1),
                            ticks: { callback: function(value, index, ticks) { return value >= 0 ? value.toFixed(1) : null; }}
                        }
                    },
                    plugins: {
                        zoom: {
                            pan: { enabled: true, mode: 'xy', threshold: 5, onPanComplete: () => rescalePlot(false) },
                            zoom: { wheel: { enabled: false }, pinch: { enabled: true }, drag: { enabled: false }, onZoomComplete: () => rescalePlot(false) }
                        },
                        legend: { labels: { filter: item => item.text !== 'Difference Zero' && item.text !== 'Simulation (Manual)' && item.text !== 'Anchor Points'}},
                        tooltip: {
                            enabled: true,
                            mode: 'nearest',
                            intersect: false,
                            position: 'experimentalAnchor',
                            filter: function(tooltipItem) {
                                const tth = tooltipItem.parsed.x;
                                const peakInfo = getPeakInfoAt(tth);
                                return peakInfo.inRegion;
                            },
                            callbacks: {
                                title: function(tooltipItems) {
                                    if (!tooltipItems.length) return '';
                                    const tth = tooltipItems[0].parsed.x;
                                    const peakInfo = getPeakInfoAt(tth);
                                    if (peakInfo.inRegion) {
                                        const closestPeak = peakInfo.peak;
                                        return `d: ${closestPeak.d.toFixed(2)} Å, HKL: ${closestPeak.hkl_list[0]}`;
                                    }
                                    return '';
                                },
                                label: function(context) {
                                    return null;
                                }
                            }
                        }
                    }
                }
            });
            mainChart.options.globalYMax = yMax;
        }


    function updatePlotRange(recalculateYMax = false) {
            if (!mainChart || workingData.tth.length === 0) {
                return;
            }
            const minTth = parseFloat(controls.tthMinSlider.value);
            const maxTth = parseFloat(controls.tthMaxSlider.value);

            // Explicitly set the x-axis limits
            mainChart.options.scales.x.min = minTth;
            mainChart.options.scales.x.max = maxTth;

            // Recalculate Y-axis if needed
            if (recalculateYMax) {
                // Find the max intensity within the current workingData range
                const currentMaxY = Math.max(...workingData.intensity);
                let newYMax = currentMaxY * 1.1; // Add 10% padding
                if (newYMax < 100) newYMax = 100; // Minimum Y-max

                // Constant negative space for difference plot
                mainChart.options.globalYMax = newYMax; // Store this globally
                mainChart.options.scales.y.max = newYMax;
                mainChart.options.scales.y.min = -(newYMax * 0.3); // Allocate 30% for difference plot
            }
            
            mainChart.update('none');
        }        

        function rescalePlot(updateY = false) {
        // === CONFIGURABLE PARAMETERS FOR DIFFERENCE PLOT ===
        const DIFF_PLOT_MIN_RATIO = 0.1;  // Minimum allocation: 10% of Y scale
        const DIFF_PLOT_MAX_RATIO = 0.3;  // Maximum allocation: 30% of Y scale
        const DIFF_PLOT_PADDING = 1.1;     // Padding factor (1.1 = 10% extra space)
        // =======

        if (!mainChart || !workingData.isValid) return;

        const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
        const globalYMax = mainChart.options.globalYMax;

        // --- DYNAMIC DIFFERENCE PLOT ALLOCATION ---
        let diffPlotHeightRatio = 0.15; // Default allocation

        // This is the source of truth for the difference plot's magnitude
        const diffData = workingData.lastRawDifference || [];
        
        if (diffData.length > 0) {
            const maxAbsDiff = Math.max(...diffData.map(Math.abs));
            if (globalYMax > 0) {
                const requiredRatio = (maxAbsDiff * DIFF_PLOT_PADDING) / globalYMax;
                diffPlotHeightRatio = Math.max(DIFF_PLOT_MIN_RATIO, Math.min(DIFF_PLOT_MAX_RATIO, requiredRatio));
            }
        }

        const constantNegSpaceHeight = globalYMax * diffPlotHeightRatio;

        // Update Y-axis 
        if (updateY) {
            mainChart.options.scales.y.max = globalYMax;
            // --- This line was moved inside the if(updateY) block ---
            mainChart.options.scales.y.min = -constantNegSpaceHeight;
        }
        
        // --- The problematic line was REMOVED from here ---
        
        // Draw HKL Markers
        const hklDataset = findDataset('HKL Markers');
        if (hklDataset && hklDataset.data.length > 0) {
            const HKL_MARKER_PIXEL_HEIGHT = 20;
            const y_scale = mainChart.scales.y;
            const zeroLineValue = 0; 
            const bottomPixel = y_scale.getPixelForValue(zeroLineValue);
            const topPixel = bottomPixel + HKL_MARKER_PIXEL_HEIGHT;
            const markerBottom = zeroLineValue;
            const markerTop = y_scale.getValueForPixel(topPixel);
            hklDataset.data.forEach(point => point.y = [markerTop, markerBottom]);
        }


        // --- Plot TRUE difference from the stored `lastRawDifference` array ---
        if (diffData.length > 0 && diffData.length === workingData.tth.length) {
            const constantDiffPlotSpaceTop = -(constantNegSpaceHeight * 0.25);
            const diffPlotZeroLine = -constantNegSpaceHeight + (constantNegSpaceHeight - constantDiffPlotSpaceTop) / 2;

            const differenceDataPoints = [];
            for (let i = 0; i < workingData.tth.length; i++) {
                const difference = diffData[i];
                differenceDataPoints.push({ x: workingData.tth[i], y: difference + diffPlotZeroLine });
            }
            findDataset('Difference').data = differenceDataPoints;

            findDataset('Difference Zero').data = [
                { x: workingData.tth[0], y: diffPlotZeroLine },
                { x: workingData.tth[workingData.tth.length - 1], y: diffPlotZeroLine }
            ];
        } else {
            // If there's no valid difference data, clear the lines.
            findDataset('Difference').data = [];
            findDataset('Difference Zero').data = [];
        }
    }

        function downloadTextFile(content, filename) {
            const element = document.createElement('a');
            const file = new Blob([content], {type: 'text/plain;charset=utf-8'});
            element.href = URL.createObjectURL(file);
            element.download = filename;
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
        }


        function showToast(message, type = 'error', duration = 4000) {
            let container = document.getElementById('toast-container');
            if (!container) {
                container = document.createElement('div');
                container.id = 'toast-container';
                document.body.appendChild(container);
            }

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;

            container.appendChild(toast);

            // Trigger the slide-in animation
            setTimeout(() => {
                toast.classList.add('show');
            }, 10);

            // Set a timer to hide and then remove the toast
            setTimeout(() => {
                toast.classList.remove('show');
                // Remove the element from the DOM after the fade-out transition completes
                toast.addEventListener('transitionend', () => toast.remove());
            }, duration);
        }


        /**
         * Calculates the observed integrated intensity for all peaks by partitioning the net
         * experimental intensity at each point according to the calculated profile shapes.
         * This correctly handles overlapping reflections.
         * @param {Array<object>} hklList - The list of HKL reflections.
         * @param {object} params - The final refined parameters object.
         * @param {object} expData - The working experimental data {tth, intensity}.
         * @returns {Map<string, number>} A map where keys are HKL strings and values are the calculated I_obs.
         */
        function calculateAllObservedIntensities(hklList, params, expData) {
            const n_points = expData.tth.length;
            if (n_points === 0) return new Map();

            const peak_profiles = new Array(hklList.length);
            const total_profile_sum = new Array(n_points).fill(0);

            // 1. Pre-calculate the theoretical shape (profile) for every peak
            hklList.forEach((peak, j) => {
                const current_peak_profile = new Array(n_points).fill(0);
                if (!peak.tth) {
                    peak_profiles[j] = current_peak_profile;
                    return;
                }
                
                const basePos = peak.tth + params.zeroShift;
                const shift = calculatePeakShift(basePos, params);
                const peakPos = basePos + shift;
                const { gamma_G, gamma_L } = calculateProfileWidths(basePos, peak, params);

                const window = CALCULATION_WINDOW_MULTIPLIER * Math.max(0.01, gamma_G + gamma_L);
                const min_tth = peakPos - window;
                const max_tth = peakPos + window;

                let startIndex = 0;
                while(startIndex < n_points && expData.tth[startIndex] < min_tth) startIndex++;

                for (let i = startIndex; i < n_points; i++) {
                    const current_tth = expData.tth[i];
                    if (current_tth > max_tth) break;
                    
                    const profile_val = pseudoVoigt(current_tth, peakPos, basePos, gamma_G, gamma_L, params);
                    if (profile_val > PEAK_HEIGHT_CUTOFF) {
                        current_peak_profile[i] = profile_val;
                        total_profile_sum[i] += profile_val;
                    }
                }
                peak_profiles[j] = current_peak_profile;
            });

            // 2. Partition the experimental intensity and integrate
            const finalBkg = calculateTotalBackground(expData.tth, params);
            const i_obs_map = new Map();

            for (let i = 1; i < n_points; i++) {
                const step_width = expData.tth[i] - expData.tth[i-1];
                const prev_y_obs_net = expData.intensity[i-1] - finalBkg[i-1];
                const current_y_obs_net = expData.intensity[i] - finalBkg[i];

                hklList.forEach((peak, j) => {
                    const hkl_string = peak.hkl_list[0];
                    if (!i_obs_map.has(hkl_string)) {
                        i_obs_map.set(hkl_string, 0);
                    }

                    const prev_fraction = total_profile_sum[i-1] > 1e-9 ? peak_profiles[j][i-1] / total_profile_sum[i-1] : 0;
                    const current_fraction = total_profile_sum[i] > 1e-9 ? peak_profiles[j][i] / total_profile_sum[i] : 0;
                    
                    const prev_partitioned_I = prev_y_obs_net * prev_fraction;
                    const current_partitioned_I = current_y_obs_net * current_fraction;
                    
                    const trapezoid_area = (prev_partitioned_I + current_partitioned_I) / 2 * step_width;
                    if (trapezoid_area > 0) {
                        i_obs_map.set(hkl_string, i_obs_map.get(hkl_string) + trapezoid_area);
                    }
                });
            }
            return i_obs_map;
        }

        /**
         * Generates a text report summarizing or detailing the refinement results.
         * Includes ESD calculation if Levenberg-Marquardt was used.
         * @param {string} format - 'summary' (parameters only) or 'full' (includes point data).
         * @returns {string} The formatted report content.
         */
        function generateReportContent(format = 'summary') {
            // Ensure fit results and necessary data are available
            if (!fitResults || !fitResults.params || !fitResults.stats || !fitResults.fitFlags || !fitResults.hklList) {
                return "Error: Fit results are incomplete or not available.";
            }
             // Need workingData (the slice used for fitting) for ESD calculation N
            if (fitResults.algorithm === 'lm' && (!workerWorkingData || !workerWorkingData.intensity || workerWorkingData.intensity.length === 0)) {
                 console.warn("generateReportContent: workingData slice not available for ESD calculation.");
                 // Proceed without ESDs or return an error? Proceeding without ESDs.
            }


            const now = new Date();
            // Destructure results for easier access
            const { params: finalParams, stats, fitFlags, hklList, algorithm, refinementMode, JtJ, parameterInfo, ss_res } = fitResults;
            const mainScaleFactor = stats.scaleFactor || 1.0;

            // Helper to format lines with fixed widths
            const formatLine = (cols, widths) => {
                return cols.map((col, i) => {
                     const colStr = (col === null || col === undefined) ? '-' : String(col);
                     return colStr.padEnd(widths[i]);
                 }).join(' ');
            };

            const modeName = refinementMode === 'pawley' ? 'Pawley' : 'Le Bail';
            const header = [
                `${modeName} Refinement Report`,
                '========================================================================',
                '',
                `Powder5, version 112, 25 Oct 2025`, 
                `Report Generated: ${now.toLocaleString()}`,
                `Data File: ${controls.fileName.textContent || 'N/A'}`,
                ''
            ];

            const algorithmNames = {
                lm: 'Levenberg-Marquardt',
                sa: 'Simulated Annealing',
                pt: 'Parallel Tempering'
            };
            const algorithmName = algorithmNames[algorithm] || 'Unknown';

            const profileNameMap = { "3": "TCH w/ Anisotropy", "4": "Simple pVoigt"};
            const profileType = String(finalParams.profileType || "4"); // Ensure string
            const profileName = profileNameMap[profileType] || "Unknown Profile";

            const selectedSg = spaceGroups.find(sg => sg.number === parseInt(controls.spaceGroupSelect.value, 10));
            const spaceGroupName = selectedSg ? `${selectedSg.number} – ${selectedSg.name}` : 'N/A';

            const statsSection = [
                '--- Refinement Statistics ---',
                `Rp (%):       ${stats.r_p !== undefined ? stats.r_p.toFixed(3) : 'N/A'}`,
                `Rwp (%):      ${stats.rwp !== undefined ? stats.rwp.toFixed(3) : 'N/A'}`,
                `χ² (GOF):     ${stats.chi2 !== undefined ? stats.chi2.toFixed(3) : 'N/A'}`,
                `Algorithm:    ${algorithmName}`,
                `Refinement:   ${modeName}`,
                `Profile:      ${profileName} (#${profileType})`,
                `Space Group:  ${spaceGroupName}`,
                ''
            ];

            // --- Williamson-Hall Analysis ---
            let whAnalysisSection = [];
            // This analysis is typically meaningful for TCH profile where size/strain are separated
            if (profileType === "3" && hklList && hklList.length > 0 && workerWorkingData && workerWorkingData.tth) {
                try {
                     // Note: calculateWilliamsonHall might need adjustment if moved to worker previously
                    const whResults = calculateWilliamsonHall(finalParams, hklList);
                    if (whResults) {
                        whAnalysisSection.push(
                            '--- Williamson-Hall Size/Strain Analysis (Approximate) ---',
                            `Apparent Crystallite Size (nm): ${whResults.size_nm !== undefined ? whResults.size_nm.toFixed(1) : 'N/A'}`,
                            `Apparent Microstrain (%):      ${whResults.strain_percent !== undefined ? whResults.strain_percent.toFixed(4) : 'N/A'}`,
                            `Linear Fit R²:                 ${whResults.r_squared !== undefined ? whResults.r_squared.toFixed(5) : 'N/A'}`,
                            '(Note: Assumes isotropic size/strain broadening via TCH U, X, Y)',
                            ''
                        );
                    }
                 } catch (whError) {
                     console.warn("Could not calculate Williamson-Hall:", whError);
                     whAnalysisSection.push('--- Williamson-Hall Size/Strain Analysis ---', '(Calculation failed)', '');
                 }
            }


            // --- ESD Calculation ---
            let esds = {};
            let esdWarning = null;

            if (algorithm === 'lm' && JtJ && parameterInfo && ss_res !== undefined && workerWorkingData && workerWorkingData.intensity && workerWorkingData.intensity.length > 0) {
                 const P = parameterInfo.length; // Number of parameters actually refined
                 const N = workerWorkingData.intensity.length; // Number of data points used

                 if (P === 0) {
                     esdWarning = "No parameters were refined.";
                 } else if (N > P) {
                     const degreesOfFreedom = N - P;
                     if (ss_res >= 0 && isFinite(ss_res)) {
                          const reduced_chi_sq = (degreesOfFreedom > 0) ? (ss_res / degreesOfFreedom) : 0; // Variance of residuals (approx)

                          let cov_matrix = null;
                          try {
                              // Validate JtJ before inversion
                               if (Array.isArray(JtJ) && JtJ.length === P && Array.isArray(JtJ[0]) && JtJ[0].length === P) {
                                  // H = JtJ (approximation); Cov = H^-1 * reduced_chi_sq
                                   const H_inv = numeric.inv(JtJ);
                                   if (H_inv) {
                                       // Scale by reduced_chi_sq to get Covariance matrix
                                        cov_matrix = numeric.mul(H_inv, reduced_chi_sq);
                                   } else {
                                        throw new Error("Matrix inversion returned null.");
                                   }
                               } else {
                                    throw new Error("JtJ matrix has incorrect dimensions or format.");
                               }
                          } catch (invError) {
                               console.error("Matrix inversion error:", invError);
                               cov_matrix = null;
                          }

                          if (cov_matrix) {
                              parameterInfo.forEach((p_info, i) => {
                                   if (cov_matrix[i] && cov_matrix[i][i] !== undefined) {
                                       const variance = cov_matrix[i][i]; // Variance is the diagonal element

                                        if (variance >= 0 && isFinite(variance)) { // Variance must be non-negative
                                            const sigma_scaled = Math.sqrt(variance); // Standard deviation (in scaled units)
                                            const scale = p_info.scale || 1.0; // Get the scale factor used during refinement

                                            // ESD is sigma converted back to original parameter units
                                            esds[p_info.name] = sigma_scaled * scale; // Un-normalize ESD

                                        } else {
                                             console.warn(`Invalid or negative variance term for parameter ${p_info.name}:`, variance);
                                             esds[p_info.name] = NaN; // Mark ESD as invalid
                                             esdWarning = esdWarning || 'Negative/invalid variance encountered.';
                                        }
                                   } else {
                                        console.warn(`Missing diagonal element [${i},${i}] in covariance matrix for parameter ${p_info.name}`);
                                        esds[p_info.name] = NaN;
                                        esdWarning = esdWarning || 'Covariance matrix calculation issue.';
                                   }
                              });
                          } else {
                               esdWarning = 'Covariance matrix calculation failed (likely high parameter correlation or singularity).';
                          }
                     } else {
                          esdWarning = "Invalid sum of squared residuals (ss_res) for variance calculation.";
                     }
                 } else { // N <= P
                     esdWarning = `N (${N}) <= P (${P}), cannot calculate reliable errors.`;
                 }
            } else if (algorithm !== 'lm') {
                esdWarning = "ESDs only available for Levenberg-Marquardt.";
            } else if (!JtJ || !parameterInfo || ss_res === undefined || !workerWorkingData || !workerWorkingData.intensity || workerWorkingData.intensity.length === 0) {
                 esdWarning = "Required data for ESD calculation is missing (JtJ, parameterInfo, ss_res, or workingData).";
            }


            // --- Parameter Table Generation ---
            const paramWidths = [24, 18, 10, 18]; // Name, Value, Fitted, ESD
            const paramHeader = formatLine(['Parameter', 'Value', 'Fitted', 'ESD'], paramWidths);
            const paramLines = [];
            const paramGroups = {};

            // Helper to add parameter definition
            const addParam = (group, name, value, flag, esd_key) => {
                 if (value !== undefined && value !== null) { // Only add if value exists
                     group.push({ name: name, value: value, flag: flag, esd_key: esd_key });
                 }
            };

            // Define Parameter Groups (Ensure esd_key matches names in parameterInfo)
            paramGroups['Structural & Instrumental'] = [];
            addParam(paramGroups['Structural & Instrumental'], 'a (Å)', finalParams.a, fitFlags.a, 'a');
            addParam(paramGroups['Structural & Instrumental'], 'b (Å)', finalParams.b, fitFlags.b, 'b');
            addParam(paramGroups['Structural & Instrumental'], 'c (Å)', finalParams.c, fitFlags.c, 'c');
            addParam(paramGroups['Structural & Instrumental'], 'alpha (°)', finalParams.alpha, fitFlags.alpha, 'alpha');
            addParam(paramGroups['Structural & Instrumental'], 'beta (°)', finalParams.beta, fitFlags.beta, 'beta');
            addParam(paramGroups['Structural & Instrumental'], 'gamma (°)', finalParams.gamma, fitFlags.gamma, 'gamma');
            addParam(paramGroups['Structural & Instrumental'], 'Radiation 1 (Å)', finalParams.lambda, undefined, undefined); // Not fitted
            addParam(paramGroups['Structural & Instrumental'], 'Radiation 2 (Å)', finalParams.lambda2, undefined, undefined); // Not fitted
            addParam(paramGroups['Structural & Instrumental'], 'Ratio (I2/I1)', finalParams.ratio, undefined, undefined);   // Not fitted
            addParam(paramGroups['Structural & Instrumental'], 'Zero Shift (°)', finalParams.zeroShift, fitFlags.zeroShift, 'zeroShift');
            addParam(paramGroups['Structural & Instrumental'], '2theta Min (°)', workerWorkingData ? workerWorkingData.tth[0] : null, undefined, undefined); // Fitted range
            addParam(paramGroups['Structural & Instrumental'], '2theta Max (°)', workerWorkingData ? workerWorkingData.tth[workerWorkingData.tth.length - 1] : null, undefined, undefined); // Fitted range


            paramGroups['Profile Parameters'] = [];
            if (profileType === "4") { // Simple pVoigt
                addParam(paramGroups['Profile Parameters'], 'GU', finalParams.GU, fitFlags.GU, 'GU');
                addParam(paramGroups['Profile Parameters'], 'GV', finalParams.GV, fitFlags.GV, 'GV');
                addParam(paramGroups['Profile Parameters'], 'GW', finalParams.GW, fitFlags.GW, 'GW');
                addParam(paramGroups['Profile Parameters'], 'GP', finalParams.GP, fitFlags.GP, 'GP');
                addParam(paramGroups['Profile Parameters'], 'LX', finalParams.LX, fitFlags.LX, 'LX');
                addParam(paramGroups['Profile Parameters'], 'eta (Mixing)', finalParams.eta, fitFlags.eta, 'eta');
                addParam(paramGroups['Profile Parameters'], 'shft (Displ.)', finalParams.shft, fitFlags.shft, 'shft');
                addParam(paramGroups['Profile Parameters'], 'trns (Transp.)', finalParams.trns, fitFlags.trns, 'trns');
            } else { // TCH (Profile 3)
                addParam(paramGroups['Profile Parameters'], 'U', finalParams.U, fitFlags.U, 'U');
                addParam(paramGroups['Profile Parameters'], 'V', finalParams.V, fitFlags.V, 'V');
                addParam(paramGroups['Profile Parameters'], 'W', finalParams.W, fitFlags.W, 'W');
                addParam(paramGroups['Profile Parameters'], 'X', finalParams.X, fitFlags.X, 'X');
                addParam(paramGroups['Profile Parameters'], 'Y', finalParams.Y, fitFlags.Y, 'Y');
                addParam(paramGroups['Profile Parameters'], 'S/L (Asymm)', finalParams.SL, fitFlags.SL, 'SL');
                addParam(paramGroups['Profile Parameters'], 'H/L (Asymm)', finalParams.HL, fitFlags.HL, 'HL');
                // Anisotropy only if profile 3
                 if (profileType === "3") {
                     addParam(paramGroups['Profile Parameters'], 'S400', finalParams.S400, fitFlags.S400, 'S400');
                     addParam(paramGroups['Profile Parameters'], 'S040', finalParams.S040, fitFlags.S040, 'S040');
                     addParam(paramGroups['Profile Parameters'], 'S004', finalParams.S004, fitFlags.S004, 'S004');
                     addParam(paramGroups['Profile Parameters'], 'S220', finalParams.S220, fitFlags.S220, 'S220');
                     addParam(paramGroups['Profile Parameters'], 'S202', finalParams.S202, fitFlags.S202, 'S202');
                     addParam(paramGroups['Profile Parameters'], 'S022', finalParams.S022, fitFlags.S022, 'S022');
                 }
            }

            paramGroups['Background Parameters'] = [];
             // Use global NUM_BACKGROUND_PARAMS constant
            for (let i = 0; i < NUM_BACKGROUND_PARAMS; i++) {
                 const name = `B${i}`;
                 addParam(paramGroups['Background Parameters'], name, finalParams[name], fitFlags[name], name);
            }
            addParam(paramGroups['Background Parameters'], 'Hump Height', finalParams.hump_H, fitFlags.hump_H, 'hump_H');
            addParam(paramGroups['Background Parameters'], 'Hump Position', finalParams.hump_P, fitFlags.hump_P, 'hump_P');
            addParam(paramGroups['Background Parameters'], 'Hump FWHM', finalParams.hump_W, fitFlags.hump_W, 'hump_W');


            // Format Parameter Lines
            for (const groupName in paramGroups) {
                if (paramGroups[groupName].length > 0) { // Only add group if it has parameters
                    paramLines.push(`--- ${groupName} ---`, paramHeader, '-'.repeat(paramHeader.length));
                    paramGroups[groupName].forEach(p => {
                         if (p.value !== null && !isNaN(p.value)) { // Extra check for NaN
                            const valStr = p.value.toExponential(6);
                            const fitStr = (p.flag === undefined) ? '' : (p.flag ? 'Yes' : 'No');
                            let esdStr = '';
                            if (p.flag && p.esd_key) {
                                const esdValue = esds[p.esd_key];
                                if (typeof esdValue === 'number' && isFinite(esdValue)) {
                                     esdStr = `(${esdValue.toExponential(2)})`;
                                } else if (isNaN(esdValue)) {
                                     esdStr = '(NaN)'; // Indicate if ESD calculation failed for this param
                                }
                            }
                            paramLines.push(formatLine([p.name, valStr, fitStr, esdStr], paramWidths));
                        }
                    });
                    paramLines.push('');
                }
            }
            if (esdWarning) paramLines.push(`NOTE regarding ESDs: ${esdWarning}`);

            // --- Reflections Section ---
            const reflectionsSection = [];
            if (hklList && hklList.length > 0 && workerWorkingData && workerWorkingData.tth) { // Need workingData for range check and Iobs
                const i_calc_header = refinementMode === 'pawley' ? 'I_refined' : 'I_extracted';
                const reflWidths = [15, 18, 18, 18, 18]; // hkl, 2th_corr, I_calc, ESD(I), I_obs
                const reflHeader = formatLine(['h,k,l', '2th_corr (°)', i_calc_header, 'ESD(I)', 'I_obs (Area)'], reflWidths);
                reflectionsSection.push('', '--- Reflections List (Integrated Intensities) ---', reflHeader, '-'.repeat(reflHeader.length));

                let i_obs_map = new Map();
                try {
                     // Calculate I_obs using partitioning (needs workingData)
                     i_obs_map = calculateAllObservedIntensities(hklList, finalParams, workerWorkingData);
                } catch(iobsError) {
                     console.error("Error calculating observed intensities:", iobsError);
                     reflectionsSection.push("(Error calculating I_obs)");
                }


                const fitted_tth_min = workerWorkingData.tth[0];
                const fitted_tth_max = workerWorkingData.tth[workerWorkingData.tth.length - 1];

                hklList.filter(hkl => hkl && hkl.tth && hkl.tth >= fitted_tth_min && hkl.tth <= fitted_tth_max) // Filter by fitted range
                    .forEach(hkl => {
                         let tthCorr = hkl.tth; // Start with theoretical position
                         if (finalParams.zeroShift) tthCorr += finalParams.zeroShift;
                         try { // Calculate shift safely
                             tthCorr += calculatePeakShift(hkl.tth, finalParams);
                         } catch { /* ignore shift error for report */ }

                        // Use final intensity directly (already scaled correctly if Le Bail)
                        const i_calc_area = hkl.intensity || 0; // Use the value from the final hklList

                        const i_obs = i_obs_map.get(hkl.hkl_list[0]) || 0;

                        let esd_I_str = '';
                        if (refinementMode === 'pawley') {
                             const hkl_name = `I_(${hkl.h_orig},${hkl.k_orig},${hkl.l_orig})`;
                             const esd_I_val = esds[hkl_name];
                             if (typeof esd_I_val === 'number' && isFinite(esd_I_val)) {
                                 esd_I_str = `(${esd_I_val.toFixed(1)})`;
                             } else if (isNaN(esd_I_val)) {
                                 esd_I_str = '(NaN)';
                             }
                        }

                        // Filter out reflections with negligible calculated AND observed intensity
                        if (i_obs > 0.01 || i_calc_area > 0.01) {
                            reflectionsSection.push(formatLine([
                                hkl.hkl_list[0],
                                tthCorr.toFixed(4),
                                i_calc_area.toFixed(1),
                                esd_I_str,
                                i_obs.toFixed(1)
                            ], reflWidths));
                        }
                    });
            }

            // --- Point Data Section ---
            const dataSection = [];
            if (format === 'full' && workerWorkingData && workerWorkingData.tth) {
                 dataSection.push('', '--- Point-by-Point Intensity Data (Fitted Range Only) ---',
                     formatLine(['2theta', 'I_obs', 'I_calc', 'Difference', 'Background'], [15, 18, 18, 18, 18]), // Added Background
                     '-'.repeat(15+18+18+18+18+4)); // Adjust length

                 try {
                     const finalBkg = calculateTotalBackground(workerWorkingData.tth, finalParams);
                     const finalNetPattern = calculatePattern(workerWorkingData.tth, hklList, finalParams);
                     const finalCalcPattern = numeric.add(numeric.mul(finalNetPattern, mainScaleFactor), finalBkg);

                     for (let i = 0; i < workerWorkingData.tth.length; i++) {
                         const i_obs = workerWorkingData.intensity[i];
                         const i_calc = finalCalcPattern[i];
                         const i_bkg = finalBkg[i];
                          if (isFinite(i_obs) && isFinite(i_calc) && isFinite(i_bkg)) {
                             dataSection.push(formatLine([
                                 workerWorkingData.tth[i].toFixed(4),
                                 i_obs.toFixed(2),
                                 i_calc.toFixed(2),
                                 (i_obs - i_calc).toFixed(2),
                                 i_bkg.toFixed(2)
                             ], [15, 18, 18, 18, 18]));
                          }
                     }
                 } catch (dataError) {
                      console.error("Error generating point data for report:", dataError);
                      dataSection.push("(Error generating point data)");
                 }
            }

            // Combine all sections
            return [...header, ...statsSection, ...whAnalysisSection, ...paramLines, ...reflectionsSection, ...dataSection].join('\n');
        }


        // --- EVENT LISTENERS, 8 oct, version 1.0.3; update le 24 oct v 111

        document.getElementById('le-bail-button').addEventListener('click', () => runFit('le-bail'));
        document.getElementById('pawley-button').addEventListener('click', () => runFit('pawley'));


        // Helper function to handle a full HKL list recalculation, including cache invalidation.
        const handleFullHklRecalculation = () => {
            if (!mainChart || isFitting) return;
            invalidateHklCache();
            generateMasterHklList();
            rescalePlot(false);
            mainChart.update('none');
        };

        // Create a debounced version of the handler for frequent input events.
        const debouncedHklRecalculation = debounce(handleFullHklRecalculation, 400); // 400ms delay

        const debouncedBackgroundUpdate = debounce(updateBackgroundForPreview, 350);


        // Helper function for simple preview updates that DON'T require HKL recalculation.
        const handleSimplePreviewUpdate = () => {
            if (!mainChart || isFitting) return;
            updatePreviewPattern();
            rescalePlot(false);
            mainChart.update('none');
        };
        //1.0.4
        const debouncedSimplePreviewUpdate = debounce(handleSimplePreviewUpdate, 350); 

        // --- Attach Listeners to Specific Controls ---
        // 1. Triggers for FULL Recalculation (these invalidate the cache)
        // These are for single-click events, so they use the direct handler.
        document.getElementById('bravais-lattice').addEventListener('change', handleFullHklRecalculation);
        document.getElementById('space-group-select').addEventListener('change', handleFullHklRecalculation);
        document.getElementById('wavelength').addEventListener('input', handleFullHklRecalculation);
        
        // Use event delegation for dynamically created lattice parameter inputs.
        // it now calls the debounced handler.
        document.getElementById('lattice-parameters-container').addEventListener('input', (event) => {
            if (event.target && event.target.type === 'number' && event.target.id.startsWith('lattice-param-')) {
                debouncedHklRecalculation();
            }
        });
        
        // 2. Triggers for SIMPLE Preview Update (these use the cached HKLs)
const controlsPanel = document.getElementById('controls-panel');
controlsPanel.querySelectorAll('#simple-pvoigt-params-container input, #anisotropy-params-container input').forEach(el => {
    // *** CHANGE IS HERE ***
    // We now call the debounced function for all continuous input events
    // from sliders and number fields within the profile tabs.
    el.addEventListener('input', debouncedSimplePreviewUpdate);
});

// The profile function dropdown should update immediately on change, not after a delay.
// This is a single 'change' event, not a continuous 'input' event, so no debounce is needed.
document.getElementById('profile-function-select').addEventListener('change', handleSimplePreviewUpdate);
 

        
        document.getElementById('zero-shift').addEventListener('input', handleSimplePreviewUpdate);
        document.getElementById('fit-zero-shift').addEventListener('change', handleSimplePreviewUpdate);

        // 3. Background parameters have their own dedicated updater function
        document.getElementById('tab-panel-background').addEventListener('input', (e) => {
            if (e.target.id === 'show-anchors-checkbox') return;
            debouncedBackgroundUpdate();
        });

        // 4. Main File Input: Clears the ENTIRE cache and sets up the application
        controls.fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (evt) => {
                try {
                    const parsedData = detectAndParseFile(file.name, evt.target.result);
                    if (!parsedData || parsedData.tth.length === 0) throw new Error("No valid data points parsed.");

                    // *** CLEAR THE ENTIRE CACHE ON NEW FILE LOAD ***
                    hklIndexCache = {}; 
                    
                    if (parsedData.wavelength) controls.wavelength.value = parsedData.wavelength.toFixed(5);
                    
                    // Convert parsed data to Float64Arrays for performance
                    fullExperimentalData = {
                        tth: new Float64Array(parsedData.tth),
                        intensity: new Float64Array(parsedData.intensity)
                    };
                    lastRawDifference = []; // This can remain a standard array
                    calculatedBackground = new Float64Array(fullExperimentalData.tth.length);
                    
                    workingDataCache.isValid = false;
                    
                    controls.fileName.textContent = file.name;
                    controls.placeholder.style.display = 'none';
                    controls.resultsContainer.style.display = 'flex';
                    
                    document.getElementById('le-bail-button').disabled = false;
                    updatePawleyButtonState();
                    
                    initializeChart();
                    
                    const min = fullExperimentalData.tth[0];
                    const max = fullExperimentalData.tth[fullExperimentalData.tth.length - 1];
                    const step = (max - min) / 2000;

                    [controls.tthMinSlider, controls.tthMaxSlider].forEach(slider => {
                        slider.min = min;
                        slider.max = max;
                        slider.step = step;
                        slider.disabled = false;
                    });
                    
                    controls.tthMinSlider.value = min;
                    controls.tthMaxSlider.value = max;
                    controls.tthMinValue.textContent = min.toFixed(2);
                    controls.tthMaxValue.textContent = max.toFixed(2);
                    
                    const estimatedBgParams = estimateBackgroundParameters(fullExperimentalData.tth, fullExperimentalData.intensity);
                    if (estimatedBgParams) {
                        for (let i = 0; i < 5; i++) {
                            const input = document.getElementById(`param-b${i}`);
                            if (input && estimatedBgParams[`B${i}`] !== undefined) {
                                input.value = estimatedBgParams[`B${i}`].toFixed(2);
                            }
                        }
                    }

                    updateWorkingData();
                    updatePlotRange(true);
                    generateMasterHklList();      
                    updateBackgroundForPreview();
                    rescalePlot(false); 
                    mainChart.update('none');

                } catch (error) {
                    alert(`Error reading file: ${error.message}`);
                    console.error(error);
                    document.getElementById('le-bail-button').disabled = true;
                    updatePawleyButtonState();
                }
            };
            reader.onerror = () => alert('Error reading file.');
            reader.readAsText(file);
        });

        // 5. General UI Listeners (not related to HKL caching)
        document.querySelector('.tab-buttons').addEventListener('click', (e) => { 
            const clickedTab = e.target.closest('.tab-btn'); 
            if (clickedTab && !clickedTab.disabled) { 
                e.currentTarget.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active')); 
                clickedTab.classList.add('active'); 
                document.querySelectorAll('.tab-content-panel').forEach(panel => panel.classList.remove('active')); 
                document.getElementById(`tab-panel-${clickedTab.dataset.tab}`).classList.add('active'); 
            } 
        });
        
        const resizer = document.getElementById('drag-handle'); 
        const leftPanel = document.getElementById('controls-panel');
        resizer.addEventListener('mousedown', (e) => { 
            e.preventDefault(); 
            document.body.style.cursor = 'col-resize'; 
            const moveHandler = (moveEvent) => { 
                if (moveEvent.clientX > 350 && moveEvent.clientX < window.innerWidth - 350) 
                    leftPanel.style.width = `${moveEvent.clientX}px`; 
            }; 
            const upHandler = () => { 
                document.body.style.cursor = 'default'; 
                window.removeEventListener('mousemove', moveHandler); 
                window.removeEventListener('mouseup', upHandler); 
            }; 
            window.addEventListener('mousemove', moveHandler); 
            window.addEventListener('mouseup', upHandler); 
        });
        
        document.getElementById('anchor-points-list').addEventListener('input', handleAnchorListInteraction);
        document.getElementById('anchor-points-list').addEventListener('click', handleAnchorListInteraction);

        document.getElementById('show-anchors-checkbox').addEventListener('change', (e) => {
            if (mainChart) {
                const isVisible = e.target.checked;
                const anchorDataset = mainChart.data.datasets.find(d => d.label === 'Anchor Points');
                if (anchorDataset) {
                    anchorDataset.hidden = !isVisible;
                    mainChart.update('none');
                }
            }
        });

        controls.mainChartCanvas.addEventListener('click', e => {
            if (e.ctrlKey && mainChart) {
                e.preventDefault();
                e.stopPropagation();
                const currentYMin = mainChart.scales.y.min;
                const currentYMax = mainChart.scales.y.max;
                const rect = controls.mainChartCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const tthValue = mainChart.scales.x.getValueForPixel(x);
                const closestPoint = findClosestExperimentalPoint(tthValue);
                if (closestPoint) {
                    const isAlreadyAdded = backgroundAnchors.some(a => a.index === closestPoint.index);
                    if (!isAlreadyAdded) {
                        backgroundAnchors.push(closestPoint);
                        backgroundAnchors.sort((a, b) => a.tth - b.tth); 
                        renderAnchorList();
                        updateBackgroundForPreview();
                    }
                }
                mainChart.options.scales.y.min = currentYMin;
                mainChart.options.scales.y.max = currentYMax;
                mainChart.update('none');
            }
        });


        controls.iterationsSlider.addEventListener('input', () => controls.iterationsValue.textContent = controls.iterationsSlider.value);
        

        
controls.tthMinSlider.addEventListener('input', () => { 
    let minVal = parseFloat(controls.tthMinSlider.value); 
    let maxVal = parseFloat(controls.tthMaxSlider.value); 
    if (minVal >= maxVal) { 
        minVal = maxVal - parseFloat(controls.tthMinSlider.step); 
        controls.tthMinSlider.value = minVal; 
    } 
    controls.tthMinValue.textContent = minVal.toFixed(2); 

    redrawFitForNewRange();
});

controls.tthMaxSlider.addEventListener('input', () => { 
    let minVal = parseFloat(controls.tthMinSlider.value); 
    let maxVal = parseFloat(controls.tthMaxSlider.value); 
    if (maxVal <= minVal) { 
        maxVal = minVal + parseFloat(controls.tthMaxSlider.step); 
        controls.tthMaxSlider.value = maxVal; 
    } 
    controls.tthMaxValue.textContent = maxVal.toFixed(2); 

    redrawFitForNewRange();
});
        
controls.mainChartCanvas.addEventListener('wheel', e => {
    e.preventDefault();
    const chart = mainChart;
    if (!chart || !chart.chartArea) return;

    const { left, right, top, bottom } = chart.chartArea;
    const xPixel = e.offsetX;
    const yPixel = e.offsetY;
    
    // Zoom in = smaller range (factor < 1), zoom out = larger range (factor > 1)
    const zoomFactor = e.deltaY < 0 ? 0.9 : 1.1;

    // Helper function to perform anchored zoom on a specific axis
    const zoomOnAxis = (axisID, factor, focalPixel) => {
        const axis = chart.scales[axisID];
        if (!axis) return;

        // Get the data value directly under the mouse cursor
        const focalValue = axis.getValueForPixel(focalPixel);
        
        const currentRange = axis.max - axis.min;
        const newRange = currentRange * factor;
        
        // Determine where the mouse is proportionally on the current axis (from 0.0 to 1.0)
        const focalRatio = (focalValue - axis.min) / currentRange;
        
        // Calculate the new min and max to keep the focal point stationary
        const newMin = focalValue - (newRange * focalRatio);
        const newMax = newMin + newRange;
        
        // Apply the new limits directly to the chart options
        chart.options.scales[axisID].min = newMin;
        chart.options.scales[axisID].max = newMax;
    };

    // Determine which axis/axes to zoom based on cursor position
    if (yPixel > bottom) { // Zooming on X-axis
        zoomOnAxis('x', zoomFactor, xPixel);
    } else if (xPixel < left) { // Zooming on Y-axis
        zoomOnAxis('y', zoomFactor, yPixel);
    } else if (xPixel >= left && xPixel <= right && yPixel >= top && yPixel <= bottom) { // Zooming on both
        zoomOnAxis('x', zoomFactor, xPixel);
        zoomOnAxis('y', zoomFactor, yPixel);
    }
   
    chart.update('none');
    rescalePlot(false); 
});


//changé le 04 oct, version 2.3
controls.mainChartCanvas.addEventListener('contextmenu', e => {
    e.preventDefault();
    if (!mainChart) return;

    // 1. Manually reset the X-axis to the CURRENT SLIDER range
    mainChart.options.scales.x.min = parseFloat(controls.tthMinSlider.value); // Use .value
    mainChart.options.scales.x.max = parseFloat(controls.tthMaxSlider.value); // Use .value
    
    // 2. Manually reset the Y-axis using the original max value we stored
    const globalYMax = mainChart.options.globalYMax;
    mainChart.options.scales.y.max = globalYMax;
    mainChart.options.scales.y.min = -(globalYMax * 0.3); // Restore the default 30% space for the diff plot

    // 3. Update the chart to apply these new axis limits and redraw the difference plot
    mainChart.update('none');
    rescalePlot(false);
});


        controls.profileSelect.addEventListener('change', (e) => { const newProfile = e.target.value; saveProfileState(currentProfile); controls.simplePVoigtParamsContainer.classList.toggle('hidden', newProfile !== '4'); controls.anisotropyParamsContainer.classList.toggle('hidden', newProfile !== '3'); restoreProfileState(newProfile); currentProfile = newProfile; if (fullExperimentalData.tth.length > 0) updatePreviewPattern(); });
        
        // This now uses the new helper function
        controls.bravaisLattice.addEventListener('change', updateUIForSystemChange);
        
        controls.paramS400.addEventListener('input', updateStephensAnisotropyUI); controls.fitS400.addEventListener('change', updateStephensAnisotropyUI); controls.paramS220.addEventListener('input', updateStephensAnisotropyUI); controls.fitS220.addEventListener('change', updateStephensAnisotropyUI); controls.paramS202.addEventListener('input', updateStephensAnisotropyUI); controls.fitS202.addEventListener('change', updateStephensAnisotropyUI);


    controls.saveDataButton.addEventListener('click', () => {
    if (!fitResults) {
        showToast("Please run a refinement before saving data.", 'error');
        return;
    }
    const originalText = controls.saveDataButton.textContent;
    controls.saveDataButton.textContent = 'Saving...';
    controls.saveDataButton.disabled = true;
    try {
        const textContent = generateReportContent('full');
        const timestamp = new Date().toISOString().slice(0, 16).replace(/[-:]/g, '').replace('T', '_');
        
        // FIX: Determine the filename based on the refinement mode from the results
        const modeName = fitResults.refinementMode === 'pawley' ? 'Pawley' : 'LeBail';
        downloadTextFile(textContent, `${modeName}-Data-${timestamp}.txt`);

        showToast("Report saved successfully!", 'success');
    } catch (error) {
        console.error("Failed to save data:", error);
    } finally {
        controls.saveDataButton.textContent = 'Save Report';
        controls.saveDataButton.disabled = false;
    }
});


controls.reportButton.addEventListener('click', async () => {
    if (!fitResults) {
        alert("Cannot generate report: Fit results are missing.");
        return;
    }

    const originalText = controls.reportButton.textContent;
    controls.reportButton.textContent = 'Generating...';
    controls.reportButton.disabled = true;

    try {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
        const margin = 15;
        const contentWidth = doc.internal.pageSize.getWidth() - 2 * margin;
        let yPosition = 20;

        const summaryText = generateReportContent('summary');
        const pdfText = summaryText
            .replace(/χ²/g, 'Chi^2')
            .replace(/°/g, 'deg')
            .replace(/β/g, 'Beta');

        const lines = pdfText.split('\n');
        doc.setFont('Courier');

        for (const line of lines) {
            if (yPosition > doc.internal.pageSize.getHeight() - 20) {
                doc.addPage();
                yPosition = 20;
            }
            const isHeader = line.startsWith('---');
            const isTitle = line.includes('Refinement Report');
            let fontSize = 9;
            let fontStyle = 'normal';

            if (isTitle) {
                fontSize = 14;
                fontStyle = 'bold';
                yPosition += 6;
            } else if (isHeader) {
                fontSize = 10;
                fontStyle = 'bold';
                yPosition += 4;
            }
            
            doc.setFontSize(fontSize);
            doc.setFont(undefined, fontStyle);
            doc.text(line, margin, yPosition);
            yPosition += fontSize * 0.4;
        }

        doc.addPage();
        const chartCanvas = await html2canvas(controls.mainChartCanvas, { backgroundColor: '#ffffff', scale: 2 });
        const mainImgData = chartCanvas.toDataURL('image/png', 0.95);
        const mainImgProps = doc.getImageProperties(mainImgData);
        const mainImgHeight = Math.min((mainImgProps.height * contentWidth) / mainImgProps.width, 250); 
        doc.addImage(mainImgData, 'PNG', margin, 20, contentWidth, mainImgHeight);
        
        // FIX: Determine the filename based on the refinement mode from the results
        const { refinementMode } = fitResults;
        const modeName = refinementMode === 'pawley' ? 'Pawley' : 'LeBail';
        doc.save(`${modeName}-Report-${new Date().toISOString().slice(0, 10)}.pdf`);

    } catch (error) {
        alert(`An error occurred while generating the report: ${error.message}`);
    } finally {
        controls.reportButton.textContent = 'Generate PDF';
        if (fitResults) {
            controls.reportButton.disabled = false;
        }
    }
});

        controls.algorithmSelect.addEventListener('change', updatePawleyButtonState);

        updatePawleyButtonState();

        updateUIForSystemChange();
    });

</script>


</body>
</html>