<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Powder 5</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

        <script src="rules_spaceGroups.js"></script>


    <style>
        :root {
            --system-blue: #007AFF;
            --system-gray-1: #8E8E93;
            --system-gray-2: #AEAEB2;
            --system-gray-3: #C7C7CC;
            --system-gray-4: #D1D1D6;
            --system-gray-5: #E5E5EA;
            --system-gray-6: #F2F2F7;
            --system-background: #FFFFFF;
            --system-grouped-background: #F2F2F7;
            --system-material-thin: rgba(255, 255, 255, 0.7);
            --system-material-regular: rgba(255, 255, 255, 0.8);
            --system-label: #000000;
            --system-secondary-label: rgba(60, 60, 67, 0.6);
            --system-tertiary-label: rgba(60, 60, 67, 0.3);
            --system-separator: rgba(60, 60, 67, 0.29);
            --system-fill: rgba(120, 120, 128, 0.2);
            --system-secondary-fill: rgba(120, 120, 128, 0.16);
            --system-shadow: rgba(0, 0, 0, 0.1);
        }

        #fit-button { width: 100%; }

        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif; 
            margin: 0; 
            background-color: var(--system-grouped-background); 
            display: flex; 
            flex-direction: column; 
            height: 100vh; 
            overflow: hidden; 
            color: var(--system-label);
        }
        #app-container { 
            display: flex; 
            width: 100%; 
            flex-grow: 1; 
            min-height: 0; 
            background-color: var(--system-grouped-background);
        }
        
        #controls-panel { 
            width: 380px; 
            min-width: 320px; 
            max-width: 500px; 
            flex-shrink: 0; 
            padding: 16px; 
            background-color: var(--system-background); 
            border-right: 1px solid var(--system-separator); 
            display: flex; 
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            z-index: 20;
            box-shadow: 0 0 20px rgba(0,0,0,0.05);
            border-radius: 0 12px 12px 0;
        }
        
        #drag-handle { 
            width: 6px; 
            cursor: col-resize; 
            background-color: var(--system-gray-5); 
            flex-shrink: 0; 
            transition: background-color 0.2s; 
        }
        #drag-handle:hover, #drag-handle:active { 
            background-color: var(--system-blue); 
        }
        
        #results-area { 
            flex-grow: 1; 
            position: relative; 
            background-color: var(--system-background); 
            min-width: 0; 
            display: flex; 
            flex-direction: column; 
            padding: 20px; 
            z-index: 10;
            border-radius: 12px 0 0 12px;
            margin: 8px 8px 8px 0;
            box-shadow: 0 4px 20px rgba(0,0,0,0.05);
        }
        
        .control-group { 
            padding: 16px; 
            margin-bottom: 16px;
            background-color: var(--system-background);
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .control-group:first-child { 
            padding-top: 0; 
            margin-top: 0;
        }
        .control-label { 
            display: block; 
            font-weight: 500; 
            color: var(--system-secondary-label); 
            font-size: 13px; 
            margin-bottom: 6px;
        }
        
        .control-input, .control-select { 
            width: 100%; 
            background-color: var(--system-gray-6); 
            border: 1px solid var(--system-gray-4); 
            color: var(--system-label); 
            border-radius: 8px; 
            padding: 10px 14px; 
            transition: all 0.2s ease; 
            box-sizing: border-box;
            font-size: 15px;
            height: 40px;
        }
        .control-input:focus, .control-select:focus { 
            outline: none; 
            border-color: var(--system-blue); 
            box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.2); 
        }
        .control-input:disabled { 
            background-color: var(--system-gray-6);
            color: var(--system-tertiary-label);
            cursor: not-allowed; 
        }
        
        .btn { 
            padding: 12px 20px; 
            border-radius: 10px; 
            font-weight: 600; 
            transition: all 0.2s; 
            cursor: pointer; 
            border: none; 
            text-align: center; 
            font-size: 15px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-primary { 
            background-color: var(--system-blue); 
            color: white; 
            box-shadow: 0 1px 3px rgba(0, 122, 255, 0.3);
        }
        .btn-primary:hover:not(:disabled) { 
            background-color: #006ee6; 
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 122, 255, 0.3);
        }
        .btn-primary:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 122, 255, 0.3);
        }

        .btn-secondary { 
    background-color: var(--system-gray-5); /* Darker background */
    color: var(--system-label); 
    border: 1px solid var(--system-gray-4); /* Add solid border */
    box-shadow: none; /* Remove shadow for a cleaner look */
}

.btn-secondary:hover:not(:disabled) { 
    background-color: var(--system-blue);    /* Change background to blue */
    color: white;                           /* Change text to white for contrast */
    border-color: var(--system-blue);       /* Make the border blue as well */
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0, 122, 255, 0.3); /* Optional: Add a blue glow like the primary buttons */
}

        .btn:disabled { 
            background-color: var(--system-gray-6); 
            color: var(--system-tertiary-label);
            cursor: not-allowed; 
            opacity: 0.7; 
            box-shadow: none;
        }
        
       .file-input-label { 
    display: block; 
    padding: 12px 16px; 
    background-color: var(--system-gray-5); /* Match the secondary buttons */
    color: var(--system-label); 
    border-radius: 10px; 
    text-align: center; 
    cursor: pointer; 
    transition: all 0.2s;
    font-weight: 500;
    border: 1px solid var(--system-gray-4); /* Change from dashed to solid */
}

.file-input-label:hover { 
    background-color: var(--system-blue);    /* Change background to blue */
    color: white;                           /* Change text to white */
    border-color: var(--system-blue);       /* Make the border blue */
}

        
        .results-grid { 
            display: grid; 
            grid-template-columns: repeat(3, minmax(80px, 1fr)); 
            gap: 12px; 
        }
        .result-card { 
            background-color: var(--system-gray-6); 
            padding: 12px; 
            border-radius: 10px; 
            text-align: center; 
            transition: all 0.2s; 
        }
        .result-card-label { 
            font-size: 12px; 
            color: var(--system-secondary-label); 
            margin-bottom: 4px;
        }
        .result-card-value { 
            font-size: 18px; 
            font-weight: 700; 
            color: var(--system-label); 
        }
        
        .fit-checkbox { 
            -webkit-appearance: none; 
            appearance: none; 
            background-color: var(--system-gray-6); 
            width: 22px; 
            height: 22px; 
            border: 1px solid var(--system-gray-4); 
            border-radius: 6px; 
            cursor: pointer; 
            display: inline-block; 
            position: relative; 
            transition: all 0.2s;
        }
        .fit-checkbox:checked { 
            background-color: var(--system-blue); 
            border-color: var(--system-blue); 
        }
        .fit-checkbox:checked::after { 
            content: '✓'; 
            color: white; 
            position: absolute; 
            left: 50%; 
            top: 50%; 
            transform: translate(-50%, -50%); 
            font-size: 14px; 
            font-weight: bold;
        }
        
        .tab-buttons { 
            display: flex; 
            background-color: var(--system-gray-6);
            border-radius: 10px;
            padding: 4px;
            margin-bottom: 16px;
        }
        .tab-btn { 
            flex: 1; 
            padding: 8px 12px; 
            background: none; 
            border: none; 
            color: var(--system-secondary-label); 
            font-weight: 500; 
            cursor: pointer; 
            border-radius: 8px;
            transition: all 0.2s; 
            font-size: 14px; 
        }
        .tab-btn:hover { 
            color: var(--system-label); 
            background-color: rgba(255,255,255,0.5);
        }
        .tab-btn.active { 
            color: var(--system-blue); 
            background-color: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .tab-content-panels { 
            position: relative; 
            padding-top: 0; 
        }
        .tab-content-panel { 
            display: none; 
            flex-direction: column; 
        }
        .tab-content-panel.active { 
            display: flex; 
        }

        .tab-content-panel > .control-group {
            border-top: none;
        }

        #lattice-parameters-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .bottom-actions { 
            margin-top: auto; 
            padding-top: 16px;
        }

        .slider-value-track { 
            display: grid; 
            grid-template-columns: 1fr; 
            grid-template-rows: 1fr; 
            align-items: center; 
        }
        .slider-value-track > * { 
            grid-column: 1; 
            grid-row: 1; 
        }
        .slider-value-display { 
            text-align: center; 
            color: var(--system-secondary-label); 
            font-weight: 500; 
            font-size: 13px; 
            pointer-events: none; 
        }
        input[type="range"].custom-slider { 
            -webkit-appearance: none; 
            appearance: none; 
            width: 100%; 
            height: 36px; 
            background: var(--system-gray-6); 
            border-radius: 6px; 
            outline: none; 
            padding: 0; 
            margin: 0; 
        }
        input[type="range"].custom-slider::-webkit-slider-thumb { 
            -webkit-appearance: none; 
            appearance: none; 
            width: 22px; 
            height: 22px; 
            background: var(--system-blue); 
            border-radius: 50%; 
            cursor: pointer; 
            border: 3px solid white; 
            box-sizing: border-box; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        input[type="range"].custom-slider::-moz-range-thumb { 
            width: 22px; 
            height: 22px; 
            background: var(--system-blue); 
            border-radius: 50%; 
            cursor: pointer; 
            border: 3px solid white; 
            box-sizing: border-box; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        input[type="range"].custom-slider:disabled { 
            background: var(--system-gray-6); 
        }
        input[type="range"].custom-slider:disabled::-webkit-slider-thumb { 
            background: var(--system-gray-3); 
        }
        input[type="range"].custom-slider:disabled::-moz-range-thumb { 
            background: var(--system-gray-3); 
        }

        /* --- UNIFIED UI & SPACING STYLES --- */
        #tab-panel-sample > .control-group, #tab-panel-background > .control-group {
            display: flex; 
            flex-direction: column; 
            gap: 16px; 
        } 
        
        /* Add these styles anywhere inside the <style> tag */
        .anchor-point-item {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
            padding: 8px;
            background-color: var(--system-gray-6);
            border-radius: 8px;
        }

        .anchor-point-item span {
    font-size: 15px;
    padding: 0 4px;
    text-align: right;
}

        .anchor-point-item .control-input {
            height: 36px;
            padding: 8px 12px;
        }

        .anchor-remove-btn {
            background-color: transparent;
            border: none;
            color: var(--system-gray-1);
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            padding: 0 8px;
            line-height: 1;
            transition: color 0.2s;
        }
        .anchor-remove-btn:hover {
            color: #ff453a; /* systemRed */
        }

        .control-group h2, .profile-section-header {
            margin: 0 0 16px 0; 
            padding-bottom: 12px; 
            border-bottom: 1px solid var(--system-separator);
            color: var(--system-label); 
            font-size: 17px; 
            font-weight: 600;
        }

.profile-controls-container + .profile-controls-container {
    margin-top: 24px;
}

        .parameter-grid-3col, .parameter-grid-2col, .slider-group, .form-row {
            display: grid; 
            gap: 12px; 
            align-items: center;
        }
        .parameter-grid-3col { 
            grid-template-columns: minmax(100px, auto) 1fr auto; 
        }
        .parameter-grid-2col, .slider-group, .form-row { 
            grid-template-columns: minmax(100px, auto) 1fr; 
        }
        
        .parameter-grid-3col > .control-label, .parameter-grid-2col > .control-label,
        .slider-group > .control-label, .form-row > .control-label {
            grid-column: 1; 
            margin-bottom: 0;
        }
        
        .parameter-grid-2col > *:not(label), .slider-group > .slider-value-track,
        .form-row > *:not(label) { 
            grid-column: 2; 
        }
        .parameter-grid-3col > .control-input { 
            grid-column: 2; 
        }
        .parameter-grid-3col > .fit-checkbox { 
            grid-column: 3; 
            justify-self: center; 
        }

        .profile-controls-container {
            display: grid; 
            grid-template-columns: minmax(100px, auto) 1fr auto;
            gap: 16px 12px; 
            align-items: center;
        }
        .profile-controls-container > .control-label { 
            grid-column: 1; 
            text-align: left; 
            margin-bottom: 0; 
        }
        .profile-controls-container > input[type="number"] { 
            grid-column: 2; 
        }
        .profile-controls-container > input[type="checkbox"] { 
            grid-column: 3; 
            justify-self: center; 
        }
        .profile-controls-container > .profile-section-header { 
            grid-column: 1 / -1; 
        }
        

        /* CSS for Toast Notifications */
        #toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
            display: flex;
            flex-direction: column-reverse;
            gap: 10px;
            pointer-events: none; /* Allow clicking through the container */
        }
        .toast {
            padding: 12px 20px;
            border-radius: 8px;
            color: white;
            font-size: 15px;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            opacity: 0;
            transform: translateX(100%); /* Start off-screen to the right */
            transition: all 0.4s cubic-bezier(0.21, 1.02, 0.73, 1); /* Smooth slide and fade */
        }
        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }
        .toast.error {
            background-color: #ff453a; /* systemRed */
        }
        .toast.success {
            background-color: #34c759; /* systemGreen */
        }


        
        .bottom-actions > .control-group {
            display: grid; 
            grid-template-columns: minmax(100px, auto) 1fr;
            gap: 16px; 
            align-items: center; 
            border: none; 
            padding: 0;
        }
        .bottom-actions > .control-group > h2,
        .bottom-actions > .control-group > .slider-group,
        .bottom-actions > .control-group > #progress-bar-container,
        .bottom-actions > .control-group > .results-grid {
            grid-column: 1 / -1;
        }
        .bottom-actions > .control-group > label[for="algorithm-select"] {
            grid-column: 1; 
            margin-bottom: 0;
        }
        .bottom-actions > .control-group > #algorithm-select {
            grid-column: 2; 
            margin-bottom: 0;
        }
        
        /* --- TOOLTIP AND SCROLLBAR FIX --- */
        .help-tooltip-container { 
            position: relative; 
            display: inline-block; 
        }
.help-icon { 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    width: 24px; 
    height: 24px; 
    background-color: #4a5568; /* Darker background for icon */
    color: white; /* White question mark */
    border-radius: 50%; 
    font-weight: 500; 
    font-size: 14px; 
    cursor: help; 
    transition: all 0.2s; 
}
.help-icon:hover { 
    background-color: #2d3748; /* Even darker on hover */
    color: white;
}
        
.tooltip-content {
    visibility: hidden; 
    opacity: 0; 
    width: 280px;
    background-color: #2d3748; /* Darker background for better contrast */
    color: #f7fafc; /* Light text color */
    text-align: left;
    border-radius: 10px; 
    padding: 16px;
    position: absolute; 
    z-index: 1001;
    top: -15px;
    right: 115%;
    margin-right: 10px;
    transition: opacity 0.3s; 
    font-size: 15px; 
    border: 1px solid #4a5568; /* Darker border */
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); /* Stronger shadow */
}
.tooltip-content::after {
    content: ""; 
    position: absolute;
    top: 20px;
    left: 100%;
    margin-top: -5px; 
    border-width: 5px; 
    border-style: solid;
    border-color: transparent transparent transparent #2d3748; /* Match tooltip background */
}

.tooltip-content.visible {
    visibility: visible;
    opacity: 1;
}

.tooltip-content h4 { 
    color: #fff; /* White for headings */
    font-size: 15px; 
    margin-top: 0; 
    margin-bottom: 8px; 
    font-weight: 600; 
}
.tooltip-content p { 
    margin-top: 0; 
    margin-bottom: 6px; 
    line-height: 1.4; 
    color: #e2e8f0; /* Lighter gray for paragraph text */
}
.tooltip-content hr { 
    border: none; 
    border-top: 1px solid #4a5568; /* Darker separator */
    margin: 12px 0; 
}
        .hidden { 
            display: none !important; 
        }

        #controls-panel::-webkit-scrollbar { 
            width: 5px; 
        }
        #controls-panel::-webkit-scrollbar-track { 
            background: transparent; 
        }
        #controls-panel::-webkit-scrollbar-thumb { 
            background: var(--system-gray-4); 
            border-radius: 3px; 
        }
        #controls-panel::-webkit-scrollbar-thumb:hover { 
            background: var(--system-gray-3); 
        }

        /* Apple-style progress bar */
        #progress-bar-container {
            height: 5px;
            background-color: var(--system-gray-5);
            border-radius: 3px;
            overflow: hidden;
        }
        #progress-bar {
            height: 100%;
            background-color: var(--system-blue);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        /* Apple-style placeholder */
        #placeholder {
            background-color: var(--system-background);
            border-radius: 12px;
            padding: 40px;
        }
        #placeholder svg {
            color: var(--system-gray-3);
        }

        /* Subtle animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .control-group {
            animation: fadeIn 0.3s ease;
        }

        /* Improved focus states for accessibility */
        .btn:focus-visible,
        .control-input:focus-visible,
        .control-select:focus-visible,
        .fit-checkbox:focus-visible {
            outline: 2px solid var(--system-blue);
            outline-offset: 2px;
        }

    </style>
</head>

<body>

    <div id="app-container">
        <div id="controls-panel">
            
            <div class="control-group" style="padding-top: 16px;">
                 <div style="display: flex; align-items: center; gap: 10px;">
                    
                    <label for="file-input" class="file-input-label" style="flex-grow: 1;">
                        <span id="file-name">Select Data File</span>
                    </label>
                     
                    <div class="help-tooltip-container">
    <span class="help-icon">?</span>

    <div class="tooltip-content">
    <h4>Powder 5 Fit</h4>
    <p>Analyze powder XRD using the LeBail or Pawley method. <a href="powder5_help.html" target="_blank" style="color: #6495ED;">Method Guide &rarr;</a></p>
    <hr>
    <h4>Supported File Formats:</h4>
    <p>Generic 2-column (2θ intensity), .xrdml, .brml, .ras, .uxd, .udf, GSAS .esd/.xra</p>
    <hr>
    <h4>Chart Interaction:</h4>
    <p><b>Zoom:</b> Use the mouse wheel over the chart or an axis.</p>
    <p><b>Pan:</b> Click and drag the chart to pan.</p>
    <p><b>Reset View:</b> Right-click on the chart.</p>
    <p><b>Add BG Anchor:</b> Hold <b>Ctrl</b> and click on the chart to manually add an anchor point.</p>
</div>
</div>




                </div>
                <input type="file" id="file-input" class="hidden" accept=".brml,.csv,.ras,.txt,.esd,.gsa,.std,.udf,.xra,.xrdml,.xy">
            </div>

            <div class="tab-buttons">
                <button class="tab-btn active" data-tab="sample">Sample</button>
                <button class="tab-btn" data-tab="background">Background</button>
                <button class="tab-btn" data-tab="profile">Profile</button>
            </div>

            <div class="tab-content-panels">
                <div id="tab-panel-sample" class="tab-content-panel active">
                    <div class="control-group">
                        <h2>Structural Parameters</h2>
                        <div class="parameter-grid-2col">
                            <label for="bravais-lattice" class="control-label">System</label>
                            <select id="bravais-lattice" class="control-select">
                                <option value="cubic_F" selected>Cubic (F)</option>
                                <option value="cubic_I">Cubic (I)</option>
                                <option value="cubic_P">Cubic (P)</option>
                                <option value="hexagonal_P">Hexagonal (P)</option>
                                <option value="tetragonal_I">Tetragonal (I)</option>
                                <option value="tetragonal_P">Tetragonal (P)</option>
                                <option value="orthorhombic_F">Orthorhombic (F)</option>
                                <option value="orthorhombic_I">Orthorhombic (I)</option>
                                <option value="orthorhombic_C">Orthorhombic (C)</option>
                                <option value="orthorhombic_P">Orthorhombic (P)</option>
                                <option value="monoclinic_C">Monoclinic (C)</option>
                                <option value="monoclinic_P">Monoclinic (P)</option>
                            </select>
                        </div>
<div class="parameter-grid-2col">
    <label for="space-group-select" class="control-label">Space Group</label>
    <select id="space-group-select" class="control-select"></select>
</div>

                        <div id="lattice-parameters-container">
                        </div>
                    </div>

                    <div class="control-group">
                        <h2>Instrumental Parameters</h2>

                        <div class="parameter-grid-3col">
                            <label for="zero-shift" class="control-label">Zero (°)</label>
                            <input type="number" id="zero-shift" value="0.0" step="0.001" class="control-input">
                            <input type="checkbox" id="fit-zero-shift" class="fit-checkbox" title="Fit this parameter" >
                        </div>

                        <div class="form-row">
                            <label for="wavelength" class="control-label">Radiation 1 (Å)</label>
                            <input type="number" id="wavelength" value="1.54056" step="0.0001" class="control-input" min="0.01" title="Cu K-alpha 1">
                        </div>

                        <div class="form-row">
                            <label for="wavelength2" class="control-label">Radiation 2 (Å)</label>
                            <input type="number" id="wavelength2" value="1.54439" step="0.0001" class="control-input" min="0.01" title="Cu K-alpha 2">
                        </div>

                        <div class="form-row">
                            <label for="ratio21" class="control-label">Ratio (I₂/I₁)</label>
                            <input type="number" id="ratio21" value="0.497" step="0.01" class="control-input" min="0">
                        </div>
                    </div>

                </div>



                <div id="tab-panel-background" class="tab-content-panel">
                    <div class="control-group">
                        <h2>Background (Chebyshev Polynomial)</h2>
                        <div id="background-params-container" class="profile-controls-container">
                            </div>
                                                    
                        <h2>Background (Amorphous Hump)</h2>
                        <div class="profile-controls-container">
                             <label class="control-label">Hump Height</label>
                             <input type="number" id="param-hump-h" value="50" step="10" class="control-input">
                             <input type="checkbox" id="fit-hump-h" class="fit-checkbox"checked>
                             
                             <label class="control-label">Hump Position (°2θ)</label>
                             <input type="number" id="param-hump-p" value="25" step="0.1" class="control-input">
                             <input type="checkbox" id="fit-hump-p" class="fit-checkbox" checked>

                             <label class="control-label">Hump FWHM (°2θ)</label>
                             <input type="number" id="param-hump-w" value="12" step="0.1" class="control-input" min="0.01">
                             <input type="checkbox" id="fit-hump-w" class="fit-checkbox" checked>
                        </div>

                       <div style="padding-top: 16px; border-top: 1px solid var(--system-separator);">
                            <h2 style="margin-bottom: 6px;">Background Anchor Points</h2>
                            <p class="control-label" style="margin-bottom: 16px;">Use <b>Ctrl+Click</b> on the chart to select an experimental data point as a background anchor. This gives the point a higher weight during refinement.</p>
                            
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                                 <label for="show-anchors-checkbox" class="control-label" style="margin-bottom:0;">Show Anchors on Chart</label>
                                 <input type="checkbox" id="show-anchors-checkbox" class="fit-checkbox" checked>
                            </div>

                            <div id="anchor-points-list">
                                </div>
                        </div>
                      
                    </div>



                </div>

                <div id="tab-panel-profile" class="tab-content-panel">
                     <div class="control-group">
                        <div class="parameter-grid-2col" style="margin-bottom: 24px;">
                             <label for="profile-function-select" class="control-label">Profile Function</label>
<select id="profile-function-select" class="control-select">
   <option value="4" selected>Simple pVoigt</option>
   <option value="3">Anisotropy</option>
</select>
                        </div>

                        <div id="simple-pvoigt-params-container" class="profile-controls-container">
    <h3 class="profile-section-header">Gaussian Broadening</h3>
    <label class="control-label">GU</label>
    <input type="number" id="param-gu" value="0.035" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-gu" class="fit-checkbox">
    <label class="control-label">GV</label>
    <input type="number" id="param-gv" value="-0.03" step="0.01" class="control-input">
    <input type="checkbox" id="fit-gv" class="fit-checkbox" >
    <label class="control-label">GW</label>
    <input type="number" id="param-gw" value="0.02" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-gw" class="fit-checkbox" >
     <label class="control-label">GP</label>
    <input type="number" id="param-gp" value="0.0" step="0.001" class="control-input">
    <input type="checkbox" id="fit-gp" class="fit-checkbox">
    <h3 class="profile-section-header">Lorentzian Broadening</h3>
    <label class="control-label">LX</label>
    <input type="number" id="param-lx" value="0.05" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-lx" class="fit-checkbox" >
     <h3 class="profile-section-header">Peak Shape & Position</h3>
     <label class="control-label">eta (Mixing)</label>
    <input type="number" id="param-eta" value="0.74" step="0.01" min="0" max="1" class="control-input">
    <input type="checkbox" id="fit-eta" class="fit-checkbox">
     <label class="control-label">shft (Displ.)</label>
    <input type="number" id="param-shft" value="0" step="0.01" class="control-input">
    <input type="checkbox" id="fit-shft" class="fit-checkbox" >
     <label class="control-label">trns (Transp.)</label>
    <input type="number" id="param-trns" value="0" step="0.01" class="control-input">
    <input type="checkbox" id="fit-trns" class="fit-checkbox">
</div>

<div id="anisotropy-params-container" class="profile-controls-container hidden">
    <h3 class="profile-section-header">Isotropic Gaussian (TCH)</h3>
    <label class="control-label">U</label>
    <input type="number" id="param-u" value="0.04" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-u" class="fit-checkbox">
    <label class="control-label">V</label>
    <input type="number" id="param-v" value="-0.03" step="0.01" class="control-input">
    <input type="checkbox" id="fit-v" class="fit-checkbox" >
    <label class="control-label">W</label>
    <input type="number" id="param-w" value="0.02" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-w" class="fit-checkbox" >
    
    <h3 class="profile-section-header">Isotropic Lorentzian (TCH)</h3>
    <label class="control-label">X</label>
    <input type="number" id="param-x" value="0.001" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-x" class="fit-checkbox" >
    <label class="control-label">Y</label>
    <input type="number" id="param-y" value="0.005" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-y" class="fit-checkbox" >

        <h3 class="profile-section-header">Peak Asymmetry</h3>
    <label class="control-label">S/L</label>
    <input type="number" id="param-sl" value="0.0" step="0.001" class="control-input">
    <input type="checkbox" id="fit-sl" class="fit-checkbox">
    <label class="control-label">H/L</label>
    <input type="number" id="param-hl" value="0.0" step="0.001" class="control-input">
    <input type="checkbox" id="fit-hl" class="fit-checkbox" >


    <h3 class="profile-section-header">Anisotropic Broadening (Stephens)</h3>
    <label class="control-label">S400</label>
    <input type="number" id="param-s400" value="0.0" step="0.1" class="control-input">
    <input type="checkbox" id="fit-s400" class="fit-checkbox">
    <label class="control-label">S040</label>
    <input type="number" id="param-s040" value="0.0" step="0.1" class="control-input">
    <input type="checkbox" id="fit-s040" class="fit-checkbox">
    <label class="control-label">S004</label>
    <input type="number" id="param-s004" value="0.0" step="0.1" class="control-input">
    <input type="checkbox" id="fit-s004" class="fit-checkbox">
    <label class="control-label">S220</label>
    <input type="number" id="param-s220" value="0.0" step="0.1" class="control-input">
    <input type="checkbox" id="fit-s220" class="fit-checkbox">
     <label class="control-label">S202</label>
    <input type="number" id="param-s202" value="0.0" step="0.1" class="control-input">
    <input type="checkbox" id="fit-s202" class="fit-checkbox">
    <label class="control-label">S022</label>
    <input type="number" id="param-s022" value="0.0" step="0.1" class="control-input">
    <input type="checkbox" id="fit-s022" class="fit-checkbox">
    

</div>

                    </div>
                </div>
            </div>

            <div class="bottom-actions"> 
                 <div class="control-group" style="border-top: none; padding-top: 0;">
                     <h2>Refinement</h2>
                     <label for="algorithm-select" class="control-label">Method</label>
                     <select id="algorithm-select" class="control-select">
                        <option value="lm">Levenberg-Marquardt</option>
                        <option value="sa" selected>Simulated Annealing</option>
                        <option value="pt" selected>Parallel Tempering</option> </select>
                     </select>
                     
                     <div class="slider-group">
                         <label class="control-label">2θ Min</label>
                         <div class="slider-value-track">
                            <input type="range" id="tth-min-slider" class="custom-slider" disabled>
                            <span id="tth-min-value" class="slider-value-display">10.0</span>
                         </div>
                     </div>
                     
                     <div class="slider-group">
                         <label class="control-label">2θ Max</label>
                         <div class="slider-value-track">
                             <input type="range" id="tth-max-slider" class="custom-slider" disabled>
                             <span id="tth-max-value" class="slider-value-display">80.0</span>
                         </div>
                     </div>

                     <div class="slider-group">
                         <label class="control-label">Max Iterations</label>
                         <div class="slider-value-track">
                            <input type="range" id="iterations-slider" min="1" max="80" value="20" step="1" class="custom-slider">
                            <span id="iterations-value" class="slider-value-display">20</span>
                         </div>
                     </div>

                     <div id="progress-bar-container" class="hidden" style="width: 100%; border-radius: 3px; height: 5px;">
                        <div id="progress-bar" style="height: 100%; width: 0%; border-radius: 3px;"></div>
                     </div>
                     <div class="results-grid">
                        <div class="result-card">
                            <div class="result-card-label">Rp (%)</div>
                            <div id="rp-result" class="result-card-value">-</div>
                        </div>
                        <div class="result-card">
                            <div class="result-card-label">Rwp (%)</div>
                            <div id="rwp-result" class="result-card-value">-</div>
                        </div>
                        <div class="result-card">
                            <div class="result-card-label">χ² (GOF)</div>
                            <div id="chi2-result" class="result-card-value">-</div>
                        </div>
                     </div>
                </div>
                <div style="display: flex; flex-direction: column; gap: 16px; margin-top: 16px;">


                    <div style="display: flex; flex-direction: column; gap: 16px; margin-top: 16px;">
    <div style="display: flex; gap: 10px;">
        <button id="le-bail-button" class="btn btn-primary" style="flex: 1;" disabled>Run Le Bail</button>
        <button id="pawley-button" class="btn btn-primary" style="flex: 1;" disabled>Run Pawley</button>
    </div>

    <div style="display: flex; gap: 10px;">
        <button id="save-data-button" class="btn btn-secondary" style="flex: 1;" disabled>Save Report</button>
        <button id="report-button" class="btn btn-secondary" style="flex: 1;" disabled>Generate PDF</button>
    </div>
</div>
                </div>
            </div>
        </div>


        <div id="drag-handle"></div>

<div id="results-area" style="position: relative; flex-grow: 1; min-height: 0;">
    <div id="placeholder" style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; color: var(--system-secondary-label);">
        <svg xmlns="http://www.w3.org/2000/svg" style="width: 64px; height: 64px; margin-bottom: 16px;" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>
        <h2 style="font-size: 22px; font-weight: 600; margin-bottom: 8px;">Awaiting Data</h2>
        <p style="font-size: 16px; color: var(--system-secondary-label);">Load a data file to begin.</p>
    </div>

    <div id="results-container" style="width: 100%; height: 100%; display: none; flex-direction: column; position: relative;">
        <canvas id="main-chart"></canvas>
    </div>

    <div style="position: absolute; bottom: 6px; right: 12px; font-size: 10px; color: var(--system-secondary-label);">
        Powder 5, version 109, 13 Oct 2025
    </div>
</div>




<script>
    document.addEventListener('DOMContentLoaded', () => {      

        const NUM_BACKGROUND_PARAMS = 9;
        const CALCULATION_WINDOW_MULTIPLIER = 6.0; //avant 109 c'estai 8
        const PEAK_HEIGHT_CUTOFF = 0.002; // 0.01 Corresponds to 1%
 
const tooltipContainer = document.querySelector('.help-tooltip-container');
const tooltipContent = document.querySelector('.tooltip-content');
let tooltipTimer;

if (tooltipContainer && tooltipContent) {
    tooltipContainer.addEventListener('mouseenter', () => {
        // If a timer is set to hide the tooltip, cancel it
        clearTimeout(tooltipTimer);
        // Add the 'visible' class to show the tooltip
        tooltipContent.classList.add('visible');
    });

    tooltipContainer.addEventListener('mouseleave', () => {
        // Start a new timer to hide the tooltip after 1 second
        tooltipTimer = setTimeout(() => {
            tooltipContent.classList.remove('visible');
        }, 1000); //  milliseconds 
    });
}


        const controls = {
            fileInput: document.getElementById('file-input'),
            fileName: document.getElementById('file-name'),
            bravaisLattice: document.getElementById('bravais-lattice'),
            spaceGroupSelect: document.getElementById('space-group-select'),

            latticeParamsContainer: document.getElementById('lattice-parameters-container'),
            wavelength: document.getElementById('wavelength'),
      wavelength2: document.getElementById('wavelength2'), // le 29 sept 25, dublet Ka
        ratio21: document.getElementById('ratio21'),      
            zeroShift: document.getElementById('zero-shift'),
            fitZeroShift: document.getElementById('fit-zero-shift'),
            profileSelect: document.getElementById('profile-function-select'),
            simplePVoigtParamsContainer: document.getElementById('simple-pvoigt-params-container'),
            anisotropyParamsContainer: document.getElementById('anisotropy-params-container'),
            paramGU: document.getElementById('param-gu'), fitGU: document.getElementById('fit-gu'),
            paramGV: document.getElementById('param-gv'), fitGV: document.getElementById('fit-gv'),
            paramGW: document.getElementById('param-gw'), fitGW: document.getElementById('fit-gw'),
            paramGP: document.getElementById('param-gp'), fitGP: document.getElementById('fit-gp'),
            paramLX: document.getElementById('param-lx'), fitLX: document.getElementById('fit-lx'),
            paramEta: document.getElementById('param-eta'), fitEta: document.getElementById('fit-eta'),
            paramShft: document.getElementById('param-shft'), fitShft: document.getElementById('fit-shft'),
            paramTrns: document.getElementById('param-trns'), fitTrns: document.getElementById('fit-trns'),
            paramU: document.getElementById('param-u'), fitU: document.getElementById('fit-u'),
            paramV: document.getElementById('param-v'), fitV: document.getElementById('fit-v'),
            paramW: document.getElementById('param-w'), fitW: document.getElementById('fit-w'),
            paramX: document.getElementById('param-x'), fitX: document.getElementById('fit-x'),
            paramY: document.getElementById('param-y'), fitY: document.getElementById('fit-y'),
            paramSL: document.getElementById('param-sl'), fitSL: document.getElementById('fit-sl'),
            paramHL: document.getElementById('param-hl'), fitHL: document.getElementById('fit-hl'),
            paramS400: document.getElementById('param-s400'), fitS400: document.getElementById('fit-s400'),
            paramS040: document.getElementById('param-s040'), fitS040: document.getElementById('fit-s040'),
            paramS004: document.getElementById('param-s004'), fitS004: document.getElementById('fit-s004'),
            paramS220: document.getElementById('param-s220'), fitS220: document.getElementById('fit-s220'),
            paramS202: document.getElementById('param-s202'), fitS202: document.getElementById('fit-s202'),
            paramS022: document.getElementById('param-s022'), fitS022: document.getElementById('fit-s022'),
            algorithmSelect: document.getElementById('algorithm-select'),
            iterationsSlider: document.getElementById('iterations-slider'),
            iterationsValue: document.getElementById('iterations-value'),
            tthMinSlider: document.getElementById('tth-min-slider'),
            tthMinValue: document.getElementById('tth-min-value'),
            tthMaxSlider: document.getElementById('tth-max-slider'),
            tthMaxValue: document.getElementById('tth-max-value'),
            fitButton: document.getElementById('fit-button'),
            reportButton: document.getElementById('report-button'),
            saveDataButton: document.getElementById('save-data-button'),
            progressBar: document.getElementById('progress-bar'),
            progressBarContainer: document.getElementById('progress-bar-container'),
            rpResult: document.getElementById('rp-result'),
            rwpResult: document.getElementById('rwp-result'),
            chi2Result: document.getElementById('chi2-result'),
            mainChartCanvas: document.getElementById('main-chart'),
            placeholder: document.getElementById('placeholder'),
            resultsContainer: document.getElementById('results-container'),
                    };

const bgContainer = document.getElementById('background-params-container');
        if (bgContainer) { 
            let bgHtml = '';
            const initialBgValues = [100, 5, ...Array(NUM_BACKGROUND_PARAMS - 2).fill(0)];
            for (let i = 0; i < NUM_BACKGROUND_PARAMS; i++) {
                bgHtml += `
                    <label class="control-label">B${i}</label>
                    <input type="number" id="param-b${i}" value="${initialBgValues[i] || 0}" step="1" class="control-input">
                    <input type="checkbox" id="fit-b${i}" class="fit-checkbox" checked>
                `;
            }
            bgContainer.innerHTML = bgHtml;
        }


        // --- Global State ---
        let profileParamCache = { "3": {}, "4": {} };
        let currentProfile = "4";
       
      
        let fullExperimentalData = { tth: new Float64Array(), intensity: new Float64Array() };
        let calculatedBackground = new Float64Array();
        let workingDataCache = { tth: new Float64Array(), intensity: new Float64Array(), background: new Float64Array(), isValid: false };

        let fitResults = null;
        let lastFitResultsCache = null; //changement le 6 oct 25
        let mainChart;
        let isFitting = false;
        let lastGeneratedHklList = [];
        let backgroundAnchors = []; // Stores {tth, y} objects
        const HIGH_WEIGHT_MULTIPLIER = 50.0
         let masterHklList = [];
         let hklIndexCache = {}; //ajouté le 8 oct 25, on met en cache les hkl

         updateSpaceGroupUI();

// ANCHORs MANAGEMENT
        function updateAnchorPointsOnChart() {
            if (!mainChart) return;

            const anchorDataset = mainChart.data.datasets.find(d => d.label === 'Anchor Points');
            if (anchorDataset) {
                // Map the anchors to the {x, y} format required by Chart.js scatter plots
                anchorDataset.data = backgroundAnchors.map(anchor => ({
                    x: anchor.tth,
                    y: anchor.y
                }));
               mainChart.update('none'); // Redraw the chart without animation
            }
        }

        // function to find the nearest data point to a click
        function findClosestExperimentalPoint(targetTth) {
            if (!fullExperimentalData || fullExperimentalData.tth.length === 0) {
                return null;
            }

            let closestIndex = -1;
            let minDiff = Infinity;

            // This is a simple linear search. .. j'aurais pu utiliser la librairie JS.. mais bon, c'est autonome
            for (let i = 0; i < fullExperimentalData.tth.length; i++) {
                const diff = Math.abs(fullExperimentalData.tth[i] - targetTth);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestIndex = i;
                }
            }

            return {
                index: closestIndex,
                tth: fullExperimentalData.tth[closestIndex],
                y: fullExperimentalData.intensity[closestIndex]
            };
        }

        // display non-editable points
        function renderAnchorList() {
            const listContainer = document.getElementById('anchor-points-list');
            listContainer.innerHTML = ''; 

            if (backgroundAnchors.length === 0) {
                listContainer.innerHTML = '<p class="control-label" style="text-align: center;">No anchor points defined.</p>';
            } else {
                backgroundAnchors.forEach((anchor, index) => {
                    const item = document.createElement('div');
                    item.className = 'anchor-point-item';
                    // Display values as text, not inputs
                    item.innerHTML = `
                        <span title="2-theta">${anchor.tth.toFixed(3)}</span>
                        <span title="Intensity">${anchor.y.toFixed(1)}</span>
                        <button class="anchor-remove-btn" data-index="${index}" title="Remove point">&times;</button>
                    `;
                    listContainer.appendChild(item);
                });
            }
            updateAnchorPointsOnChart();
        }

        // Simplified function to only handle removing points
        function handleAnchorListInteraction(e) {
            if (e.target.classList.contains('anchor-remove-btn')) {
                const index = parseInt(e.target.dataset.index, 10);
                if (!isNaN(index)) {
                    backgroundAnchors.splice(index, 1);
                    renderAnchorList();
                    updateBackgroundForPreview();
                }
            }
        }
    
        /**
         * Calculates the total background contribution from Chebyshev polynomials and an amorphous hump.
         * This version is optimized to return a Float64Array for improved performance.
         * @param {Float64Array} tthAxis - The array of 2-theta values.
         * @param {object} params - The object containing all refinement parameters.
         * @returns {Float64Array} A new array containing the calculated background intensity at each point.
         */
        function calculateTotalBackground(tthAxis, params) {
            // --- 1. Pre-computation and setup ---
            const n = tthAxis.length;
            if (n === 0) {
                return new Float64Array();
            }

            const background = new Float64Array(n); // Allocate the typed array upfront

            // Extract and check Chebyshev parameters
            const chebyshevCoefficients = [];
            let hasChebyshev = false;
            for (let i = 0; i < NUM_BACKGROUND_PARAMS; i++) {
                const coeff = params[`B${i}`] || 0;
                chebyshevCoefficients[i] = coeff;
                if (Math.abs(coeff) > 1e-9) hasChebyshev = true;
            }

            // Extract and pre-calculate for Amorphous Hump
            const humpHeight = params.hump_H || 0;
            let hasHump = humpHeight > 1e-9;
            let humpPosition, hwhm_sq;
            if (hasHump) {
                humpPosition = params.hump_P || 0;
                const fwhm = params.hump_W || 1;
                hwhm_sq = (fwhm / 2) * (fwhm / 2);
                if (hwhm_sq < 1e-9) hasHump = false; // Avoid division by zero
            }

            // Pre-calculate scaling factors for Chebyshev
            let tthMin, tthRange;
            if (hasChebyshev) {
                tthMin = tthAxis[0];
                tthRange = tthAxis[tthAxis.length - 1] - tthMin;
                if (tthRange <= 0) hasChebyshev = false; // Avoid division by zero
            }

            // Early exit if there's nothing to calculate
            if (!hasChebyshev && !hasHump) {
                return background; // Return the zero-filled Float64Array
            }

            // --- 2. Single loop calculation ---
            for (let i = 0; i < n; i++) {
                const tth = tthAxis[i];
                let totalBackgroundValue = 0;

                // Calculate Chebyshev part if needed
                if (hasChebyshev) {
                    const x_prime = (2 * (tth - tthMin) / tthRange) - 1;

                    let t_n_minus_1 = 1; // T_0(x)
                    let t_n = x_prime; // T_1(x)

                    let chebyshevValue = chebyshevCoefficients[0] * t_n_minus_1;
                    if (chebyshevCoefficients.length > 1) {
                        chebyshevValue += (chebyshevCoefficients[1] || 0) * t_n;
                    }

                    for (let n = 2; n < chebyshevCoefficients.length; n++) {
                        const t_n_plus_1 = 2 * x_prime * t_n - t_n_minus_1;
                        chebyshevValue += (chebyshevCoefficients[n] || 0) * t_n_plus_1;
                        t_n_minus_1 = t_n;
                        t_n = t_n_plus_1;
                    }
                    totalBackgroundValue += chebyshevValue;
                }

                // Calculate Amorphous Hump part if needed
                if (hasHump) {
                    const diff = tth - humpPosition;
                    const humpValue = humpHeight / (1 + (diff * diff) / hwhm_sq);
                    totalBackgroundValue += humpValue;
                }
                
                background[i] = totalBackgroundValue;
            }
            
            return background;
        }



        function updateStephensAnisotropyUI() {
            const { system } = getSystemAndCentering();
            const sParams = { s400: { input: controls.paramS400, fit: controls.fitS400 }, s040: { input: controls.paramS040, fit: controls.fitS040 }, s004: { input: controls.paramS004, fit: controls.fitS004 }, s220: { input: controls.paramS220, fit: controls.fitS220 }, s202: { input: controls.paramS202, fit: controls.fitS202 }, s022: { input: controls.paramS022, fit: controls.fitS022 }, };
            for (const key in sParams) { sParams[key].input.disabled = false; sParams[key].fit.disabled = false; sParams[key].input.style.backgroundColor = ''; }
            switch (system) {
                case 'cubic':
                    sParams.s040.input.value = sParams.s400.input.value; sParams.s004.input.value = sParams.s400.input.value; sParams.s040.fit.checked = sParams.s400.fit.checked; sParams.s004.fit.checked = sParams.s400.fit.checked; sParams.s202.input.value = sParams.s220.input.value; sParams.s022.input.value = sParams.s220.input.value; sParams.s202.fit.checked = sParams.s220.fit.checked; sParams.s022.fit.checked = sParams.s220.fit.checked;
                    [sParams.s040, sParams.s004, sParams.s202, sParams.s022].forEach(p => { p.input.disabled = true; p.fit.disabled = true; p.input.style.backgroundColor = 'var(--system-gray-5)'; });
                    break;
                case 'hexagonal': case 'tetragonal': case 'rhombohedral':
                    sParams.s040.input.value = sParams.s400.input.value; sParams.s040.fit.checked = sParams.s400.fit.checked; sParams.s022.input.value = sParams.s202.input.value; sParams.s022.fit.checked = sParams.s202.fit.checked;
                    [sParams.s040, sParams.s022].forEach(p => { p.input.disabled = true; p.fit.disabled = true; p.input.style.backgroundColor = 'var(--system-gray-5)'; });
                    break;
            }
        }

        const verticalCursorLine = { id: 'verticalCursorLine', afterDraw: chart => { if (chart.tooltip?._active?.length) { let x = chart.tooltip._active[0].element.x, yAxis = chart.scales.y, ctx = chart.ctx; ctx.save(); ctx.beginPath(); ctx.moveTo(x, yAxis.top); ctx.lineTo(x, yAxis.bottom); ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(156, 163, 175, 0.7)'; ctx.setLineDash([4, 4]); ctx.stroke(); ctx.restore(); } } };
        Chart.register(verticalCursorLine);
        Chart.Tooltip.positioners.experimentalAnchor = function(items) { if (!items.length) return false; const experimentalItem = items.find(item => item.datasetIndex === 0) || items[0]; return { x: experimentalItem.element.x, y: experimentalItem.element.y }; };
        
                function getSystemAndCentering() {
            let [system, centering] = controls.bravaisLattice.value.split('_');
            // 9. r Rhombohedral, maille hex
            if (system === "rhombohedral") {
                centering = "R"; // Force centering to 'R' for rhombohedral system
            }
            return { system, centering };
        }

        function saveProfileState(profileId) { const state = {}; const container = document.getElementById((profileId === '4') ? 'simple-pvoigt-params-container' : 'anisotropy-params-container'); if (container) container.querySelectorAll('input[type="number"], input[type="checkbox"]').forEach(input => { state[input.id] = (input.type === 'checkbox') ? input.checked : input.value; }); profileParamCache[profileId] = state; }
        function restoreProfileState(profileId) { const state = profileParamCache[profileId]; if (!state || Object.keys(state).length === 0) return; const container = document.getElementById((profileId === '4') ? 'simple-pvoigt-params-container' : 'anisotropy-params-container'); if (container) container.querySelectorAll('input[type="number"], input[type="checkbox"]').forEach(input => { if (state[input.id] !== undefined) input.type === 'checkbox' ? (input.checked = state[input.id]) : (input.value = state[input.id]); }); }
        
        // Data mapping systems to their possible Laue classes...peut etre mieux de les mettres dans la const spaceGroups ?
        const laueClassMap = {
            'cubic': [{ value: 'm-3m', text: 'm-3m' }, { value: 'm-3', text: 'm-3' }],
            'hexagonal': [{ value: '6/mmm', text: '6/mmm' }, { value: '6/m', text: '6/m' }],
            'rhombohedral': [{ value: '-3m', text: '-3m (Rhom. axes)' }, { value: '-3', text: '-3 (Rhom. axes)' }],
            'tetragonal': [{ value: '4/mmm', text: '4/mmm' }, { value: '4/m', text: '4/m' }],
            'orthorhombic': [{ value: 'mmm', text: 'mmm' }],
            'monoclinic': [{ value: '2/m', text: '2/m' }],
        };


function getSpaceGroupCentering(spaceGroupName) {
    const firstLetter = spaceGroupName.charAt(0).toUpperCase();
    if (firstLetter === "R") return "R"; // rhombohedral, mais en axes hex, à vérifier
    return firstLetter; // P, I, F, C, A, etc.
}

    //  updateSpaceGroupUI, v 108
    // les rhombo dans les axes hexa
function updateSpaceGroupUI() {
    const { system } = getSystemAndCentering();
    if (!spaceGroups.length) return; // Wait until data is defined

    const filteredGroups = spaceGroups.filter(sg => {
        // -
        // Create a special case for the hexagonal system to include rhombohedral ('R') groups.
        if (system === 'hexagonal') {
            // Show any group that is either 'hexagonal' OR is 'trigonal' with an 'R' name.
            return sg.system === 'hexagonal' || sg.system === 'trigonal';
        }
        
        // The original logic works correctly for all other systems.
        const selectedCentering = controls.bravaisLattice.value.split('_')[1];
        const sgCentering = sg.name.charAt(0).toUpperCase();
        return sg.system === system && sgCentering === selectedCentering;
    });

    controls.spaceGroupSelect.innerHTML = "";
    filteredGroups.forEach(sg => {
        const opt = document.createElement("option");
        opt.value = sg.number;
        opt.textContent = `${sg.number} – ${sg.name}`;
        controls.spaceGroupSelect.appendChild(opt);
    });
}

        function updateLatticeParamUI() {
            const currentValues = {}; const container = controls.latticeParamsContainer;
            container.querySelectorAll('input[type="number"]').forEach(input => { const name = input.id.replace('lattice-param-', ''); if (input.value) currentValues[name] = input.value; });
            const { system } = getSystemAndCentering(); container.innerHTML = '';
            const createInput = (name, label, defaultValue, step, isAngle = false) => {
                const valueToUse = currentValues[name] !== undefined ? currentValues[name] : defaultValue; const id_base = `lattice-param-${name}`; const unit = isAngle ? '°' : 'Å'; const minAttribute = isAngle ? '' : 'min="0.001"';
                const row = document.createElement('div'); row.className = 'parameter-grid-3col'; row.innerHTML = `<label for="${id_base}" class="control-label">${label} (${unit})</label><input type="number" id="${id_base}" value="${valueToUse}" step="${step}" class="control-input" ${minAttribute}><input type="checkbox" id="fit-lattice-${name}" class="fit-checkbox" title="Fit this parameter" checked>`; container.appendChild(row);
            };
            const params = { cubic: [{ name: 'a', label: 'a', value: 4.23, step: 0.001 }], tetragonal: [{ name: 'a', label: 'a', value: 4.0, step: 0.001 }, { name: 'c', label: 'c', value: 5.0, step: 0.001 }], orthorhombic: [{ name: 'a', label: 'a', value: 4.0, step: 0.001 }, { name: 'b', label: 'b', value: 5.0, step: 0.001 }, { name: 'c', label: 'c', value: 6.0, step: 0.001 }], hexagonal: [{ name: 'a', label: 'a', value: 4.0, step: 0.001 }, { name: 'c', label: 'c', value: 6.0, step: 0.001 }], rhombohedral: [{ name: 'a', label: 'a', value: 5.5, step: 0.001 }, { name: 'c', label: 'c', value: 15.0, step: 0.001 }], monoclinic: [{ name: 'a', label: 'a', value: 4.0, step: 0.001 }, { name: 'b', label: 'b', value: 5.0, step: 0.001 }, { name: 'c', label: 'c', value: 6.0, step: 0.001 }, { name: 'beta', label: 'β', value: 105.0, step: 0.01, isAngle: true }] };
            if(params[system]) params[system].forEach(p => createInput(p.name, p.label, p.value, p.step, p.isAngle));
        }


        function updateUIForSystemChange() {
            updateLatticeParamUI();
            updateSpaceGroupUI();
            updateStephensAnisotropyUI();
        }

        // This event listener triggers all UI updates.
        controls.bravaisLattice.addEventListener('change', updateUIForSystemChange);

        const detectAndParseFile = (fileName, fileContent) => {
    const name = fileName.toLowerCase();
    const lines = fileContent.trim().split(/\r?\n/);
    const firstLine = lines.length > 0 ? lines[0].trim() : '';
    
    if (name.endsWith('.uxd') || firstLine.startsWith('_FILEVERSION')) return parseUxdFile(fileContent);
    if (name.endsWith('.xrdml') || (fileContent.includes('<?xml') && fileContent.includes('<xrdMeasurement'))) return parseXrdmlFile(fileContent);
    if (name.endsWith('.brml') || (fileContent.includes('<?xml') && fileContent.includes('<RawDataFile'))) return parseBrukerBrmlFile(fileContent);
    if (name.endsWith('.ras') || fileContent.toUpperCase().includes('*RAS_HEADER_START')) return parseRigakuRasFile(fileContent);
    if (name.endsWith('.udf')) return parsePhilipsUdfFile(fileContent);

    // GSAS detection logic
    const bankLine = lines.find(line => line.trim().toUpperCase().startsWith('BANK'));
    if (bankLine) {
        // XRA format has 'STD' on the same line as 'BANK'
        if (bankLine.toUpperCase().includes('STD')) {
            return parseGsasXraFile(fileContent);
        }
        // Otherwise, assume it's the ESD format (Y, sigY pairs)
        return parseGsasEsdFile(fileContent);
    }

    // Fallback to generic two-column parser
    return parseDataFile(fileContent);
};
        
        const parseDataFile = (text) => { const lines = text.trim().split(/\r?\n/); const tth = [], intensity = []; lines.forEach(line => { if (line.startsWith('#') || line.startsWith('//') || line.trim() === '') return; const parts = line.trim().split(/[\s,;]+/); if (parts.length >= 2) { const x = parseFloat(parts[0]); const y = parseFloat(parts[1]); if (!isNaN(x) && !isNaN(y)) { tth.push(x); intensity.push(y); } } }); return { tth, intensity }; };
        const parseXrdmlFile = (xmlString) => { const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlString, "application/xml"); if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing XRDML file."); } let wavelength = null; const kAlpha1Node = xmlDoc.querySelector("kAlpha1"); if (kAlpha1Node?.textContent) wavelength = parseFloat(kAlpha1Node.textContent); const intensityNode = xmlDoc.querySelector("intensities") || xmlDoc.querySelector("counts"); if (!intensityNode) throw new Error("Could not find <intensities> or <counts> in XRDML file."); const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number); const positionsNode = xmlDoc.querySelector('positions[axis="2Theta"]'); if (!positionsNode) throw new Error("Could not find <positions> in XRDML file."); const startPosNode = positionsNode.querySelector("startPosition"); const endPosNode = positionsNode.querySelector("endPosition"); if (!startPosNode || !endPosNode) throw new Error("Could not find start/end positions in XRDML."); const startPos = parseFloat(startPosNode.textContent); const endPos = parseFloat(endPosNode.textContent); const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * (endPos - startPos) / (intensity.length - 1)); return { tth, intensity, wavelength }; };
        const parseBrukerBrmlFile = (xmlString) => { const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlString, "application/xml"); if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing BRML file."); } let wavelength = null; const wlNode = xmlDoc.querySelector('usedWavelength'); if (wlNode) { const kAlpha1 = wlNode.getAttribute('kAlpha1'); if (kAlpha1) wavelength = parseFloat(kAlpha1); } const intensityNode = xmlDoc.querySelector("dataPoints > counts"); if (!intensityNode) throw new Error("No <counts> data found in BRML file."); const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number); const startPosNode = xmlDoc.querySelector('startPosition[axis="TwoTheta"]'); const stepSizeNode = xmlDoc.querySelector('increment[axis="TwoTheta"]'); if (!startPosNode || !stepSizeNode) throw new Error("Could not find scan parameters in BRML file."); const startPos = parseFloat(startPosNode.textContent); const stepSize = parseFloat(stepSizeNode.textContent); const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * stepSize); return { tth, intensity, wavelength }; };
        const parseRigakuRasFile = (text) => { const lines = text.trim().split(/\r?\n/); const tth = [], intensity = []; let inDataSection = false; let wavelength = null; for (const line of lines) { const upperLine = line.toUpperCase(); if (upperLine.startsWith('*WAVE_LENGTH') || upperLine.startsWith('*MEAS_COND_XG_WAVE_LENGTH')) { const parts = line.trim().split(/\s+/); if (parts.length > 1) { const wl = parseFloat(parts[1]); if (!isNaN(wl)) wavelength = wl; } } if (upperLine.startsWith('*RAS_INT_START')) { inDataSection = true; continue; } if (upperLine.startsWith('*RAS_INT_END')) break; if (inDataSection) { const parts = line.trim().split(/[\s,]+/); if (parts.length >= 2) { const x = parseFloat(parts[0]); const y = parseFloat(parts[1]); if (!isNaN(x) && !isNaN(y)) { tth.push(x); intensity.push(y); } } } } if (tth.length === 0) throw new Error("No data found in RAS file data section."); return { tth, intensity, wavelength }; };
        const parseGsasEsdFile = (text) => { const lines = text.trim().split(/\r?\n/); let wavelength = null; let startTth, stepSize; let dataStartIndex = -1; lines.forEach((line, index) => { const upperLine = line.toUpperCase(); if (upperLine.includes('WAVELENGTH')) { const match = line.match(/wavelength\s+([0-9.]+)/i); if (match && match[1]) wavelength = parseFloat(match[1]); } if (upperLine.startsWith('BANK')) { const parts = line.trim().split(/\s+/); if (parts.length >= 6 && parts[4].toUpperCase() === 'CONST') { startTth = parseFloat(parts[5]) / 100.0; stepSize = parseFloat(parts[6]) / 100.0; dataStartIndex = index + 1; } } }); if (startTth === undefined || stepSize === undefined) throw new Error("GSAS Parse Error: Could not find a valid 'BANK' line with CONST scan parameters."); if (dataStartIndex !== -1 && lines[dataStartIndex]?.toUpperCase().includes('STD')) dataStartIndex++; if (dataStartIndex === -1 || dataStartIndex >= lines.length) throw new Error("GSAS Parse Error: Found scan parameters but no subsequent data lines."); const intensity = []; for (let i = dataStartIndex; i < lines.length; i++) { const parts = lines[i].trim().split(/\s+/); for (let j = 1; j < parts.length; j += 2) { const val = parseFloat(parts[j]); if (!isNaN(val)) intensity.push(val); } } if (intensity.length === 0) throw new Error("GSAS Parse Error: No intensity data could be parsed."); const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize); return { tth, intensity, wavelength }; };
        
        const parseGsasXraFile = (text) => {
    const lines = text.trim().split(/\r?\n/);
    let wavelength = null;
    let startTth, stepSize;
    let dataStartIndex = -1;
    lines.forEach((line, index) => {
        const upperLine = line.toUpperCase();
        if (upperLine.includes('WAVELENGTH')) {
            const match = line.match(/wavelength\s+([0-9.]+)/i);
            if (match && match[1]) wavelength = parseFloat(match[1]);
        }
        if (upperLine.startsWith('BANK')) {
            const parts = line.trim().split(/\s+/);
            // This format has CONST at index 4, start at 5, step at 6
            if (parts.length >= 7 && parts[4].toUpperCase() === 'CONST') {
                startTth = parseFloat(parts[5]) / 100.0;
                stepSize = parseFloat(parts[6]) / 100.0;
                dataStartIndex = index + 1; // Data starts on the next line
            }
        }
    });

    if (startTth === undefined || stepSize === undefined) throw new Error("GSAS XRA Parse Error: Could not find a valid 'BANK' line with CONST scan parameters.");
    if (dataStartIndex === -1 || dataStartIndex >= lines.length) throw new Error("GSAS XRA Parse Error: Found scan parameters but no subsequent data lines.");

    const intensity = [];
    for (let i = dataStartIndex; i < lines.length; i++) {
        // Ignore blank lines that might be at the end of the file
        if (lines[i].trim() === '') continue;
        const parts = lines[i].trim().split(/\s+/);
        // This loop reads every value, as XRA format is intensity-only
        for (let j = 0; j < parts.length; j++) {
            const val = parseFloat(parts[j]);
            if (!isNaN(val)) intensity.push(val);
        }
    }
    if (intensity.length === 0) throw new Error("GSAS XRA Parse Error: No intensity data could be parsed.");
    const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize);
    return { tth, intensity, wavelength };
};
        
        const parseUxdFile = (text) => { const lines = text.trim().split(/\r?\n/); const intensity = []; let startTth, stepSize, wavelength; let inDataSection = false; for (const line of lines) { const trimmedLine = line.trim(); if (inDataSection) { const parts = trimmedLine.split(/\s+/); parts.forEach(part => { const val = parseFloat(part); if (!isNaN(val)) intensity.push(val); }); } else { if (trimmedLine.toUpperCase().startsWith('_START=')) startTth = parseFloat(trimmedLine.substring(7)); else if (trimmedLine.toUpperCase().startsWith('_STEPSIZE=')) stepSize = parseFloat(trimmedLine.substring(10)); else if (trimmedLine.toUpperCase().startsWith('_WL1=')) wavelength = parseFloat(trimmedLine.substring(5)); else if (trimmedLine.toUpperCase() === '_COUNTS') inDataSection = true; } } if (startTth === undefined || stepSize === undefined) throw new Error("Could not find _START and _STEPSIZE in UXD file."); if (intensity.length === 0) throw new Error("No intensity data found after _COUNTS in UXD file."); const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize); return { tth, intensity, wavelength }; };
        const parsePhilipsUdfFile = (text) => { const lines = text.trim().split(/\r?\n/); const tth = [], intensity = []; let inDataSection = false; let wavelength = null; for (const line of lines) { const trimmedLine = line.trim(); if (trimmedLine.toUpperCase().startsWith('LAMBDA')) { const parts = trimmedLine.split('='); if (parts.length > 1) wavelength = parseFloat(parts[1]); } if (trimmedLine.toUpperCase() === '[DATA]') { inDataSection = true; continue; } if (trimmedLine.startsWith('[') && trimmedLine.toUpperCase() !== '[DATA]') inDataSection = false; if (inDataSection) { const parts = trimmedLine.split(/,/).map(p => p.trim()); if(parts.length >= 2) { const x = parseFloat(parts[0]); const y = parseFloat(parts[1]); if (!isNaN(x) && !isNaN(y)) { tth.push(x); intensity.push(y); } } } } if (tth.length === 0) throw new Error("No [Data] section found in UDF file."); return { tth, intensity, wavelength }; };



        // Global cache for the data used in fitting, 
        let workingData = {
            tth: [],
            intensity: [],
            weights: [],
            startIndex: 0, // Store the starting index from the full dataset
            lastRawDifference: [],
            isValid: false
        };

        /**
         * This function is the single source of truth for refinement data.
         * It slices the fullExperimentalData based on slider values and, critically,
         * pre-calculates the weights array using Float64Array for performance.
         */
        function updateWorkingData() {
            if (fullExperimentalData.tth.length === 0) {
                workingData.isValid = false;
                return;
            }
            const minTth = parseFloat(controls.tthMinSlider.value);
            const maxTth = parseFloat(controls.tthMaxSlider.value);

            // Find the start and end indices in the master 'fullExperimentalData' array
            let startIndex = fullExperimentalData.tth.findIndex(t => t >= minTth);
            if (startIndex === -1) startIndex = 0;

            let endIndex = fullExperimentalData.tth.findIndex(t => t > maxTth);
            if (endIndex === -1) endIndex = fullExperimentalData.tth.length;

            // Slice the master typed arrays; .slice() on a typed array returns a new typed array
            workingData.tth = fullExperimentalData.tth.slice(startIndex, endIndex);
            workingData.intensity = fullExperimentalData.intensity.slice(startIndex, endIndex);
            workingData.startIndex = startIndex; // Store the offset

            // Pre-calculate weights into a new Float64Array for performance
            const n = workingData.intensity.length;
            workingData.weights = new Float64Array(n);
            const anchorIndices = new Set(backgroundAnchors.map(a => a.index));
            
            const yMax = Math.max(...workingData.intensity);
            const floor = 0.001 * yMax; // Floor is 0.1% of maximum, similar to GSAS

            for (let i = 0; i < n; i++) {
                let weight = 1 / Math.max(floor, workingData.intensity[i]);
                if (anchorIndices.has(startIndex + i)) {
                    weight *= HIGH_WEIGHT_MULTIPLIER;
                }
                workingData.weights[i] = weight;
            }

            workingData.isValid = true;
        }



        function evaluateExpression(expr, h, k, l) {
            switch (expr.trim()) {
                case 'h+k': return h + k;
                case 'k+l': return k + l;
                case 'h+l': return h + l;
                case 'h+k+l': return h + k + l;
                case '-h+k+l': return -h + k + l;
                case 'h-k+l': return h - k + l;
                case '2h+l': return 2 * h + l;
                case 'h': return h;
                case 'k': return k;
                case 'l': return l;
                default: return NaN; // Return NaN for unknown expressions
            }
        }

        /**
 * Main entry point to check if a reflection is allowed by the space group rules.
 * @returns {boolean} True if the reflection is allowed.
 */
function isReflectionAllowed(h, k, l, spaceGroup) {
    const ruleTree = spaceGroup.rule_tree;

    // If no rules, all reflections are allowed
    if (!ruleTree || Object.keys(ruleTree).length === 0) {
        return true;
    }

    return evaluateRuleTree(h, k, l, ruleTree);
}

/**
 * Recursively evaluates the rule tree for a given reflection.
 * @returns {boolean} The result of the rule evaluation.
 */
function evaluateRuleTree(h, k, l, node) {
    // Handle logical operators (AND/OR)
    if (node.logic) {
        if (node.logic === "AND") {
            return node.rules.every(rule => evaluateRuleTree(h, k, l, rule));
        } else if (node.logic === "OR") {
            return node.rules.some(rule => evaluateRuleTree(h, k, l, rule));
        }
    }

    // Handle individual rule types
    if (node.type === "family_check") {
        const inFamily = isInFamily(h, k, l, node.family);
        // The 'inverse' flag means the rule applies if the reflection is NOT in the family
        return node.inverse ? !inFamily : inFamily;
    }

    if (node.type === "expression_check") {
        const value = evaluateExpression(h, k, l, node.expression);
        // The condition is met if the expression result is an even multiple of the divisor
        return !isNaN(value) && value % node.divisor === 0;
    }

    if (node.type === "parity") {
        if (node.rule === "all_even") {
            return h % 2 === 0 && k % 2 === 0 && l % 2 === 0;
        } else if (node.rule === "all_odd") {
            return h % 2 !== 0 && k % 2 !== 0 && l % 2 !== 0;
        }
    }

    // If a node doesn't match any known type, it's considered a pass
    return true;
}

/**
 * Checks if a given hkl triplet belongs to a specific reflection family.
 * @returns {boolean} True if the hkl is in the family.
 */
function isInFamily(h, k, l, family) {
    switch (family) {
        case "h00": return k === 0 && l === 0;
        case "0k0": return h === 0 && l === 0;
        case "00l": return h === 0 && k === 0;
        case "h0l": return k === 0;
        case "hk0": return l === 0;
        case "0kl": return h === 0;
        case "hhl": return h === k;
        case "hkk": return k === l;
        case "hhh": return h === k && k === l;
        default:    return false;
    }
}

/**
 * Safely evaluates a predefined crystallographic expression.
 * @returns {number|NaN} The result of the expression, or NaN if unknown.
 */
function evaluateExpression(h, k, l, expr) {
    switch (expr.trim()) {
        case 'h+k':   return h + k;
        case 'k+l':   return k + l;
        case 'h+l':   return h + l;
        case 'h+k+l': return h + k + l;
        case '-h+k+l':return -h + k + l;
        case '2h+l':  return 2 * h + l;
        case 'h':     return h;
        case 'k':     return k;
        case 'l':     return l;
        default:      return NaN; // Return NaN for unknown expressions
    }
}


        // master HKL, 1.0.3 et ensuite
        // This function now uses the cache to get raw indices and then calculates positions.
function generateMasterHklList() {
    if (fullExperimentalData.tth.length === 0 || spaceGroups.length === 0) {
        masterHklList = [];
        updatePreviewPattern();
        return;
    }

    const selectedSgNumber = parseInt(controls.spaceGroupSelect.value, 10);
    const selectedSg = spaceGroups.find(sg => sg.number === selectedSgNumber);
    if (!selectedSg) {
        masterHklList = [];
        console.error("Cannot generate HKL list: selected space group not found.");
        updatePreviewPattern();
        return;
    }

    const maxTth = Math.max(...fullExperimentalData.tth) + 2.0;
    const params = getAllParams();

    // 1. Get raw HKL indices. This is the key step that uses the new caching function.
    const rawHklIndices = generateAndCacheHklIndices(selectedSg, maxTth, params);

    // 2. Create a deep copy to work with, so we don't modify the cached version.
    let workingHklList = JSON.parse(JSON.stringify(rawHklIndices));

    // 3. Calculate the 2-theta positions for the current parameters.
    updateHklPositions(workingHklList, params, selectedSg.system);

    // 4. Filter out peaks that are outside the range, sort them, and assign to the global list.
    masterHklList = workingHklList
        .filter(peak => peak.tth !== null && peak.tth <= maxTth)
        .sort((a, b) => a.tth - b.tth);

    // Add a default intensity property for preview purposes
    masterHklList.forEach(peak => {
        peak.intensity = peak.intensity || 0;
    });

    updatePreviewPattern();
}

        // v 108
function updateHklPositions(hklList, params, system) {
    const { a, b, c, alpha, beta, lambda } = params;
    if (!a || !lambda || a <= 0 || lambda <= 0) return;
    
    const deg2rad = Math.PI / 180;
    const lambda_sq_over_4 = (lambda * lambda) / 4.0;
    const a_sq = a * a;

    let b_sq, c_sq, sin_beta_sq, cos_beta;
    if (system === 'monoclinic') {
        const beta_rad = (beta || 90) * deg2rad;
        sin_beta_sq = Math.sin(beta_rad);
        sin_beta_sq *= sin_beta_sq;
        cos_beta = Math.cos(beta_rad);
        b_sq = (b || a) * (b || a);
        c_sq = (c || a) * (c || a);
    }

    hklList.forEach(peak => {
        if (!peak || peak.h_orig === undefined) return;
        const h = peak.h_orig;
        const k = peak.k_orig;
        const l = peak.l_orig;
        const h2 = h * h;
        const k2 = k * k;
        const l2 = l * l;
        
        let inv_d_sq = 0;
        switch(system) {
            case 'cubic': 
                inv_d_sq = (h2 + k2 + l2) / a_sq; 
                break;
            case 'tetragonal': 
                c_sq = (c || a) * (c || a);
                inv_d_sq = (h2 + k2) / a_sq + l2 / c_sq; 
                break;
            case 'orthorhombic': 
                b_sq = (b || a) * (b || a);
                c_sq = (c || a) * (c || a);
                inv_d_sq = h2/a_sq + k2/b_sq + l2/c_sq; 
                break;
            // --- THIS IS THE CRITICAL FIX ---
            // Added 'trigonal' to the case list to ensure the correct formula is used.
            case 'hexagonal': 
            case 'rhombohedral':
            case 'trigonal':
                c_sq = (c || a) * (c || a);
                inv_d_sq = 4 * (h2 + h*k + k2) / (3 * a_sq) + l2 / c_sq; 
                break;
            // --- END OF FIX ---
            case 'monoclinic':
                inv_d_sq = (1/sin_beta_sq) * (h2/a_sq + k2*sin_beta_sq/b_sq + l2/c_sq - (2*h*l*cos_beta)/(a*c));
                break;
        }
        
        if (inv_d_sq > 1e-12) {
            const sinThetaSq = lambda_sq_over_4 * inv_d_sq;
            if (sinThetaSq <= 1 && sinThetaSq > 0) {
                peak.tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI);
                peak.d = 1 / Math.sqrt(inv_d_sq);
            } else {
                peak.tth = null;
                peak.d = null;
            }
        } else {
            peak.tth = null;
            peak.d = null;
        }
    });
}


        function updateBackgroundForPreview() {
            if (fullExperimentalData.tth.length === 0 || isFitting) return;

            const params = getAllParams();
            calculatedBackground = calculateTotalBackground(fullExperimentalData.tth, params);

            if (mainChart) {
                // ---Save the current Y-axis zoom state ---
                const currentYMin = mainChart.scales.y.min;
                const currentYMax = mainChart.scales.y.max;

                const backgroundDataset = mainChart.data.datasets.find(d => d.label === 'Background');
                if (backgroundDataset) {
                    backgroundDataset.data = fullExperimentalData.tth.map((t, i) => ({ x: t, y: calculatedBackground[i] }));
                }
                
                updatePreviewPattern(); 
                
                // --Restore the Y-axis zoom state before updating ---
                mainChart.options.scales.y.min = currentYMin;
                mainChart.options.scales.y.max = currentYMax;
                
                mainChart.update('none');
            }
        }

        function getMultiplicityAndCanonicalHKL(h, k, l, laue_class) {
    if (h === 0 && k === 0 && l === 0) {
        return { multiplicity: 1, canonical_hkl_obj: [0, 0, 0] };
    }

    let m = 0;
    // This logic is now robust for all systems
    switch (laue_class) {
        case 'm-3m':
            if (h > k && k > l && l >= 0) m = 48;
            else if (h === k && k > l && l >= 0) m = 24;
            else if (h > k && k === l && l >= 0) m = 24;
            else if (h > l && k > l && h === k) m = 24;
            else if (h === k && k === l && l > 0) m = 8;
            else if (h > 0 && k === 0 && l === 0) m = 6;
            else if (h === k && l === 0 && h > 0) m = 12;
            else if (h > k && k > 0 && l === 0) m = 24;
            else m = 1;
            break;
        case 'm-3':
            if (h > k && k > l && l >= 0) m = 24;
            else if (h === k && k > l && l >= 0) m = 12;
            else if (h > k && k === l && l >= 0) m = 12;
            else if (h === k && k === l && l > 0) m = 8;
            else if (h > 0 && k === 0 && l === 0) m = 6;
            else if (h === k && l === 0 && h > 0) m = 6;
            else if (h > k && k > 0 && l === 0) m = 12;
            else m = 1;
            break;
        case '6/mmm':
            if (l > 0) {
                if (h > k && k >= 0) m = 24; else if (h === k && k > 0) m = 12; else if (h > 0 && k === 0) m = 12; else if (h === 0 && k === 0) m = 2;
            } else { // l=0
                if (h > k && k >= 0) m = 12; else if (h === k && k > 0) m = 6; else if (h > 0 && k === 0) m = 6;
            }
            break;
        case '6/m':
            if (l > 0) m = (h > 0 || k > 0) ? 12 : 2; else m = (h > 0 || k > 0) ? 6 : 1;
            break;
        case '-3m':
            if (l !== 0) {
                // Reflections with l > 0
                if (h === 0 && k === 0) {
                    m = 2; // 00l
                } else if (h === 0 || k === 0 || h === k) {
                    m = 12; // Special reflections like h0l, hhl
                } else {
                    m = 24; // General hkl
                }
            } else {
                // Reflections on the l = 0 plane (hk0)
                if (h === 0 || k === 0 || h === k) {
                    m = 6; // Special reflections like h00, hh0
                } else {
                    m = 12; // General hk0
                }
            }
            break;

        // --- CORRECTED -3 LAUE CLASS LOGIC ---
        case '-3':
            if (h === 0 && k === 0) {
                m = 2; // Special case for 00l reflections
            } else {
                m = 6; // All other reflections (general hkl and special hk0) have multiplicity 6
            }
            break;
        // --- END CORRECTION ---

        case '4/mmm':
            if (l > 0) {
                if (h > k && k >= 0) m = 16; else if (h === k && k > 0) m = 8; else if (h > 0 && k === 0) m = 8; else if (h === 0 && k === 0) m = 2;
            } else { // l=0
                if (h > k && k > 0) m = 8; else if (h === k && k > 0) m = 4; else if (h > 0 && k === 0) m = 4;
            }
            break;
        case '4/m':
             if (l > 0) m = (h > 0 || k > 0) ? 8 : 2; else m = (h > 0 || k > 0) ? 4 : 1;
            break;
        case 'mmm':
            if (h > 0 && k > 0 && l > 0) m = 8;
            else if (h > 0 && k > 0 && l === 0 || h > 0 && k === 0 && l > 0 || h === 0 && k > 0 && l > 0) m = 4;
            else if (h > 0 || k > 0 || l > 0) m = 2;
            break;
        case '2/m':
            if (k > 0 || (k === 0 && l > 0)) m = 4; else m = 2;
            break;
        case '-1':
            m = 2;
            break;
        default:
            m = 1;
            break;
    }
    return { multiplicity: m, canonical_hkl_obj: [h, k, l] };
}

    function calculatePeakShift(tth, params) { if (params.profileType === "4") { const thetaRad = tth * (Math.PI / 180) / 2; const cosTheta = Math.cos(thetaRad); const sin2Theta = Math.sin(2 * thetaRad); const displacementShift = -(params.shft / 1000) * cosTheta * (180 / Math.PI); const transparencyShift = params.trns * sin2Theta * (180 / Math.PI); return displacementShift + transparencyShift; } else { return 0; } }

    function calculateProfileWidths(tth, hkl, params) {
    const profileType = params.profileType || controls.profileSelect.value || "4";
    const thetaRad = tth * (Math.PI / 180) / 2;
    // Prevent division by zero or tan(Infinity) at 90 degrees
    if (Math.abs(thetaRad - Math.PI / 2.0) < 1e-6) {
        return { gamma_G: 0.1, gamma_L: 0.1 };
    }
    const tanTheta = Math.tan(thetaRad);
    const cosTheta = Math.cos(thetaRad);
    
    let gamma_G = 1e-3; // Default tiny width
    let gamma_L = 1e-3; // Default tiny width
    
    if (profileType === "4") {
        // --- Robust Simple pVoigt Calculation ---
        const gamma_G_sq = (params.GU || 0) * tanTheta * tanTheta + 
                          (params.GV || 0) * tanTheta + 
                          (params.GW || 0) + 
                          (params.GP || 0) / (cosTheta * cosTheta);

        // Check for invalid (negative or non-finite) width before sqrt
        if (gamma_G_sq > 0 && isFinite(gamma_G_sq)) {
            gamma_G = Math.sqrt(gamma_G_sq);
        }

        const calculated_L = (params.LX || 0) / cosTheta;
        if (calculated_L > 0 && isFinite(calculated_L)) {
            gamma_L = calculated_L;
        }

    } else {
        // --- TCH Profile Calculation (Profile 3) ---
        const gamma_G_sq = (params.U || 0) * tanTheta * tanTheta + 
                          (params.V || 0) * tanTheta + 
                          (params.W || 0);
        
        // Check for invalid width before sqrt
        if (gamma_G_sq > 0 && isFinite(gamma_G_sq)) {
            gamma_G = Math.sqrt(gamma_G_sq);
        }

        const calculated_L = (params.X || 0) * tanTheta + (params.Y || 0) / cosTheta;
        if (calculated_L > 0 && isFinite(calculated_L)) {
            gamma_L = calculated_L;
        }

        if (profileType === "3" && hkl && hkl.d) {
            const d_inv_sq = 1 / (hkl.d * hkl.d);
            const [h_val, k_val, l_val] = hkl.hkl_list[0].replace(/[()]/g, '').split(',').map(Number);
            const h2 = h_val * h_val, k2 = k_val * k_val, l2 = l_val * l_val;
            
            let H_aniso = (params.S400 || 0) * h2 * h2 + 
                          (params.S040 || 0) * k2 * k2 + 
                          (params.S004 || 0) * l2 * l2 + 
                          (params.S220 || 0) * h2 * k2 + 
                          (params.S202 || 0) * h2 * l2 + 
                          (params.S022 || 0) * k2 * l2;
            H_aniso *= d_inv_sq * d_inv_sq;
            
            // Only add anisotropic broadening if it's a valid number... ajouter dans la doc le facteur d'échelle, dans GSAS c'est aussi 1000
            if(isFinite(H_aniso)) {
                 gamma_L += Math.abs(H_aniso) / 1000;
            }
        }
    }
    
    // Final safeguard
    return { 
        gamma_G: Math.max(1e-4, gamma_G), 
        gamma_L: Math.max(1e-4, gamma_L) 
    };
}

// pour calculer les surfaces des pics, pour les rapports, erreur dans l'Anistropy avant la version 2.6
//Anisotropy calc was in slight error priot to 8 october
function getPseudoVoigtArea(gamma_G, gamma_L, params) {
            // Area of a Gaussian with FWHM = H is H * sqrt(pi / (4*ln(2)))
            const GAUSS_AREA_CONST = 1.0644677;
            // Area of a Lorentzian with FWHM = H is H * pi / 2
            const LORENTZ_AREA_CONST = 1.5707963;

            if (params.profileType === "4") {
                // For Simple pVoigt, the area is a simple mix of the two component areas
                const area_G = gamma_G * GAUSS_AREA_CONST;
                const area_L = gamma_L * LORENTZ_AREA_CONST;
                const currentEta = params.eta || 0.5;
                return currentEta * area_L + (1 - currentEta) * area_G;

            } else {
                // ------
                // For the TCH profile, the FWHM of the Gaussian and Lorentzian parts
                // are considered the same as the final convoluted FWHM for the area calculation.
                const fwhm = getPeakFWHM(gamma_G, gamma_L);
                
                // calculate the mixing parameter, eta, as done in the pseudoVoigt function.
                const ratio = gamma_L / fwhm;
                const eta_calc = 1.36603 * ratio - 0.47719 * (ratio * ratio) + 0.11116 * Math.pow(ratio, 3);
                const currentEta = Math.max(0, Math.min(1, eta_calc));

                // Now, calculate the area as a mix of a pure Gaussian and pure Lorentzian, both having the same FWHM.
                const area_G_combined = fwhm * GAUSS_AREA_CONST;
                const area_L_combined = fwhm * LORENTZ_AREA_CONST;
                
                return currentEta * area_L_combined + (1 - currentEta) * area_G_combined;
                // -----
            }
        }

        //  pseudoVoigt function with proper profile handling
function pseudoVoigt(x, x0, tth_peak, gamma_G, gamma_L, params) {
    // Handle degenerate cases where width is zero
    if (gamma_G <= 1e-9 && gamma_L <= 1e-9) {
        return Math.abs(x - x0) < 1e-6 ? 1e10 : 0.0;
    }

    // Apply asymmetry correction to the peak position difference
    const corrected_delta = applyAsymmetry(x, x0, tth_peak, params);

    // For Simple pVoigt (profile 4), changé le 4 oct

        if (params.profileType === "4") {
     
            const currentEta = params.eta || 0.5;
        const Cg = 4 * Math.log(2); // Constant: 2.7725887...

        // Use the individual, separate FWHMs for each shape.
        const H_G = Math.max(1e-9, gamma_G); // Gaussian FWHM
        const H_L = Math.max(1e-9, gamma_L); // Lorentzian FWHM

        const gaussianShape = Math.exp(-Cg * Math.pow(corrected_delta / H_G, 2));
        const lorentzianShape = 1 / (1 + 4 * Math.pow(corrected_delta / H_L, 2));

        // Return the linear combination of the two independent shapes.
        return currentEta * lorentzianShape + (1 - currentEta) * gaussianShape;


    }
    // For TCH profile (profile 3): Use proper TCH formulas
    else {
        // TCH formula for combining FWHM
        const fwhm_pow5 = Math.pow(gamma_G, 5) +
                          2.69269 * Math.pow(gamma_G, 4) * gamma_L +
                          2.42843 * Math.pow(gamma_G, 3) * Math.pow(gamma_L, 2) +
                          4.47163 * Math.pow(gamma_G, 2) * Math.pow(gamma_L, 3) +
                          0.07842 * gamma_G * Math.pow(gamma_L, 4) +
                          Math.pow(gamma_L, 5);
        const fwhm = Math.pow(fwhm_pow5, 0.2);
        
        if (fwhm <= 1e-9) {
            return Math.abs(corrected_delta) < 1e-6 ? 1e10 : 0.0;
        }

        // TCH formula for eta
        const ratio = gamma_L / fwhm;
        const eta_calc = 1.36603 * ratio - 0.47719 * (ratio * ratio) + 0.11116 * Math.pow(ratio, 3);
        const currentEta = Math.max(0, Math.min(1, eta_calc));
        
        // Calculate shapes using TCH combined FWHM
        const Cg = 4 * Math.log(2);
        const gaussianShape = Math.exp(-Cg * Math.pow(corrected_delta / fwhm, 2));
        const lorentzianShape = 1 / (1 + 4 * Math.pow(corrected_delta / fwhm, 2));
        
        return currentEta * lorentzianShape + (1 - currentEta) * gaussianShape;
    }
}



/**
 * Performs a Williamson-Hall analysis using the refined TCH profile parameters.
 * @param {object} params - The final refined parameters object (containing U, X, Y, lambda).
 * @param {Array<object>} hklList - The list of HKL reflections with their 2-theta positions.
 * @returns {object|null} An object with size, strain, and R-squared, or null if calculation fails.
 */
function calculateWilliamsonHall(params, hklList) {
    // This analysis is only valid for the TCH profile which separates size/strain contributions.
    if (params.profileType === "4" || params.U === undefined || params.X === undefined || params.Y === undefined) {
        return null;
    }

    const points = [];
    const deg2rad = Math.PI / 180;
    const workingTthMin = workingData.tth[0];
    const workingTthMax = workingData.tth[workingData.tth.length - 1];

    hklList.forEach(peak => {
        // Only include peaks within the currently fitted range for the analysis.
        if (!peak.tth || peak.tth < workingTthMin || peak.tth > workingTthMax) {
            return;
        }

        const theta_rad = peak.tth * deg2rad / 2.0;
        const cosTheta = Math.cos(theta_rad);
        const tanTheta = Math.tan(theta_rad);

        // Step 1: Calculate sample-only breadth components (in degrees) by ignoring instrumental V and W.
        const beta_G_sq = (params.U || 0) * tanTheta * tanTheta;
        const beta_G = beta_G_sq > 0 ? Math.sqrt(beta_G_sq) : 0;
        const beta_L = (params.X || 0) * tanTheta + (params.Y || 0) / cosTheta;
        
        // Step 2: Combine them using the TCH FWHM approximation to get the total sample breadth.
        const fwhm_g_5 = Math.pow(beta_G, 5);
        const fwhm_l_5 = Math.pow(beta_L, 5);
        const fwhm_g_4_l = 2.69269 * Math.pow(beta_G, 4) * beta_L;
        const fwhm_g_3_l_2 = 2.42843 * Math.pow(beta_G, 3) * Math.pow(beta_L, 2);
        const fwhm_g_2_l_3 = 4.47163 * Math.pow(beta_G, 2) * Math.pow(beta_L, 3);
        const fwhm_g_l_4 = 0.07842 * beta_G * Math.pow(beta_L, 4);
        const beta_sample_deg = Math.pow(fwhm_g_5 + fwhm_g_4_l + fwhm_g_3_l_2 + fwhm_g_2_l_3 + fwhm_g_l_4 + fwhm_l_5, 0.2);

        if (beta_sample_deg <= 1e-6) return; // Ignore zero-width peaks.

        // Step 3: Convert breadth to radians for the W-H equation.
        const beta_sample_rad = beta_sample_deg * deg2rad;

        // Step 4: Calculate the coordinates for the W-H plot.
        const x = Math.sin(theta_rad);          // x-axis is sin(theta)
        const y = beta_sample_rad * cosTheta;   // y-axis is beta * cos(theta)
        points.push({ x, y });
    });

    if (points.length < 2) return null; // Need at least 2 points for a linear fit.

    // Step 5: Perform a linear regression (y = mx + c) to find slope (m) and intercept (c).
    let sum_x = 0, sum_y = 0, sum_xy = 0, sum_x_sq = 0, sum_y_sq = 0;
    const n = points.length;
    points.forEach(p => {
        sum_x += p.x;
        sum_y += p.y;
        sum_xy += p.x * p.y;
        sum_x_sq += p.x * p.x;
        sum_y_sq += p.y * p.y;
    });

    const m_slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x_sq - sum_x * sum_x);
    const c_intercept = (sum_y - m_slope * sum_x) / n;

    // Calculate R-squared for goodness of fit.
    const ss_xx = sum_x_sq - (sum_x * sum_x) / n;
    const ss_yy = sum_y_sq - (sum_y * sum_y) / n;
    const ss_xy = sum_xy - (sum_x * sum_y) / n;
    const r_squared = (ss_xx === 0 || ss_yy === 0) ? 1 : Math.pow(ss_xy, 2) / (ss_xx * ss_yy);

    // Step 6: Extract physical parameters from the slope and intercept.
    const K_scherrer = 0.9; // Scherrer constant, typically 0.9.
    const lambda = params.lambda;

    // From intercept: c = K * lambda / L  => L = K * lambda / c
    const crystallite_size_A = (c_intercept > 1e-9) ? (K_scherrer * lambda) / c_intercept : Infinity;
    const crystallite_size_nm = crystallite_size_A / 10.0;

    // From slope: m = 4 * epsilon => epsilon = m / 4
    const microstrain = m_slope / 4.0;
    const microstrain_percent = microstrain * 100;

    return {
        size_nm: crystallite_size_nm,
        strain_percent: microstrain_percent,
        r_squared: r_squared
    };
}


    /**
 * Applies an asymmetry correction using raw, unscaled S/L and H/L parameters.
 * This version includes safeguards against numerical instability but expects
 * the user to input physically realistic (i.e., very small) parameter values.
 * @param {number} x - The current 2-theta point on the x-axis.
 * @param {number} x0 - The calculated center of the peak.
 * @param {number} tth_peak - The theoretical 2-theta position of the peak.
 * @param {object} params - The parameters object containing raw SL and HL.
 * @returns {number} The asymmetrically corrected distance from the peak center.
 */
function applyAsymmetry(x, x0, tth_peak, params) {
    // Return early if not using a profile that supports this asymmetry (TCH) or if params are zero.
    if (params.profileType === "4" || (!params.SL && !params.HL)) {
        return x - x0;
    }

    const delta_2theta = x - x0;
    if (Math.abs(delta_2theta) < 1e-9) {
        return 0;
    }

    // Safeguard: At very low 2-theta, cot(theta) approaches infinity.
    if (tth_peak < 0.1) {
        return delta_2theta;
    }

    const theta_rad = tth_peak * (Math.PI / 180) / 2.0;
    const cot_theta = 1.0 / Math.tan(theta_rad);

    // The raw S/L and H/L values from the input fields are used directly.
    const asymmetry_param = (params.SL || 0) * cot_theta + (params.HL || 0);
    const correction_term = asymmetry_param * Math.abs(delta_2theta);

    // Safeguard: The denominator is clamped to prevent it from becoming zero or negative,
    const MAX_CORRECTION = 0.95; 
    const asymmetry_factor = 1.0 - Math.min(correction_term, MAX_CORRECTION);
    
    return delta_2theta / asymmetry_factor;
}


        function calculatePattern(tthAxis, hklList, params) {

           const n_points = tthAxis.length;
            const pattern = new Float64Array(n_points);
            const deg2rad = Math.PI / 180;

            // --- Calculate K-alpha 1 pattern ---
            hklList.forEach(peak => {
                if (!peak.intensity || peak.intensity <= 0 || !peak.tth) return;

                const basePos1 = peak.tth + params.zeroShift;
                const shift1 = calculatePeakShift(basePos1, params);
                const peakPos1 = basePos1 + shift1;
                const { gamma_G, gamma_L } = calculateProfileWidths(basePos1, peak, params);
                const shapeArea1 = getPseudoVoigtArea(gamma_G, gamma_L, params);

                // Use a window to find all points that might be above the cutoff
                const window = CALCULATION_WINDOW_MULTIPLIER * Math.max(0.01, gamma_G + gamma_L);
                const min_tth = peakPos1 - window;
                const max_tth = peakPos1 + window;

                let startIndex = 0;
                while(startIndex < n_points && tthAxis[startIndex] < min_tth) startIndex++;

                for (let i = startIndex; i < n_points; i++) {
                    const current_tth = tthAxis[i];
                    if (current_tth > max_tth) break;

                    const intensityAtPoint = pseudoVoigt(current_tth, peakPos1, basePos1, gamma_G, gamma_L, params);

                    // Only include points where the peak height is above the cutoff threshold ***
                    if (intensityAtPoint > PEAK_HEIGHT_CUTOFF) {
                        if (shapeArea1 > 1e-9) {
                            pattern[i] += peak.intensity * (intensityAtPoint / shapeArea1);
                        }
                    }
                }
            });

            // --- Calculate and Add K-alpha 2 pattern ---
            const doubletEnabled = params.ratio > 0 && params.lambda2 > 0 && Math.abs(params.lambda - params.lambda2) > 1e-6;
            if (doubletEnabled) {
                const lambdaRatio = params.lambda2 / params.lambda;
                hklList.forEach(peak => {
                    if (!peak.intensity || peak.intensity <= 0 || !peak.tth) return;

                    const sinTheta1 = Math.sin(peak.tth * deg2rad / 2.0);
                    if (Math.abs(sinTheta1 * lambdaRatio) >= 1) return;
                    
                    const tth2 = 2 * Math.asin(sinTheta1 * lambdaRatio) / deg2rad;
                    const basePos2 = tth2 + params.zeroShift;
                    const shift2 = calculatePeakShift(basePos2, params);
                    const peakPos2 = basePos2 + shift2;
                    const { gamma_G: gamma_G2, gamma_L: gamma_L2 } = calculateProfileWidths(basePos2, peak, params);
                    const shapeArea2 = getPseudoVoigtArea(gamma_G2, gamma_L2, params);

                    const window2 = CALCULATION_WINDOW_MULTIPLIER * Math.max(0.01, gamma_G2 + gamma_L2);
                    const min_tth2 = peakPos2 - window2;
                    const max_tth2 = peakPos2 + window2;

                    let startIndex2 = 0;
                    while(startIndex2 < n_points && tthAxis[startIndex2] < min_tth2) startIndex2++;

                    for (let i = startIndex2; i < n_points; i++) {
                        const current_tth = tthAxis[i];
                        if (current_tth > max_tth2) break;

                        const intensityAtPoint = pseudoVoigt(current_tth, peakPos2, basePos2, gamma_G2, gamma_L2, params);
                        
                        // Apply the same height cutoff logic for the K-alpha 2 peak ***
                        if (intensityAtPoint > PEAK_HEIGHT_CUTOFF) {
                            if (shapeArea2 > 1e-9) {
                                pattern[i] += peak.intensity * params.ratio * (intensityAtPoint / shapeArea2);
                            }
                        }
                    }
                });
            }
            return pattern;
        }

        function redrawFitForNewRange() {
            if (!mainChart) return; 

            const currentYMin = mainChart.scales.y.min;
            const currentYMax = mainChart.scales.y.max;

            updateWorkingData();

            if (!fitResults) {
                updatePreviewPattern();
            } else {
                const params = fitResults.params;
                const scaleFactor = fitResults.stats.scaleFactor;
                
                const background_sliced = calculateTotalBackground(workingData.tth, params);
                const unscaledPeakPattern_sliced = calculatePattern(workingData.tth, fitResults.hklList, params);
                
                const totalCalcPattern = new Float64Array(unscaledPeakPattern_sliced.length);
                for(let i = 0; i < totalCalcPattern.length; i++) {
                    totalCalcPattern[i] = (unscaledPeakPattern_sliced[i] * scaleFactor) + background_sliced[i];
                }
                
                // ✅ CORRECTED: Use a for loop instead of .map()
                const diff = [];
                for (let i = 0; i < workingData.intensity.length; i++) {
                    diff.push(workingData.intensity[i] - totalCalcPattern[i]);
                }
                workingData.lastRawDifference = diff;
                
                const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
                
                // ✅ CORRECTED: Use a for loop to build chart data arrays
                const calculatedData = [];
                const backgroundData = [];
                for(let i = 0; i < workingData.tth.length; i++) {
                    calculatedData.push({ x: workingData.tth[i], y: totalCalcPattern[i] });
                    backgroundData.push({ x: workingData.tth[i], y: background_sliced[i] });
                }

                findDataset('Calculated').data = calculatedData;
                findDataset('Background').data = backgroundData;
                findDataset('Simulation (Manual)').data = [];
            }
            
            rescalePlot(false);
            
            mainChart.options.scales.x.min = parseFloat(controls.tthMinSlider.value);
            mainChart.options.scales.x.max = parseFloat(controls.tthMaxSlider.value);
            mainChart.options.scales.y.min = currentYMin;
            mainChart.options.scales.y.max = currentYMax;
            
            mainChart.update('none');
        }

// pour pas commencer avec un bruit de fond débile
function estimateBackgroundParameters(tth, intensity) {
    if (tth.length < 100) return null; // Not enough data for a reliable estimate

    // --- 1. Identify background points by finding the minimum in chunks ---
    const backgroundPoints = [];
    // Divide the pattern into roughly 50 chunks to find local minima
    const chunkSize = Math.max(50, Math.floor(tth.length / 50)); 
    for (let i = 0; i < tth.length; i += chunkSize) {
        const chunkIntensity = intensity.slice(i, i + chunkSize);
        const chunkTth = tth.slice(i, i + chunkSize);
        if (chunkIntensity.length === 0) continue;

        let minVal = Infinity;
        let minIndex = -1;
        for (let j = 0; j < chunkIntensity.length; j++) {
            if (chunkIntensity[j] < minVal) {
                minVal = chunkIntensity[j];
                minIndex = j;
            }
        }
        if (minIndex !== -1) {
            backgroundPoints.push({ x: chunkTth[minIndex], y: minVal });
        }
    }

    if (backgroundPoints.length < NUM_BACKGROUND_PARAMS+1) return null; // Need N+1 points for N-degree polynomial

    // --- 2. Perform a 5-term Chebyshev polynomial fit on these points ---
    const N = NUM_BACKGROUND_PARAMS; // Fit B0 to...
    const M = backgroundPoints.length;
    const tthMin = tth[0];
    const tthMax = tth[tth.length - 1];
    const tthRange = tthMax - tthMin;
    if (tthRange <= 0) return null;

    const A = []; // Matrix for normal equations
    const b = []; // Vector for normal equations

    backgroundPoints.forEach(point => {
        const x_prime = (2 * (point.x - tthMin) / tthRange) - 1;
        const row = [];
        let T_prev = 1;       // T0
        let T_curr = x_prime; // T1
        row.push(T_prev);
        if (N > 1) row.push(T_curr);

        for (let n = 2; n < N; n++) {
            const T_next = 2 * x_prime * T_curr - T_prev;
            row.push(T_next);
            T_prev = T_curr;
            T_curr = T_next;
        }
        A.push(row);
        b.push(point.y);
    });

    try {
        const At = transpose(A);
        const AtA = multiply(At, A);
        const Atb = multiply(At, b);
        const coeffs = solve(AtA, Atb);

        if (coeffs && coeffs.length === N) {
            const bgParams = {};
            coeffs.forEach((c, i) => bgParams[`B${i}`] = c);
            return bgParams;
        }
    } catch (error) {
        console.error("Background estimation fit failed:", error);
        return null;
    }

    return null;
}


// runFit function 
    function runFit(refinementMode) {
    if (isFitting) return;
    isFitting = true;
    setUIState(true);
    updateWorkingData();

    if (masterHklList.length === 0) {
        alert("Could not find a list of reflections. Please select a space group first. Aborting fit.");
        isFitting = false; setUIState(false); return;
    }

    fitResults = null;
    let currentParams = getAllParams();
    const fitFlags = getFitFlags();
    const selectedSgNumber = parseInt(controls.spaceGroupSelect.value, 10);
    const selectedSg = spaceGroups.find(sg => sg.number === selectedSgNumber);
    if (!selectedSg) { alert("Error: Could not find selected space group data."); isFitting = false; setUIState(false); return; }
    
    const system = selectedSg.system;
    const maxIterations = parseInt(controls.iterationsSlider.value);
    const algorithm = controls.algorithmSelect.value;

    if (!workingData.isValid || workingData.tth.length === 0) {
        alert("No data in the selected 2-theta range. Aborting fit.");
        isFitting = false; setUIState(false); return;
    }

    let currentHklList = JSON.parse(JSON.stringify(masterHklList));
    currentHklList.forEach(p => { if(p.tth) p.intensity = 1000.0; });
    
    (async () => {
        let finalResults;

        // --- Le Bail Refinement Path ---
        if (refinementMode === 'le-bail') {
            const LE_BAIL_CYCLES = 4;
            for (let cycle = 0; cycle < LE_BAIL_CYCLES; cycle++) {
                controls.progressBar.style.width = `${((cycle + 1) / LE_BAIL_CYCLES) * 100}%`;
                await new Promise(resolve => setTimeout(resolve, 0));

                let refinementResults;
                if (algorithm === 'lm') {
                    refinementResults = await refineParametersLM(currentParams, fitFlags, maxIterations, currentHklList, system, null, refinementMode);
                } else if (algorithm === 'sa') {
                    refinementResults = await refineParametersSA(currentParams, fitFlags, maxIterations, currentHklList, system, null, refinementMode);
                } else { // Parallel Tempering
                    refinementResults = await refineParametersPT(currentParams, fitFlags, maxIterations, currentHklList, system, null, refinementMode);
                }
                
                if (refinementResults && refinementResults.params && refinementResults.hklList) {
                    currentParams = refinementResults.params;
                    currentHklList = refinementResults.hklList;
                    finalResults = refinementResults;
                }

                const updatedBackground = calculateTotalBackground(workingData.tth, currentParams);
                leBailIntensityExtraction({ tth: workingData.tth, intensity: workingData.intensity, background: updatedBackground }, currentHklList, currentParams);
            }
        } 
        // --- Pawley Refinement Path ---
        else { 
            const initialBackground = calculateTotalBackground(workingData.tth, currentParams);
            leBailIntensityExtraction({ 
                tth: workingData.tth, 
                intensity: workingData.intensity, 
                background: initialBackground 
            }, currentHklList, currentParams);

            const pawleyProgress = async (progress) => {
                controls.progressBar.style.width = `${progress * 100}%`;
                await new Promise(resolve => setTimeout(resolve, 0));
            };

            if (algorithm === 'lm') {
                finalResults = await refineParametersLM(currentParams, fitFlags, maxIterations, currentHklList, system, pawleyProgress, refinementMode);
            } else if (algorithm === 'sa') {
                finalResults = await refineParametersSA(currentParams, fitFlags, maxIterations, currentHklList, system, pawleyProgress, refinementMode);
            } else { // Parallel Tempering
                finalResults = await refineParametersPT(currentParams, fitFlags, maxIterations, currentHklList, system, pawleyProgress, refinementMode);
            }
            
            if (finalResults && finalResults.params && finalResults.hklList) {
                currentParams = finalResults.params;
                currentHklList = finalResults.hklList;
            }
        }
        
        if (!currentParams || !currentHklList) {
            showToast("Refinement failed to produce valid results. Aborting.", "error");
            isFitting = false;
            setUIState(false);
            return; 
        }

        const finalNetPatternForStats = calculatePattern(workingData.tth, currentHklList, currentParams);
        const finalBackgroundForStats = calculateTotalBackground(workingData.tth, currentParams);
        const finalStats = calculateStatistics(workingData, finalNetPatternForStats, fitFlags, finalBackgroundForStats, currentParams, currentHklList, refinementMode);
        
        fitResults = {
            params: currentParams,
            hklList: currentHklList,
            stats: finalStats,
            algorithm: algorithm,
            refinementMode: refinementMode, // The critical fix is here
            fitFlags: fitFlags,
            paramMapping: finalResults ? finalResults.paramMapping : [],
            JtJ: finalResults ? finalResults.JtJ : null,
            ss_res: finalResults ? finalResults.ss_res : null
        };

        lastFitResultsCache = JSON.parse(JSON.stringify(fitResults));
        updateUI(fitResults.params, fitResults.stats, finalNetPatternForStats, finalBackgroundForStats, fitResults.stats.scaleFactor, fitResults.hklList);

        isFitting = false;
        setUIState(false);
    })();
}



        function leBailIntensityExtraction(expData, hklList, params) {
    if (expData.tth.length !== expData.background.length || expData.tth.length !== expData.intensity.length) {
        console.error("CRITICAL ERROR in leBailIntensityExtraction: Mismatched array lengths!");
        return;
    }

    const deg2rad = Math.PI / 180;
    const doubletEnabled = params.ratio > 0 && params.lambda2 > 0 && Math.abs(params.lambda - params.lambda2) > 1e-6;
    const lambdaRatio = doubletEnabled ? params.lambda2 / params.lambda : 1.0;

    // Reset intensities for the new extraction cycle, 8 c'est trop ?
    hklList.forEach(p => p.intensity = 0);

    for (let i = 0; i < expData.tth.length; i++) {
        let totalProfileAtPoint = 0;
        const contributingPeaks = [];

        // Find all K-alpha 1 peaks that contribute
        hklList.forEach((peak, peakIdx) => {
            const basePos = peak.tth + params.zeroShift;
            const shift = calculatePeakShift(basePos, params);
            const peakPos = basePos + shift;
            const { gamma_G, gamma_L } = calculateProfileWidths(basePos, peak, params);
            const window = 20 * Math.max(0.01, gamma_G, gamma_L);

            if (Math.abs(expData.tth[i] - peakPos) < window) {
                const profileVal = pseudoVoigt(expData.tth[i], peakPos, basePos, gamma_G, gamma_L, params);
                totalProfileAtPoint += profileVal;
                contributingPeaks.push({ idx: peakIdx, val: profileVal });
            }
        });

        // Find all K-alpha 2 peaks that contribute (if doublet is enabled)
        if (doubletEnabled) {
            hklList.forEach((peak, peakIdx) => {
                if (!peak.tth) return;

                const sinTheta1 = Math.sin(peak.tth * deg2rad / 2.0);
                if (Math.abs(sinTheta1) > 1) return;

                const sinTheta2 = sinTheta1 * lambdaRatio;
                if (Math.abs(sinTheta2) >= 1) return;

                const tth2 = 2 * Math.asin(sinTheta2) / deg2rad;
                const basePos2 = tth2 + params.zeroShift;
                const shift2 = calculatePeakShift(basePos2, params);
                const peakPos2 = basePos2 + shift2;
                const { gamma_G: gamma_G2, gamma_L: gamma_L2 } = calculateProfileWidths(basePos2, peak, params);
                const window = 8 * Math.max(0.01, gamma_G2, gamma_L2);

                if (Math.abs(expData.tth[i] - peakPos2) < window) {
                    const profileVal = pseudoVoigt(expData.tth[i], peakPos2, basePos2, gamma_G2, gamma_L2, params);
                    const weightedProfileVal = profileVal * params.ratio;
                    totalProfileAtPoint += weightedProfileVal;
                    // Add this as a separate contribution from the same peak
                    contributingPeaks.push({ idx: peakIdx, val: weightedProfileVal });
                }
            });
        }

        if (totalProfileAtPoint > 1e-9 && contributingPeaks.length > 0) {
            const obsIntensityNet = expData.intensity[i] - (expData.background[i] || 0);

            if (obsIntensityNet > 0) {
                contributingPeaks.forEach(p => {
                    hklList[p.idx].intensity += obsIntensityNet * (p.val / totalProfileAtPoint);
                });
            }
        }
    }

    // Ensure all final intensities are non-negative
    hklList.forEach(p => {
        if (p.intensity < 0) {
            p.intensity = 0;
        }
    });

        let DAMPING_FACTOR=0.3;
    hklList.forEach(p => {
        // Store previous intensity if it doesn't exist
        
        if (p.intensity_previous === undefined) {
            p.intensity_previous = p.intensity;
        } else {
            // Apply damping: mix old and new intensities
            const newIntensity = p.intensity;
            p.intensity = (1.0 - DAMPING_FACTOR) * newIntensity + DAMPING_FACTOR * p.intensity_previous;
            // Update the stored previous value
            p.intensity_previous = newIntensity;
        }
    });

}

// calculateStatistics function
function calculateStatistics(workingData, netCalcPattern, fitFlags, finalBackground, params, hklList, refinementMode) {
    const y_obs = workingData.intensity;
    const y_bkg = finalBackground;
    const weights = workingData.weights;
    const N = y_obs.length;

    if (N === 0 || y_obs.length !== netCalcPattern.length || y_obs.length !== y_bkg.length) {
        console.error("Statistics calculation error: Mismatched array lengths.");
        return { r_p: -1, rwp: -1, chi2: -1, scaleFactor: 1, sum_w_res_sq: 0 };
    }

    let scaleFactor = 1.0;
    if (refinementMode === 'le-bail') {
        let sum_w_y_net_y_calc = 0;
        let sum_w_y_calc_sq = 0;
        for (let i = 0; i < N; i++) {
            const y_obs_net = y_obs[i] - y_bkg[i];
            sum_w_y_net_y_calc += weights[i] * y_obs_net * netCalcPattern[i];
            sum_w_y_calc_sq += weights[i] * netCalcPattern[i] * netCalcPattern[i];
        }
        scaleFactor = (sum_w_y_calc_sq > 1e-9) ? sum_w_y_net_y_calc / sum_w_y_calc_sq : 1.0;
    }
    
    // ✅ CORRECTED: Use a for loop instead of .map()
    const y_calc = new Float64Array(netCalcPattern.length);
    for(let i = 0; i < netCalcPattern.length; i++) {
        y_calc[i] = (scaleFactor * netCalcPattern[i]) + y_bkg[i];
    }

    let sum_w_res_sq = 0, sum_w_obs_sq = 0, sum_abs_res = 0, sum_abs_obs = 0;
    for (let i = 0; i < N; i++) {
        const res = y_obs[i] - y_calc[i];
        sum_w_res_sq += weights[i] * res * res;
        sum_w_obs_sq += weights[i] * y_obs[i] * y_obs[i];
        sum_abs_res += Math.abs(res);
        sum_abs_obs += Math.abs(y_obs[i]);
    }

    const Rp = 100 * (sum_abs_res / sum_abs_obs);
    const Rwp = 100 * Math.sqrt(sum_w_res_sq / sum_w_obs_sq);

    const P_base = getParameterMapping(fitFlags, params, hklList, 'le-bail').paramMapping.length;
    let P = P_base;
    if (refinementMode === 'pawley') {
        const refinedIntensitiesCount = hklList.filter(hkl => hkl.tth >= workingData.tth[0] && hkl.tth <= workingData.tth[workingData.tth.length - 1]).length;
        P += refinedIntensitiesCount;
    }
    
    const Rexp_denominator = sum_w_obs_sq;
    if (N <= P || Rexp_denominator <= 0) {
         return { r_p: Rp, rwp: Rwp, chi2: 0, scaleFactor, sum_w_res_sq };
    }

    const Rexp = 100 * Math.sqrt((N - P) / Rexp_denominator);
    const GOF = (Rexp > 1e-6) ? Math.pow(Rwp / Rexp, 2) : 0;

    return { r_p: Rp, rwp: Rwp, chi2: GOF, scaleFactor, sum_w_res_sq };
}


/**
 * Refines parameters using the Parallel Tempering (PT) algorithm.
 * PT runs multiple replicas of the system at different temperatures and allows them to swap states,
 * which helps overcome energy barriers and find the global minimum more effectively.
 *
 * @param {object} initialParams - The starting parameters for the refinement.
 * @param {object} fitFlags - A boolean map indicating which parameters to refine.
 * @param {number} maxIter - The total number of iterations to run.
 * @param {Array<object>} hklList - The list of HKL reflections.
 * @param {string} system - The crystal system (e.g., 'cubic').
 * @param {Function} progressCallback - A function to call with progress (0.0 to 1.0).
 * @param {string} refinementMode - The refinement mode ('le-bail' or 'pawley').
 * @returns {Promise<object>} A promise that resolves with the final refinement results.
 */
async function refineParametersPT(initialParams, fitFlags, maxIter, hklList, system, progressCallback, refinementMode) {
    const { paramMapping } = getParameterMapping(fitFlags, initialParams, hklList, refinementMode);
    if (paramMapping.length === 0) {
        return { params: initialParams, hklList: hklList, ss_res: 0 };
    }

    // --- PT Configuration ---
    const numReplicas = 8; // Number of parallel chains. 8 is a good starting point.
    const maxTemp = 1.0; // Temperature of the "hottest" replica.
    const minTemp = 1e-5; // Temperature of the "coldest" replica.
    const swapInterval = 10; // Attempt swaps every N iterations.

    // --- Objective function to calculate the cost (sum of weighted squared residuals) ---
    const objective = (p_obj, hkl_list_obj) => {
        try {
            updateHklPositions(hkl_list_obj, p_obj, system);
            const netCalcPattern = calculatePattern(workingData.tth, hkl_list_obj, p_obj);
            const y_bkg = calculateTotalBackground(workingData.tth, p_obj);
            
            let num = 0, den = 0;
            for (let i = 0; i < workingData.tth.length; i++) {
                const y_obs_net = workingData.intensity[i] - y_bkg[i];
                num += workingData.weights[i] * y_obs_net * netCalcPattern[i];
                den += workingData.weights[i] * netCalcPattern[i] * netCalcPattern[i];
            }
            const scaleFactor = (den > 1e-9) ? num / den : 1.0;
            
            const y_calc_total = netCalcPattern.map((y, i) => (scaleFactor * y) + y_bkg[i]);
            let sum_w_res_sq = 0;
            for (let i = 0; i < workingData.tth.length; i++) {
                sum_w_res_sq += workingData.weights[i] * Math.pow(workingData.intensity[i] - y_calc_total[i], 2);
            }
            return isFinite(sum_w_res_sq) ? sum_w_res_sq : 1e12; // Return a large number on error
        } catch (err) {
            return 1e12;
        }
    };

    // --- Initialization ---
    // 1. Create the geometric temperature ladder
    const temperatures = Array.from({ length: numReplicas }, (_, i) => 
        maxTemp * Math.pow(minTemp / maxTemp, i / (numReplicas - 1))
    );

    // 2. Initialize all replicas with the same starting state
    const initialCost = objective(initialParams, hklList);
    let replicas = temperatures.map(temp => ({
        params: JSON.parse(JSON.stringify(initialParams)),
        hklList: JSON.parse(JSON.stringify(hklList)),
        cost: initialCost,
        temp: temp
    }));

    // 3. Keep track of the best solution found across all replicas
    let bestOverallParams = JSON.parse(JSON.stringify(initialParams));
    let bestOverallHklList = JSON.parse(JSON.stringify(hklList));
    let bestOverallCost = initialCost;

    // --- Main PT Loop ---
    for (let iter = 0; iter < maxIter; iter++) {
        // --- Part 1: Standard Monte Carlo step for each replica ---
        for (let i = 0; i < numReplicas; i++) {
            let replica = replicas[i];
            const originalParams = JSON.parse(JSON.stringify(replica.params));
            const originalHklList = JSON.parse(JSON.stringify(replica.hklList));

            // Perturb a random parameter
            const p_idx = Math.floor(Math.random() * paramMapping.length);
            const mapping = paramMapping[p_idx];
            const original_val = mapping.get(replica.params, replica.hklList);
            // The step size scales with the replica's temperature
            const step_size = (mapping.step || 0.3) * Math.max(0.05, replica.temp);
            const new_val = original_val + (Math.random() - 0.5) * 2 * step_size;
            mapping.set(replica.params, replica.hklList, new_val);
            
            // Calculate new cost and decide whether to accept
            const neighbor_cost = objective(replica.params, replica.hklList);
            const delta_cost = neighbor_cost - replica.cost;
            
            if (delta_cost < 0 || Math.exp(-delta_cost / (replica.cost * replica.temp)) > Math.random()) {
                replica.cost = neighbor_cost; // Accept the move
            } else {
                replica.params = originalParams; // Reject, revert
                replica.hklList = originalHklList;
            }

            // Update the global best solution if this replica found a new minimum
            if (replica.cost < bestOverallCost) {
                bestOverallCost = replica.cost;
                bestOverallParams = JSON.parse(JSON.stringify(replica.params));
                bestOverallHklList = JSON.parse(JSON.stringify(replica.hklList));
            }
        }

        // --- Part 2: Attempt to swap states between adjacent replicas ---
        if (iter > 0 && iter % swapInterval === 0) {
            for (let i = 0; i < numReplicas - 1; i++) {
                const rep1 = replicas[i];
                const rep2 = replicas[i + 1];

                // Metropolis criterion for swapping replicas
                // P_swap = exp( (cost_1 - cost_2) * (1/T_1 - 1/T_2) )
                const delta_beta = (1 / rep1.temp) - (1 / rep2.temp);
                const delta_cost = rep1.cost - rep2.cost;
                const acceptance_prob = Math.exp(delta_beta * delta_cost);

                if (acceptance_prob > Math.random()) {
                    // Swap the states (params, hkl, cost), but NOT the temperatures
                    [rep1.params, rep2.params] = [rep2.params, rep1.params];
                    [rep1.hklList, rep2.hklList] = [rep2.hklList, rep1.hklList];
                    [rep1.cost, rep2.cost] = [rep2.cost, rep1.cost];
                }
            }
        }
        
        if (progressCallback) await progressCallback((iter + 1) / maxIter);
    }
    
    // --- Finalization ---
    // The best result is the one stored in bestOverallParams, which corresponds to the lowest cost found at any temperature.
    // Calculate final scale factor and apply it to the HKL intensities of the best solution
    updateHklPositions(bestOverallHklList, bestOverallParams, system);
    const netCalcPattern = calculatePattern(workingData.tth, bestOverallHklList, bestOverallParams);
    const y_bkg = calculateTotalBackground(workingData.tth, bestOverallParams);
    let num = 0, den = 0;
    for (let i = 0; i < workingData.tth.length; i++) {
        const y_obs_net = workingData.intensity[i] - y_bkg[i];
        num += workingData.weights[i] * y_obs_net * netCalcPattern[i];
        den += workingData.weights[i] * netCalcPattern[i] * netCalcPattern[i];
    }
    const bestScaleFactor = (den > 1e-9) ? num / den : 1.0;
    
    // Apply the final scale factor to the intensities of the returned list
    bestOverallHklList.forEach(hkl => {
        hkl.intensity *= bestScaleFactor;
    });

    return {
        params: bestOverallParams,
        hklList: bestOverallHklList,
        algorithm: 'pt',
        paramMapping,
        fitFlags,
        ss_res: bestOverallCost
    };
}



// 
async function refineParametersLM(initialParams, fitFlags, maxIter, hklList, system, progressCallback, refinementMode) {
        const { paramMapping } = getParameterMapping(fitFlags, initialParams, hklList, refinementMode);
        if (paramMapping.length === 0) {
            return { params: initialParams, hklList: hklList, ss_res: 0 };
        }

        let params = initialParams;
        let workingHklList = hklList;
        
        let finalJtJ, ss_res = Infinity;
        let lambda = 0.001;
        
        const y_obs = workingData.intensity;
        
        // ✅ CORRECTED: Use a for loop instead of .map()
        const sqrt_weights = new Float64Array(workingData.weights.length);
        for (let i = 0; i < workingData.weights.length; i++) {
            sqrt_weights[i] = Math.sqrt(workingData.weights[i]);
        }

        const n_points = y_obs.length;
        const n_params = paramMapping.length;

        // Pre-allocate typed arrays for performance
        const residuals = new Float64Array(n_points);
        const y_calc_total = new Float64Array(n_points);
        const y_calc_baseline = new Float64Array(n_points);
        const jacobian_col = new Float64Array(n_points);
        
        // Calculate total pattern (includes scale factor calculation for Le Bail)
        const calculateTotalPattern = (targetArray) => {
            updateHklPositions(workingHklList, params, system);
            const y_bkg = calculateTotalBackground(workingData.tth, params);
            const netCalcPattern = calculatePattern(workingData.tth, workingHklList, params);
            
            let scaleFactor = 1.0;
            if (refinementMode === 'le-bail') {
                let num = 0, den = 0;
                for (let i = 0; i < n_points; i++) {
                    const y_obs_net = y_obs[i] - y_bkg[i];
                    num += workingData.weights[i] * y_obs_net * netCalcPattern[i];
                    den += workingData.weights[i] * netCalcPattern[i] * netCalcPattern[i];
                }
                scaleFactor = (den > 1e-9) ? num / den : 1.0;
            }
            
            for (let i = 0; i < n_points; i++) {
                targetArray[i] = (scaleFactor * netCalcPattern[i]) + y_bkg[i];
            }
            return scaleFactor;
        };

        for (let iter = 0; iter < maxIter; iter++) {
            // Calculate baseline pattern
            calculateTotalPattern(y_calc_baseline);
            
            // Calculate residuals and cost
            let cost = 0;
            for (let i = 0; i < n_points; i++) {
                residuals[i] = (y_obs[i] - y_calc_baseline[i]) * sqrt_weights[i];
                cost += residuals[i] * residuals[i];
            }

            // Check convergence
            if (iter > 0 && Math.abs(ss_res - cost) < 1e-9 * ss_res) {
                break;
            }
            ss_res = cost;

            // Calculate Jacobian using finite differences
            const jacobian_T = []; // Store as columns (transposed)
            
            for (let p = 0; p < n_params; p++) {
                const mapping = paramMapping[p];
                const originalValue = mapping.get(params, workingHklList);
                const fd_step = mapping.fd_step || 1e-5;
                
                // Perturb parameter
                mapping.set(params, workingHklList, originalValue + fd_step);
                
                // Recalculate pattern
                calculateTotalPattern(y_calc_total);
                
                // Calculate derivative column: dy_calc/dp (weighted)
                for (let i = 0; i < n_points; i++) {
                    jacobian_col[i] = (y_calc_total[i] - y_calc_baseline[i]) / fd_step * sqrt_weights[i];
                }
                
                // Restore original value
                mapping.set(params, workingHklList, originalValue);
                
                // Store column (make a copy)
                jacobian_T.push([...jacobian_col]);
            }

            // Calculate JtJ and Jtr efficiently
            const JtJ = new Array(n_params);
            const Jtr = new Array(n_params);
            
            for (let i = 0; i < n_params; i++) {
                JtJ[i] = new Array(n_params);
                let jtr_val = 0;
                
                // Jtr = J^T * residuals
                for (let k = 0; k < n_points; k++) {
                    jtr_val += jacobian_T[i][k] * residuals[k];
                }
                Jtr[i] = jtr_val;
                
                // JtJ = J^T * J
                for (let j = 0; j < n_params; j++) {
                    let sum = 0;
                    for (let k = 0; k < n_points; k++) {
                        sum += jacobian_T[i][k] * jacobian_T[j][k];
                    }
                    JtJ[i][j] = sum;
                }
            }
            
            finalJtJ = JtJ;

            // Apply Levenberg-Marquardt damping
            const A_lm = new Array(n_params);
            for (let i = 0; i < n_params; i++) {
                A_lm[i] = [...JtJ[i]];
                A_lm[i][i] *= (1.0 + lambda);
            }

            // Solve for parameter step: (JtJ + λI) * Δp = Jtr
            const p_step = solve(A_lm, Jtr);
            
            if (p_step.some(v => !isFinite(v))) {
                break;
            }

            // Apply step to get new parameters
            const p_current = paramMapping.map(m => m.get(params, workingHklList));
            const p_new = p_current.map((val, i) => val + p_step[i]);
            
            // Store current state (only copy when needed)
            const oldParams = JSON.parse(JSON.stringify(params));
            const oldHklList = JSON.parse(JSON.stringify(workingHklList));
            
            // Set new parameters
            paramMapping.forEach((m, i) => m.set(params, workingHklList, p_new[i]));
            
            // Calculate new cost
            calculateTotalPattern(y_calc_total);
            let new_cost = 0;
            for (let i = 0; i < n_points; i++) {
                const res = (y_obs[i] - y_calc_total[i]) * sqrt_weights[i];
                new_cost += res * res;
            }

            // Accept or reject step
            if (new_cost < cost && isFinite(new_cost)) {
                lambda = Math.max(1e-9, lambda / 2);
            } else {
                // Restore old state
                params = oldParams;
                workingHklList = oldHklList;
                lambda = Math.min(1e9, lambda * 2);
            }
            
            if (progressCallback) await progressCallback((iter + 1) / maxIter);
        }

        return { params, hklList: workingHklList, JtJ: finalJtJ, paramMapping, ss_res, algorithm: 'lm', fitFlags };
    }




    async function refineParametersSA(initialParams, fitFlags, maxIter, hklList, system, progressCallback, refinementMode) {
        const { paramMapping } = getParameterMapping(fitFlags, initialParams, hklList, refinementMode);

        const objective = (p_obj, hkl_list_obj) => {
            try {
                updateHklPositions(hkl_list_obj, p_obj, system);
                const netCalcPattern = calculatePattern(workingData.tth, hkl_list_obj, p_obj);
                const y_bkg = calculateTotalBackground(workingData.tth, p_obj);
                
                let num = 0, den = 0;
                for (let i = 0; i < workingData.tth.length; i++) {
                    const y_obs_net = workingData.intensity[i] - y_bkg[i];
                    num += workingData.weights[i] * y_obs_net * netCalcPattern[i];
                    den += workingData.weights[i] * netCalcPattern[i] * netCalcPattern[i];
                }
                const scaleFactor = (den > 1e-9) ? num / den : 1.0;
                
                // ✅ CORRECTED: Use a for loop instead of .map()
                const y_calc_total = new Float64Array(netCalcPattern.length);
                for (let i = 0; i < netCalcPattern.length; i++) {
                    y_calc_total[i] = (scaleFactor * netCalcPattern[i]) + y_bkg[i];
                }

                let sum_w_res_sq = 0;
                for (let i = 0; i < workingData.tth.length; i++) {
                    sum_w_res_sq += workingData.weights[i] * Math.pow(workingData.intensity[i] - y_calc_total[i], 2);
                }
                return isFinite(sum_w_res_sq) ? sum_w_res_sq : 1e12;
            } catch (err) { return 1e12; }
        };

        let currentParams = JSON.parse(JSON.stringify(initialParams));
        let currentHklList = JSON.parse(JSON.stringify(hklList));
        let current_cost = objective(currentParams, currentHklList);

        let bestParams = JSON.parse(JSON.stringify(currentParams));
        let bestHklList = JSON.parse(JSON.stringify(currentHklList));
        let best_cost = current_cost;

        let T = 1.0;
        const T_min = 1e-7;
        const coolingRate = (maxIter > 0) ? Math.pow(T_min / T, 1.0 / maxIter) : 1.0;
        
        for (let step = 0; step < maxIter; step++) {
            const originalParams = JSON.parse(JSON.stringify(currentParams));
            const originalHklList = JSON.parse(JSON.stringify(currentHklList));
            
            const paramsToChange = Math.max(1, Math.floor(paramMapping.length / 10));
            for(let i = 0; i < paramsToChange; i++) {
                const p_idx = Math.floor(Math.random() * paramMapping.length);
                const mapping = paramMapping[p_idx];
                const original_norm_val = mapping.get(currentParams, currentHklList);
                const step_scale = Math.max(0.05, T);
                const step_size = (mapping.step || 0.3) * step_scale;
                const new_norm_val = original_norm_val + (Math.random() - 0.5) * 2 * step_size;
                mapping.set(currentParams, currentHklList, new_norm_val);
            }
            
            const neighbor_cost = objective(currentParams, currentHklList);
            const delta_cost = neighbor_cost - current_cost;
            
            const acceptance_prob = (T > 0 && current_cost > 0) ? Math.exp(-delta_cost / (current_cost * T)) : 0;
            const should_accept = (delta_cost < 0) || acceptance_prob > Math.random();

            if (should_accept) {
                current_cost = neighbor_cost;
            } else {
                currentParams = originalParams;
                currentHklList = originalHklList;
            }

            if (current_cost < best_cost) {
                best_cost = current_cost;
                bestParams = JSON.parse(JSON.stringify(currentParams));
                bestHklList = JSON.parse(JSON.stringify(currentHklList));
            }

            T = Math.max(T_min, T * coolingRate);
            if (progressCallback) await progressCallback((step + 1) / maxIter);
        }
        
        updateHklPositions(bestHklList, bestParams, system);
        const netCalcPattern = calculatePattern(workingData.tth, bestHklList, bestParams);
        const y_bkg = calculateTotalBackground(workingData.tth, bestParams);
        let num = 0, den = 0;
        for (let i = 0; i < workingData.tth.length; i++) {
            const y_obs_net = workingData.intensity[i] - y_bkg[i];
            num += workingData.weights[i] * y_obs_net * netCalcPattern[i];
            den += workingData.weights[i] * netCalcPattern[i] * netCalcPattern[i];
        }
        const bestScaleFactor = (den > 1e-9) ? num / den : 1.0;
        
        bestHklList.forEach(hkl => {
            hkl.intensity *= bestScaleFactor;
        });
        
        return { 
            params: bestParams, 
            hklList: bestHklList, 
            algorithm: 'sa', 
            paramMapping, 
            fitFlags, 
            ss_res: best_cost
        };
    }

        const getAllParams = () => {
            const profileType = controls.profileSelect.value;
            let params = {
                lambda: parseFloat(controls.wavelength.value),
                lambda2: parseFloat(controls.wavelength2.value), 
                ratio: parseFloat(controls.ratio21.value),       
                zeroShift: parseFloat(controls.zeroShift.value),
                profileType: profileType
            };
            
            document.querySelectorAll('#lattice-parameters-container input[type="number"]').forEach(input => {
                if (input.id.startsWith('lattice-param-')) {
                    const paramName = input.id.replace('lattice-param-', '');
                    params[paramName] = parseFloat(input.value);
                }
            });

            const { system } = getSystemAndCentering();

            switch(system) {
                case 'cubic': case 'tetragonal': case 'orthorhombic': 
                    params.alpha = params.beta = params.gamma = 90; 
                    break;
                case 'rhombohedral':
                case 'hexagonal': 
                    params.alpha = params.beta = 90; params.gamma = 120; 
                    break;
                case 'monoclinic': 
                    params.alpha = params.gamma = 90; 
                    break;
            }

            if (profileType === "4") {
                Object.assign(params, { 
                    GU: parseFloat(controls.paramGU.value), GV: parseFloat(controls.paramGV.value), 
                    GW: parseFloat(controls.paramGW.value), GP: parseFloat(controls.paramGP.value), 
                    LX: parseFloat(controls.paramLX.value), eta: parseFloat(controls.paramEta.value), 
                    shft: parseFloat(controls.paramShft.value), trns: parseFloat(controls.paramTrns.value) 
                });
            } else {
                Object.assign(params, { 
                    U: parseFloat(controls.paramU.value), V: parseFloat(controls.paramV.value), 
                    W: parseFloat(controls.paramW.value), X: parseFloat(controls.paramX.value), 
                    Y: parseFloat(controls.paramY.value), SL: parseFloat(controls.paramSL.value), 
                    HL: parseFloat(controls.paramHL.value), S400: parseFloat(controls.paramS400.value), 
                    S040: parseFloat(controls.paramS040.value), S004: parseFloat(controls.paramS004.value), 
                    S220: parseFloat(controls.paramS220.value), S202: parseFloat(controls.paramS202.value), 
                    S022: parseFloat(controls.paramS022.value) 
                });
            }

            // Add Chebyshev and Hump parameters
            for (let i = 0; i < NUM_BACKGROUND_PARAMS; i++) {
                const input = document.getElementById(`param-b${i}`);
                if (input) params[`B${i}`] = parseFloat(input.value);
            }
            params['hump_H'] = parseFloat(document.getElementById('param-hump-h').value);
            params['hump_P'] = parseFloat(document.getElementById('param-hump-p').value);
            params['hump_W'] = parseFloat(document.getElementById('param-hump-w').value);

            return params;
        };
       
        const getFitFlags = () => {
            const profileType = controls.profileSelect.value;
            let flags = {
                a: document.getElementById('fit-lattice-a')?.checked ?? false,
                b: document.getElementById('fit-lattice-b')?.checked ?? false,
                c: document.getElementById('fit-lattice-c')?.checked ?? false,
                alpha: document.getElementById('fit-lattice-alpha')?.checked ?? false,
                beta: document.getElementById('fit-lattice-beta')?.checked ?? false,
                gamma: document.getElementById('fit-lattice-gamma')?.checked ?? false,
                zeroShift: controls.fitZeroShift.checked,
            };
            if (profileType === "4") {
                Object.assign(flags, { GU: controls.fitGU.checked, GV: controls.fitGV.checked, GW: controls.fitGW.checked, GP: controls.fitGP.checked, LX: controls.fitLX.checked, eta: controls.fitEta.checked, shft: controls.fitShft.checked, trns: controls.fitTrns.checked });
            } else {
                Object.assign(flags, { U: controls.fitU.checked, V: controls.fitV.checked, W: controls.fitW.checked, X: controls.fitX.checked, Y: controls.fitY.checked, SL: controls.fitSL.checked, HL: controls.fitHL.checked });
                if (profileType === "3") {
                    Object.assign(flags, { S400: controls.fitS400.checked, S040: controls.fitS040.checked, S004: controls.fitS004.checked, S220: controls.fitS220.checked, S202: controls.fitS202.checked, S022: controls.fitS022.checked });
                    const { system } = getSystemAndCentering();
                    switch (system) {
                        case 'cubic': flags.S040 = flags.S004 = flags.S202 = flags.S022 = false; break;
                        case 'hexagonal': case 'tetragonal': case 'rhombohedral': flags.S040 = flags.S022 = false; break;
                    }
                }
            }

            // Add Chebyshev and Hump flags
            for (let i = 0; i < NUM_BACKGROUND_PARAMS; i++) {
                const checkbox = document.getElementById(`fit-b${i}`);
                if (checkbox) flags[`B${i}`] = checkbox.checked;
            }
            flags['hump_H'] = document.getElementById('fit-hump-h').checked;
            flags['hump_P'] = document.getElementById('fit-hump-p').checked;
            flags['hump_W'] = document.getElementById('fit-hump-w').checked;

            return flags;
        };


function getParameterMapping(fitFlags, initialParams, hklList, refinementMode) {
    const mappings = [];

    const createMapping = (flag, name, defaultScale = 1.0, minVal = -Infinity, maxVal = Infinity, step = 0.2) => {
        if (!flag) return null;
        const initialValue = initialParams[name] ?? 0;
        const scale = Math.abs(initialValue) > 1e-9 ? initialValue : defaultScale;
        return {
            name: name,
            scale: scale,
            step: step,
            isIntensity: false, // Flag to identify parameter type
            get: (p_obj, hkl_list_obj) => p_obj[name] / scale,
            set: (p_obj, hkl_list_obj, value) => {
                let rawValue = value * scale;
                if (rawValue < minVal) rawValue = minVal;
                if (rawValue > maxVal) rawValue = maxVal;
                p_obj[name] = rawValue;
            }
        };
    };

    if (refinementMode === 'pawley' && hklList) {
        hklList.forEach((hkl, index) => {
            if (hkl.tth >= workingData.tth[0] && hkl.tth <= workingData.tth[workingData.tth.length - 1]) {
                const hkl_name = `I_(${hkl.h_orig},${hkl.k_orig},${hkl.l_orig})`;
                const initialIntensity = hkl.intensity > 0 ? hkl.intensity : 1000.0;
                mappings.push({
                    name: hkl_name,
                    scale: initialIntensity,
                    step: 0.3,
                    isIntensity: true, // Flag to identify parameter type
                    index: index, 
                    get: (p_obj, hkl_list_obj) => hkl_list_obj[index].intensity / initialIntensity,
                    set: (p_obj, hkl_list_obj, value) => {
                        let rawValue = value * initialIntensity;
                        hkl_list_obj[index].intensity = Math.max(0, rawValue);
                    }
                });
            }
        });
    }

    const profileType = initialParams.profileType || controls.profileSelect.value;
    mappings.push(createMapping(fitFlags.a, 'a', 4.0, 0.1, undefined, 0.01));
    mappings.push(createMapping(fitFlags.b, 'b', 4.0, 0.1, undefined, 0.01));
    mappings.push(createMapping(fitFlags.c, 'c', 6.0, 0.1, undefined, 0.01));
    mappings.push(createMapping(fitFlags.alpha, 'alpha', 90.0, undefined, undefined, 0.05));
    mappings.push(createMapping(fitFlags.beta, 'beta', 90.0, undefined, undefined, 0.05));
    mappings.push(createMapping(fitFlags.gamma, 'gamma', 120.0, undefined, undefined, 0.05));
    mappings.push(createMapping(fitFlags.zeroShift, 'zeroShift', 0.01, undefined, undefined, 0.1));
    if (profileType === "4") {
        mappings.push(createMapping(fitFlags.GU, 'GU', 0.1, 0, undefined, 0.05));
        mappings.push(createMapping(fitFlags.GV, 'GV', -0.1, undefined, undefined, 0.05));
        mappings.push(createMapping(fitFlags.GW, 'GW', 0.1, 1e-6, undefined, 0.05));
        mappings.push(createMapping(fitFlags.GP, 'GP', 0.0, undefined, undefined, 0.1));
        mappings.push(createMapping(fitFlags.LX, 'LX', 0.1, 1e-6, undefined, 0.2));
        mappings.push(createMapping(fitFlags.eta, 'eta', 0.5, 0, 1, 0.1));
        mappings.push(createMapping(fitFlags.shft, 'shft', 0.0, undefined, undefined, 0.1));
        mappings.push(createMapping(fitFlags.trns, 'trns', 0.0, undefined, undefined, 0.1));
    } else {
        mappings.push(createMapping(fitFlags.U, 'U', 0.1, undefined, undefined, 0.2));
        mappings.push(createMapping(fitFlags.V, 'V', -0.1, undefined, undefined, 0.2));
        mappings.push(createMapping(fitFlags.W, 'W', 0.1, 1e-6, undefined, 0.2));
        mappings.push(createMapping(fitFlags.X, 'X', 0.1, 1e-6, undefined, 0.2));
        mappings.push(createMapping(fitFlags.Y, 'Y', 0.1, 1e-6, undefined, 0.2));
        mappings.push(createMapping(fitFlags.SL, 'SL', 0.01, undefined, undefined, 0.1));
        mappings.push(createMapping(fitFlags.HL, 'HL', 0.01, undefined, undefined, 0.1));
         if (profileType === "3") {
            mappings.push(createMapping(fitFlags.S400, 'S400', 0.0, undefined, undefined, 0.2));
            mappings.push(createMapping(fitFlags.S040, 'S040', 0.0, undefined, undefined, 0.2));
            mappings.push(createMapping(fitFlags.S004, 'S004', 0.0, undefined, undefined, 0.2));
            mappings.push(createMapping(fitFlags.S220, 'S220', 0.0, undefined, undefined, 0.2));
            mappings.push(createMapping(fitFlags.S202, 'S202', 0.0, undefined, undefined, 0.2));
            mappings.push(createMapping(fitFlags.S022, 'S022', 0.0, undefined, undefined, 0.2));
        }
    }
    for (let i = 0; i < NUM_BACKGROUND_PARAMS; i++) {
        mappings.push(createMapping(fitFlags[`B${i}`], `B${i}`, i === 0 ? 100 : 1.0, undefined, undefined, 0.3));
    }
    mappings.push(createMapping(fitFlags.hump_H, 'hump_H', 100.0, undefined, undefined, 0.2));
    mappings.push(createMapping(fitFlags.hump_P, 'hump_P', 30.0, undefined, undefined, 0.1));
    mappings.push(createMapping(fitFlags.hump_W, 'hump_W', 5.0, 0.01, undefined, 0.1));

    const paramMapping = mappings.filter(Boolean);
    return { paramMapping };
}


/**
 * Clears the cached HKL index list for the currently selected space group.
 * This forces a full recalculation on the next request.
 */
function invalidateHklCache() {
    const selectedSgNumber = parseInt(controls.spaceGroupSelect.value, 10);
    if (selectedSgNumber && hklIndexCache[selectedSgNumber]) {
        delete hklIndexCache[selectedSgNumber];
    }
}

/**
 * Generates the list of raw HKL indices {h, k, l, multiplicity}.
 * Checks the cache first. If the list is not cached for the given space group,
 * it performs the expensive loop calculations and stores the result in the cache.
 * @returns {Array} A list of raw HKL reflection objects.
 */
function generateAndCacheHklIndices(spaceGroup, maxTth, params) {
    const sgNumber = spaceGroup.number;
    // 1. Check the cache first! If found, return the cached list immediately.
    if (hklIndexCache[sgNumber]) {
        return hklIndexCache[sgNumber];
    }

    // 2. If not in cache, perform the expensive generation.
    const { a, lambda } = params;
    const { system, laue_class } = spaceGroup;
    if (!a || !lambda || a <= 0 || lambda <= 0 || !laue_class) return [];

    const maxDimension = Math.max(params.a || 0, params.b || params.a, params.c || params.a);
    const maxIndex = Math.ceil(2 * maxDimension / lambda * Math.sin(maxTth * Math.PI / 360)) + 5;
    
    let rawReflections = [];

    const loopAndAdd = (h, k, l) => {
        if (h === 0 && k === 0 && l === 0) return;
        if (isReflectionAllowed(h, k, l, spaceGroup)) {
            const { multiplicity } = getMultiplicityAndCanonicalHKL(h, k, l, laue_class);
            // NOTE: We only store raw index data, NOT position (tth, d).
            rawReflections.push({
                h_orig: h,
                k_orig: k,
                l_orig: l,
                hkl_list: [`(${h},${k},${l})`],
                multiplicity: multiplicity
            });
        }
    };

    // This is computationally intensive block.
    switch (laue_class) {
        case 'm-3m': case 'm-3':
            for (let l = 0; l < maxIndex; l++) for (let k = l; k < maxIndex; k++) for (let h = k; h < maxIndex; h++) loopAndAdd(h, k, l);
            break;
        case '6/mmm': case '6/m':
            for (let l = 0; l < maxIndex; l++) for (let k = 0; k < maxIndex; k++) for (let h = k; h < maxIndex; h++) loopAndAdd(h, k, l);
            break;
            
        // --- CORRECTED TRIGONAL LOOP LOGIC ---
        case '-3m': case '-3':
            for (let l = -maxIndex; l < maxIndex; l++) {
                for (let k = 0; k < maxIndex; k++) {
                    for (let h = k; h < maxIndex; h++) { // Enforces h >= k >= 0
                        if (h === 0 && k === 0 && l === 0) continue;
                        loopAndAdd(h, k, l);
                    }
                }
            }
            break;
        // --- END CORRECTION ---

        case '4/mmm': case '4/m':
            for (let l = 0; l < maxIndex; l++) for (let k = 0; k < maxIndex; k++) for (let h = k; h < maxIndex; h++) loopAndAdd(h, k, l);
            break;
        case 'mmm':
            for (let l = 0; l < maxIndex; l++) for (let k = 0; k < maxIndex; k++) for (let h = 0; h < maxIndex; h++) loopAndAdd(h, k, l);
            break;
        case '2/m':
            for (let k = 0; k < maxIndex; k++) for (let l = 0; l < maxIndex; l++) for (let h = -maxIndex; h < maxIndex; h++) if (!((k === 0 && h < 0) || (l === 0 && h < 0))) loopAndAdd(h, k, l);
            break;
        case '-1':
            for (let k = 0; k < maxIndex; k++) for (let h = -maxIndex; h < maxIndex; h++) for (let l = -maxIndex; l < maxIndex; l++) if (!(k > 0 || l < 0)) loopAndAdd(h, k, l);
            break;
        default:
            for (let h = 0; h < maxIndex; h++) for (let k = 0; k < maxIndex; k++) for (let l = 0; l < maxIndex; l++) loopAndAdd(h, k, l);
            break;
    }

    // 3. Store the newly generated list in the cache before returning it.
    hklIndexCache[sgNumber] = rawReflections;
    return rawReflections;
}

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was invoked.
 * @param {Function} func The function to debounce.
 * @param {number} wait The number of milliseconds to delay.
 * @returns {Function} Returns the new debounced function.
 */
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
};




        const dot = (v1, v2) => { let s = 0; for(let i=0; i<v1.length; i++) s += v1[i] * v2[i]; return s; }; const add = (v1, v2) => v1.map((x, i) => x + v2[i]); const subtract = (v1, v2) => v1.map((x, i) => x - v2[i]); const scale = (v, s) => v.map(x => x * s); const transpose = (m) => { if (!m || m.length === 0 || !Array.isArray(m[0])) return m.map(x => [x]); return m[0].map((_, colIndex) => m.map(row => row[colIndex])); }; const multiply = (A, B) => { if (!Array.isArray(B[0])) return A.map(row => dot(row, B)); const Bt = transpose(B); return A.map(rowA => Bt.map(colB => dot(rowA, colB))); }; 
        const solve = (A, b) => { const n = A.length; const Ab = A.map((row, i) => [...row, b[i]]); for (let i = 0; i < n; i++) { let max = i; for (let k = i + 1; k < n; k++) if (Math.abs(Ab[k][i]) > Math.abs(Ab[max][i])) max = k; [Ab[i], Ab[max]] = [Ab[max], Ab[i]]; if (Math.abs(Ab[i][i]) < 1e-12) continue; for (let k = i + 1; k < n; k++) { const factor = Ab[k][i] / Ab[i][i]; if (!isFinite(factor)) continue; for (let j = i; j < n + 1; j++) Ab[k][j] -= factor * Ab[i][j]; } } const x = new Array(n).fill(0); for (let i = n - 1; i >= 0; i--) { let sum = 0; for (let j = i + 1; j < n; j++) sum += Ab[i][j] * x[j]; if (Math.abs(Ab[i][i]) > 1e-12) x[i] = (Ab[i][n] - sum) / Ab[i][i]; } return x; };
        function calculateDeterminant(A) { const n = A.length; if (n === 1) return A[0][0]; if (n === 2) return A[0][0] * A[1][1] - A[0][1] * A[1][0]; const U = A.map(row => [...row]); let det = 1; for (let i = 0; i < n; i++) { let maxRow = i; for (let k = i + 1; k < n; k++) if (Math.abs(U[k][i]) > Math.abs(U[maxRow][i])) maxRow = k; if (maxRow !== i) { [U[i], U[maxRow]] = [U[maxRow], U[i]]; det *= -1; } if (Math.abs(U[i][i]) < 1e-15) return 0; det *= U[i][i]; for (let k = i + 1; k < n; k++) { const factor = U[k][i] / U[i][i]; for (let j = i; j < n; j++) U[k][j] -= factor * U[i][j]; } } return det; }
        function matrixInverse(A) { const n = A.length; if (n === 0) return []; const det = calculateDeterminant(A); if (Math.abs(det) < 1e-15) { console.warn("Matrix is singular or near-singular, determinant =", det); return null; } const augmented = A.map((row, i) => [...row, ...Array.from({ length: n }, (_, j) => (i === j ? 1 : 0))]); for (let i = 0; i < n; i++) { let maxRow = i; for (let j = i + 1; j < n; j++) if (Math.abs(augmented[j][i]) > Math.abs(augmented[maxRow][i])) maxRow = j; [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]]; if (Math.abs(augmented[i][i]) < 1e-15) { console.warn("Zero pivot encountered during matrix inversion"); return null; } const pivot = augmented[i][i]; for (let j = 0; j < 2 * n; j++) augmented[i][j] /= pivot; for (let j = 0; j < n; j++) { if (i !== j) { const factor = augmented[j][i]; for (let k = 0; k < 2 * n; k++) augmented[j][k] -= factor * augmented[i][k]; } } } return augmented.map(row => row.slice(n)); }
        function enforceSymmetryConstraints(params) { const { system } = getSystemAndCentering(); switch (system) { case 'cubic': if (params.S400 !== undefined) params.S040 = params.S004 = params.S400; if (params.S220 !== undefined) params.S202 = params.S022 = params.S220; break; case 'hexagonal': case 'tetragonal': case 'rhombohedral': if (params.S400 !== undefined) params.S040 = params.S400; if (params.S202 !== undefined) params.S022 = params.S202; break; } }


        function updatePreviewPattern() {
            if (!mainChart || !workingData.isValid || isFitting) return;

            const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
            const params = getAllParams();
            if (isNaN(params.lambda) || params.lambda <= 0 || isNaN(params.a) || params.a <= 0) return;
            
            const selectedSg = spaceGroups.find(sg => sg.number === parseInt(controls.spaceGroupSelect.value, 10));
            if (!selectedSg) return;

            let hklList = JSON.parse(JSON.stringify(masterHklList));
            updateHklPositions(hklList, params, selectedSg.system);
            lastGeneratedHklList = hklList; 

            if (lastFitResultsCache && lastFitResultsCache.hklList) {
                const intensityMap = new Map(
                    lastFitResultsCache.hklList.map(p => [p.hkl_list[0], p.intensity])
                );
                hklList.forEach(p => {
                    p.intensity = intensityMap.get(p.hkl_list[0]) || 0;
                });
            } else {
                hklList.forEach(p => p.intensity = 1000); 
            }
            
            const minTth = parseFloat(controls.tthMinSlider.value); 
            const maxTth = parseFloat(controls.tthMaxSlider.value);

            findDataset('HKL Markers').data = hklList
                .filter(hkl => {
                    if (!hkl.tth) return false;
                    const peakPos = hkl.tth + params.zeroShift;
                    return peakPos >= minTth && peakPos <= maxTth;
                })
                .map(hkl => ({
                    x: hkl.tth + params.zeroShift,
                    hkl: `${hkl.hkl_list[0]} [m=${hkl.multiplicity}]`
                }));

            const background_sliced = calculateTotalBackground(workingData.tth, params);
            const unscaledPeakPattern_sliced = calculatePattern(workingData.tth, hklList, params);
            const y_obs_net_sliced = new Float64Array(workingData.intensity.length);
            for(let i = 0; i < y_obs_net_sliced.length; i++) {
                y_obs_net_sliced[i] = Math.max(0, workingData.intensity[i] - background_sliced[i]);
            }
            
            const sum_obs_calc = dot(y_obs_net_sliced, unscaledPeakPattern_sliced);
            const sum_calc_sq = dot(unscaledPeakPattern_sliced, unscaledPeakPattern_sliced);
            const scaleFactor = (sum_calc_sq > 1e-9) ? sum_obs_calc / sum_calc_sq : 1.0;
            const totalCalcPattern = new Float64Array(unscaledPeakPattern_sliced.length);
            for (let i = 0; i < totalCalcPattern.length; i++) {
                totalCalcPattern[i] = (unscaledPeakPattern_sliced[i] * scaleFactor) + background_sliced[i];
            }
            
            // ✅ CORRECTED: Use a for loop instead of .map()
            const diff = [];
            for (let i = 0; i < workingData.intensity.length; i++) {
                diff.push(workingData.intensity[i] - totalCalcPattern[i]);
            }
            workingData.lastRawDifference = diff;

            // ✅ CORRECTED: Use a for loop to build the chart data array
            const simulationData = [];
            for (let i = 0; i < workingData.tth.length; i++) {
                simulationData.push({ x: workingData.tth[i], y: totalCalcPattern[i] });
            }
            findDataset('Simulation (Manual)').data = simulationData;
            findDataset('Calculated').data = [];
        }



        // setUIState function
function setUIState(fitting) {
    isFitting = fitting;
    const leBailButton = document.getElementById('le-bail-button');
    const pawleyButton = document.getElementById('pawley-button');
    
    leBailButton.disabled = fitting;
    pawleyButton.disabled = fitting;
    controls.reportButton.disabled = fitting;
    controls.saveDataButton.disabled = fitting;
    
    // Update text content during refinement
    if (fitting) {
        leBailButton.textContent = 'Refining...';
        pawleyButton.textContent = 'Refining...';
        controls.rpResult.textContent = '...';
        controls.rwpResult.textContent = '...';
        controls.chi2Result.textContent = '...';
    } else {
        leBailButton.textContent = 'Run Le Bail';
        pawleyButton.textContent = 'Run Pawley';
        if(fitResults) {
            controls.reportButton.disabled = false;
            controls.saveDataButton.disabled = false;
        }
        controls.rwpResult.parentElement.parentElement.querySelectorAll('.result-card').forEach(c => c.style.background = '');
    }

    controls.progressBarContainer.classList.toggle('hidden', !fitting);
    document.body.style.cursor = fitting ? 'wait' : 'default';
    if (!fitting) {
        controls.progressBar.style.width = '0%';
    }
}
        
    function updateUI(params, stats, netPeakPattern_full, background_full, scaleFactor, hklList) {
            const safeUpdate = (paramValue, controlElement, digits) => { 
                if (controlElement && typeof paramValue === 'number' && isFinite(paramValue)) {
                    controlElement.value = paramValue.toFixed(digits);
                }
            };
            
            if (stats && typeof stats.r_p === 'number') controls.rpResult.textContent = stats.r_p.toFixed(2);
            if (stats && typeof stats.rwp === 'number') controls.rwpResult.textContent = stats.rwp.toFixed(2);
            if (stats && typeof stats.chi2 === 'number') controls.chi2Result.textContent = stats.chi2.toFixed(3);
            
            // Update lattice, zero shift, and profile parameters
            safeUpdate(params.a, document.getElementById('lattice-param-a'), 4);
            safeUpdate(params.b, document.getElementById('lattice-param-b'), 4);
            safeUpdate(params.c, document.getElementById('lattice-param-c'), 4);
            safeUpdate(params.alpha, document.getElementById('lattice-param-alpha'), 3);
            safeUpdate(params.beta, document.getElementById('lattice-param-beta'), 3);
            safeUpdate(params.gamma, document.getElementById('lattice-param-gamma'), 3);
            safeUpdate(params.zeroShift, controls.zeroShift, 4);
            
            const profileType = params.profileType || controls.profileSelect.value;
            if (profileType === "4") {
                safeUpdate(params.GU, controls.paramGU, 4); safeUpdate(params.GV, controls.paramGV, 4);
                safeUpdate(params.GW, controls.paramGW, 4); safeUpdate(params.GP, controls.paramGP, 4);
                safeUpdate(params.LX, controls.paramLX, 4); safeUpdate(params.eta, controls.paramEta, 4);
                safeUpdate(params.shft, controls.paramShft, 4); safeUpdate(params.trns, controls.paramTrns, 4);
            } else {
                safeUpdate(params.U, controls.paramU, 4); safeUpdate(params.V, controls.paramV, 4);
                safeUpdate(params.W, controls.paramW, 4); safeUpdate(params.X, controls.paramX, 4);
                safeUpdate(params.Y, controls.paramY, 4); safeUpdate(params.SL, controls.paramSL, 4);
                safeUpdate(params.HL, controls.paramHL, 4);
                if (profileType === "3") {
                    safeUpdate(params.S400, controls.paramS400, 4); safeUpdate(params.S040, controls.paramS040, 4);
                    safeUpdate(params.S004, controls.paramS004, 4); safeUpdate(params.S220, controls.paramS220, 4);
                    safeUpdate(params.S202, controls.paramS202, 4); safeUpdate(params.S022, controls.paramS022, 4);
                }
            }
            
            // --- Update background parameter inputs 
            for (let i = 0; i < NUM_BACKGROUND_PARAMS; i++) {
                safeUpdate(params[`B${i}`], document.getElementById(`param-b${i}`), 4);
            }
            safeUpdate(params.hump_H, document.getElementById('param-hump-h'), 4);
            safeUpdate(params.hump_P, document.getElementById('param-hump-p'), 4);
            safeUpdate(params.hump_W, document.getElementById('param-hump-w'), 4);

            // ✅ This check is critical to ensure valid data is passed to the chart
            if (netPeakPattern_full && background_full && hklList && mainChart) {
                updateChart(netPeakPattern_full, background_full, hklList, params, scaleFactor);
            }
        }

        //updateChart, sans Y auto zoom, le 7 oct 25
        function updateChart(netPeakPattern_sliced, background_sliced, hklList, params, scaleFactor = 1.0) {
            if (!mainChart || !workingData.isValid) return;

            // Store the current Y-axis zoom state BEFORE making any changes
            const currentYMin = mainChart.scales.y.min;
            const currentYMax = mainChart.scales.y.max;

            const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
            
            // 1. Hide the manual simulation line, as we now have a real fit
            findDataset('Simulation (Manual)').data = [];

            // 2. Calculate the total pattern and the raw difference array
            const totalCalcPattern = new Float64Array(netPeakPattern_sliced.length);
            for(let i = 0; i < totalCalcPattern.length; i++){
                totalCalcPattern[i] = (netPeakPattern_sliced[i] * scaleFactor) + background_sliced[i];
            }
            
            const diff = [];
            for (let i = 0; i < workingData.intensity.length; i++) {
                diff.push(workingData.intensity[i] - totalCalcPattern[i]);
            }
            // This global variable is now ready for rescalePlot to use
            workingData.lastRawDifference = diff; 

            // 3. Prepare the data for the 'Calculated' and 'Background' datasets
            const calculatedData = [];
            const backgroundData = [];
            for(let i = 0; i < workingData.tth.length; i++) {
                calculatedData.push({ x: workingData.tth[i], y: totalCalcPattern[i] });
                backgroundData.push({ x: workingData.tth[i], y: background_sliced[i] });
            }
            findDataset('Calculated').data = calculatedData;
            findDataset('Background').data = backgroundData;


            // 4. Restore the Y-axis zoom state FIRST. This sets the final "frame" for the chart.
            mainChart.options.scales.y.min = currentYMin;
            mainChart.options.scales.y.max = currentYMax;
            
            // 5. NOW call rescalePlot. It will use the correct, restored axis dimensions to draw the difference plot.
            rescalePlot(false); 
            
            // 6. Finally, update the chart once to draw everything in its correct place.
            mainChart.update('none');
        }

        function getPeakInfoAt(tth) {
            if (!lastGeneratedHklList || lastGeneratedHklList.length === 0 || !mainChart) return { peak: null, inRegion: false };
            let closestPeak = null, minDiff = Infinity; const currentParams = getAllParams(); const zeroShift = currentParams.zeroShift || 0;
            for (const hkl of lastGeneratedHklList) { const peakShift = calculatePeakShift(hkl.tth, currentParams); const peakPos = hkl.tth + zeroShift + peakShift; const diff = Math.abs(tth - peakPos); if (diff < minDiff) { minDiff = diff; closestPeak = hkl; } }
            if (closestPeak) { 
                const threshold = 0.2;
                   if (minDiff < threshold) return { peak: closestPeak, inRegion: true }; }
            return { peak: null, inRegion: false };
        }


        function initializeChart() {
            if (mainChart) mainChart.destroy();

            // ✅ CORRECTED: Use a for loop instead of .map()
            const experimentalPoints = [];
            for (let i = 0; i < fullExperimentalData.tth.length; i++) {
                experimentalPoints.push({ x: fullExperimentalData.tth[i], y: fullExperimentalData.intensity[i] });
            }
            
            const yMax = Math.max(...fullExperimentalData.intensity) || 1000;
            mainChart = new Chart(controls.mainChartCanvas, {
                type: 'line',
                data: { 
                    datasets: [
                        { label: 'Experimental', data: experimentalPoints, borderColor: 'rgba(107, 114, 128, 0.7)', borderWidth: 0.5, pointRadius: 1, pointBackgroundColor: 'rgba(107, 114, 128, 0.7)', order: 1 },
                        { label: 'Simulation (Manual)', data: [], borderColor: 'rgba(249, 115, 22, 0.8)', borderWidth: 2, pointRadius: 0, borderDash: [8, 4], order: 2 },
                        { label: 'Calculated', data: [], borderColor: 'rgba(59, 130, 246, 1)', borderWidth: 2, pointRadius: 0, order: 3 },
                        { label: 'Background', data: [], borderColor: 'rgba(2, 9, 206, 0.8)', borderWidth: 1.5, pointRadius: 0, borderDash: [5, 5], order: 4 },
                        { label: 'Difference', data: [], borderColor: 'rgba(239, 68, 68, 0.8)', borderWidth: 1.5, pointRadius: 0, order: 5 },
                        { label: 'Difference Zero', data: [], borderColor: 'rgba(156, 163, 175, 0.8)', borderWidth: 1, pointRadius: 0, borderDash: [2, 2], order: 6 },
                        { type: 'bar', label: 'HKL Markers', data: [], backgroundColor: 'rgba(22, 163, 74, 0.9)', barThickness: 1, categoryPercentage: 1.0, barPercentage: 1.0, order: 0 },
                        {
                            label: 'Anchor Points',
                            type: 'scatter',
                            data: [], // Initially empty
                            showLine: false,
                            pointBackgroundColor: 'rgba(34, 197, 94, 1)', // A vibrant green
                            pointBorderColor: 'rgba(255, 255, 255, 0.9)',
                            pointRadius: 5,
                            pointHoverRadius: 7,
                            pointBorderWidth: 1.5,
                            order: -1 // Render on top of everything
                        }
                    ]
                },
                options: {
                    responsive: true, maintainAspectRatio: false, animation: false,
                    scales: {
                        x: { type: 'linear', title: { display: true, text: '2θ (degrees)', font: { size: 14 }}},
                        y: { type: 'linear', position: 'left', title: { display: true, text: 'Intensity (a.u.)', font: { size: 14 }},
                            min: -yMax * 0.3, max: Math.ceil(yMax * 1.1),
                            ticks: { callback: function(value, index, ticks) { return value >= 0 ? value.toFixed(1) : null; }}
                        }
                    },
                    plugins: {
                        zoom: {
                            pan: { enabled: true, mode: 'xy', threshold: 5, onPanComplete: () => rescalePlot(false) },
                            zoom: { wheel: { enabled: false }, pinch: { enabled: true }, drag: { enabled: false }, onZoomComplete: () => rescalePlot(false) }
                        },
                        legend: { labels: { filter: item => item.text !== 'Difference Zero' && item.text !== 'Simulation (Manual)' && item.text !== 'Anchor Points'}},
                        tooltip: {
                            enabled: true,
                            mode: 'nearest',
                            intersect: false,
                            position: 'experimentalAnchor',
                            filter: function(tooltipItem) {
                                const tth = tooltipItem.parsed.x;
                                const peakInfo = getPeakInfoAt(tth);
                                return peakInfo.inRegion;
                            },
                            callbacks: {
                                title: function(tooltipItems) {
                                    if (!tooltipItems.length) return '';
                                    const tth = tooltipItems[0].parsed.x;
                                    const peakInfo = getPeakInfoAt(tth);
                                    if (peakInfo.inRegion) {
                                        const closestPeak = peakInfo.peak;
                                        return `d: ${closestPeak.d.toFixed(2)} Å, HKL: ${closestPeak.hkl_list[0]}`;
                                    }
                                    return '';
                                },
                                label: function(context) {
                                    return null;
                                }
                            }
                        }
                    }
                }
            });
            mainChart.options.globalYMax = yMax;
        }


    function updatePlotRange(recalculateYMax = false) {
            if (!mainChart || workingData.tth.length === 0) {
                return;
            }
            const minTth = parseFloat(controls.tthMinSlider.value);
            const maxTth = parseFloat(controls.tthMaxSlider.value);

            // Explicitly set the x-axis limits
            mainChart.options.scales.x.min = minTth;
            mainChart.options.scales.x.max = maxTth;

            // Recalculate Y-axis if needed
            if (recalculateYMax) {
                // Find the max intensity within the current workingData range
                const currentMaxY = Math.max(...workingData.intensity);
                let newYMax = currentMaxY * 1.1; // Add 10% padding
                if (newYMax < 100) newYMax = 100; // Minimum Y-max

                // Constant negative space for difference plot
                mainChart.options.globalYMax = newYMax; // Store this globally
                mainChart.options.scales.y.max = newYMax;
                mainChart.options.scales.y.min = -(newYMax * 0.3); // Allocate 30% for difference plot
            }
            
            mainChart.update('none');
        }        


        function rescalePlot(updateY = false) {
        // === CONFIGURABLE PARAMETERS FOR DIFFERENCE PLOT ===
        const DIFF_PLOT_MIN_RATIO = 0.1;  // Minimum allocation: 10% of Y scale
        const DIFF_PLOT_MAX_RATIO = 0.3;  // Maximum allocation: 30% of Y scale
        const DIFF_PLOT_PADDING = 1.1;     // Padding factor (1.1 = 10% extra space)
        // =======

        if (!mainChart || !workingData.isValid) return;

        const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
        const globalYMax = mainChart.options.globalYMax;

        // --- DYNAMIC DIFFERENCE PLOT ALLOCATION ---
        let diffPlotHeightRatio = 0.15; // Default allocation

        // This is the source of truth for the difference plot's magnitude
        const diffData = workingData.lastRawDifference || [];
        
        if (diffData.length > 0) {
            const maxAbsDiff = Math.max(...diffData.map(Math.abs));
            if (globalYMax > 0) {
                const requiredRatio = (maxAbsDiff * DIFF_PLOT_PADDING) / globalYMax;
                diffPlotHeightRatio = Math.max(DIFF_PLOT_MIN_RATIO, Math.min(DIFF_PLOT_MAX_RATIO, requiredRatio));
            }
        }

        const constantNegSpaceHeight = globalYMax * diffPlotHeightRatio;

        // Update Y-axis 
        if (updateY) {
            mainChart.options.scales.y.max = globalYMax;
        }
        mainChart.options.scales.y.min = -constantNegSpaceHeight;
        
        // Draw HKL Markers with a fixed pixel height
        const hklDataset = findDataset('HKL Markers');
        if (hklDataset && hklDataset.data.length > 0) {
            const HKL_MARKER_PIXEL_HEIGHT = 20;
            const y_scale = mainChart.scales.y;
            const zeroLineValue = 0; 
            const bottomPixel = y_scale.getPixelForValue(zeroLineValue);
            const topPixel = bottomPixel + HKL_MARKER_PIXEL_HEIGHT;
            const markerBottom = zeroLineValue;
            const markerTop = y_scale.getValueForPixel(topPixel);
            hklDataset.data.forEach(point => point.y = [markerTop, markerBottom]);
        }


        // --- Plot TRUE difference from the stored `lastRawDifference` array ---
        if (diffData.length > 0 && diffData.length === workingData.tth.length) {
            const constantDiffPlotSpaceTop = -(constantNegSpaceHeight * 0.25);
            const diffPlotZeroLine = -constantNegSpaceHeight + (constantNegSpaceHeight - constantDiffPlotSpaceTop) / 2;

            const differenceDataPoints = [];
            for (let i = 0; i < workingData.tth.length; i++) {
                const difference = diffData[i];
                differenceDataPoints.push({ x: workingData.tth[i], y: difference + diffPlotZeroLine });
            }
            findDataset('Difference').data = differenceDataPoints;

            findDataset('Difference Zero').data = [
                { x: workingData.tth[0], y: diffPlotZeroLine },
                { x: workingData.tth[workingData.tth.length - 1], y: diffPlotZeroLine }
            ];
        } else {
            // If there's no valid difference data, clear the lines.
            findDataset('Difference').data = [];
            findDataset('Difference Zero').data = [];
        }
    }

        function downloadTextFile(content, filename) {
            const element = document.createElement('a');
            const file = new Blob([content], {type: 'text/plain;charset=utf-8'});
            element.href = URL.createObjectURL(file);
            element.download = filename;
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
        }


        function showToast(message, type = 'error', duration = 4000) {
            let container = document.getElementById('toast-container');
            if (!container) {
                container = document.createElement('div');
                container.id = 'toast-container';
                document.body.appendChild(container);
            }

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;

            container.appendChild(toast);

            // Trigger the slide-in animation
            setTimeout(() => {
                toast.classList.add('show');
            }, 10);

            // Set a timer to hide and then remove the toast
            setTimeout(() => {
                toast.classList.remove('show');
                // Remove the element from the DOM after the fade-out transition completes
                toast.addEventListener('transitionend', () => toast.remove());
            }, duration);
        }


        /**
         * Calculates the total FWHM of a pseudo-Voigt peak from its Gaussian and Lorentzian components.
         * Uses the Thompson-Cox-Hastings approximation, which is accurate for all profile types.
         * @param {number} gamma_G - The FWHM of the Gaussian component.
         * @param {number} gamma_L - The FWHM of the Lorentzian component.
         * @returns {number} The total FWHM of the convoluted peak.
         */
        function getPeakFWHM(gamma_G, gamma_L) {
            const fwhm_g_5 = Math.pow(gamma_G, 5);
            const fwhm_l_5 = Math.pow(gamma_L, 5);
            const fwhm_g_4_l = Math.pow(gamma_G, 4) * gamma_L;
            const fwhm_g_3_l_2 = Math.pow(gamma_G, 3) * Math.pow(gamma_L, 2);
            const fwhm_g_2_l_3 = Math.pow(gamma_G, 2) * Math.pow(gamma_L, 3);
            const fwhm_g_l_4 = gamma_G * Math.pow(gamma_L, 4);

            const fwhm_pow5 = fwhm_g_5 + 2.69269 * fwhm_g_4_l + 2.42843 * fwhm_g_3_l_2 + 4.47163 * fwhm_g_2_l_3 + 0.07842 * fwhm_g_l_4 + fwhm_l_5;
            
            return Math.pow(fwhm_pow5, 0.2);
        }

        /**
         * Calculates the observed integrated intensity for all peaks by partitioning the net
         * experimental intensity at each point according to the calculated profile shapes.
         * This correctly handles overlapping reflections.
         * @param {Array<object>} hklList - The list of HKL reflections.
         * @param {object} params - The final refined parameters object.
         * @param {object} expData - The working experimental data {tth, intensity}.
         * @returns {Map<string, number>} A map where keys are HKL strings and values are the calculated I_obs.
         */
        function calculateAllObservedIntensities(hklList, params, expData) {
            const n_points = expData.tth.length;
            if (n_points === 0) return new Map();

            const peak_profiles = new Array(hklList.length);
            const total_profile_sum = new Array(n_points).fill(0);

            // 1. Pre-calculate the theoretical shape (profile) for every peak
            hklList.forEach((peak, j) => {
                const current_peak_profile = new Array(n_points).fill(0);
                if (!peak.tth) {
                    peak_profiles[j] = current_peak_profile;
                    return;
                }
                
                const basePos = peak.tth + params.zeroShift;
                const shift = calculatePeakShift(basePos, params);
                const peakPos = basePos + shift;
                const { gamma_G, gamma_L } = calculateProfileWidths(basePos, peak, params);

                const window = CALCULATION_WINDOW_MULTIPLIER * Math.max(0.01, gamma_G + gamma_L);
                const min_tth = peakPos - window;
                const max_tth = peakPos + window;

                let startIndex = 0;
                while(startIndex < n_points && expData.tth[startIndex] < min_tth) startIndex++;

                for (let i = startIndex; i < n_points; i++) {
                    const current_tth = expData.tth[i];
                    if (current_tth > max_tth) break;
                    
                    const profile_val = pseudoVoigt(current_tth, peakPos, basePos, gamma_G, gamma_L, params);
                    if (profile_val > PEAK_HEIGHT_CUTOFF) {
                        current_peak_profile[i] = profile_val;
                        total_profile_sum[i] += profile_val;
                    }
                }
                peak_profiles[j] = current_peak_profile;
            });

            // 2. Partition the experimental intensity and integrate
            const finalBkg = calculateTotalBackground(expData.tth, params);
            const i_obs_map = new Map();

            for (let i = 1; i < n_points; i++) {
                const step_width = expData.tth[i] - expData.tth[i-1];
                const prev_y_obs_net = expData.intensity[i-1] - finalBkg[i-1];
                const current_y_obs_net = expData.intensity[i] - finalBkg[i];

                hklList.forEach((peak, j) => {
                    const hkl_string = peak.hkl_list[0];
                    if (!i_obs_map.has(hkl_string)) {
                        i_obs_map.set(hkl_string, 0);
                    }

                    const prev_fraction = total_profile_sum[i-1] > 1e-9 ? peak_profiles[j][i-1] / total_profile_sum[i-1] : 0;
                    const current_fraction = total_profile_sum[i] > 1e-9 ? peak_profiles[j][i] / total_profile_sum[i] : 0;
                    
                    const prev_partitioned_I = prev_y_obs_net * prev_fraction;
                    const current_partitioned_I = current_y_obs_net * current_fraction;
                    
                    const trapezoid_area = (prev_partitioned_I + current_partitioned_I) / 2 * step_width;
                    if (trapezoid_area > 0) {
                        i_obs_map.set(hkl_string, i_obs_map.get(hkl_string) + trapezoid_area);
                    }
                });
            }
            return i_obs_map;
        }

        function generateReportContent(format = 'summary') {
            if (!fitResults || !fitResults.params || !workingData.isValid) {
                return "Error: Fit results are not available.";
            }

            const now = new Date();
            const { params: finalParams, stats, fitFlags, hklList, algorithm, refinementMode } = fitResults;
            const mainScaleFactor = stats.scaleFactor || 1.0;
            
            const formatLine = (cols, widths) => {
                return cols.map((col, i) => (col || '-').padEnd(widths[i])).join(' ');
            };

            const modeName = refinementMode === 'pawley' ? 'Pawley' : 'Le Bail';
            const header = [
                `${modeName} Refinement Report`,
                '========================================================================',
                '',
                `Powder5, version 08102025`,
                `https://nitad54448.github.io/Enseignement/powder5_en_cours.html`,
                `Report Generated: ${now.toLocaleString()}`,
                `Data File: ${controls.fileName.textContent}`,
                ''
            ];

            const algorithmNames = {
                lm: 'Levenberg-Marquardt',
                sa: 'Simulated Annealing',
                pt: 'Parallel Tempering'
            };
            const algorithmName = algorithmNames[algorithm] || 'Unknown';

            const profileName = finalParams.profileType === "4" ? "Simple pVoigt" : "TCH w/ Anisotropy";
            const selectedSg = spaceGroups.find(sg => sg.number === parseInt(controls.spaceGroupSelect.value, 10));
            const spaceGroupName = selectedSg ? `${selectedSg.number} – ${selectedSg.name}` : 'N/A';
            
            const statsSection = [
                '--- Refinement Statistics ---',
                `Rp (%):       ${stats.r_p.toFixed(3)}`,
                `Rwp (%):      ${stats.rwp.toFixed(3)}`,
                `χ² (GOF):     ${stats.chi2.toFixed(3)}`,
                `Algorithm:    ${algorithmName}`,
                `Refinement:   ${modeName}`,
                `Profile:      ${profileName} (#${finalParams.profileType})`,
                `Space Group:  ${spaceGroupName}`,
                ''
            ];

                        let whAnalysisSection = [];
            // This analysis is only meaningful for the TCH profile and pawley.
            if (finalParams.profileType == "3" && refinementMode === 'pawley') { 
                const whResults = calculateWilliamsonHall(finalParams, hklList);
                if (whResults) {
                    whAnalysisSection.push(
                        '--- Williamson-Hall Size/Strain Analysis ---',
                        `Apparent Crystallite Size (nm): ${whResults.size_nm.toFixed(0)}`,
                        `Apparent Microstrain (%):      ${whResults.strain_percent.toFixed(3)}`,
                        `Linear Fit R²:                 ${whResults.r_squared.toFixed(5)}`,
                        ''
                    );
                }
            }



            let esds = {};
            let esdWarning = null;
            if (fitResults.algorithm === 'lm' && fitResults.JtJ && fitResults.paramMapping) {
                const P = fitResults.paramMapping.length;
                const N = workingData.intensity.length;
                if (N > P && fitResults.ss_res !== undefined) {
                    const reduced_chi_sq = fitResults.ss_res / (N - P);
                    const cov_matrix = matrixInverse(fitResults.JtJ);
                    if (cov_matrix) {
                        fitResults.paramMapping.forEach((p_map, i) => {
                            if (cov_matrix[i] && cov_matrix[i][i] !== undefined) {
                                esds[p_map.name] = Math.sqrt(Math.abs(reduced_chi_sq * cov_matrix[i][i])) * p_map.scale;
                            }
                        });
                    } else { esdWarning = 'Matrix inversion failed (parameter correlation).'; }
                } else { esdWarning = "N <= P, cannot calculate reliable errors."; }
            } else if (fitResults.algorithm !== 'lm') { 
                esdWarning = "ESDs only available for Levenberg-Marquardt."; 
            }

            const paramWidths = [24, 18, 10, 18];
            const paramHeader = formatLine(['Parameter', 'Value', 'Fitted', 'ESD'], paramWidths);
            const paramLines = [];
            const paramGroups = {};
            paramGroups['Structural & Instrumental'] = [ { name: 'a (Å)', value: finalParams.a, flag: fitFlags.a, esd: 'a' }, { name: 'b (Å)', value: finalParams.b, flag: fitFlags.b, esd: 'b' }, { name: 'c (Å)', value: finalParams.c, flag: fitFlags.c, esd: 'c' }, { name: 'alpha (°)', value: finalParams.alpha, flag: fitFlags.alpha, esd: 'alpha' }, { name: 'beta (°)', value: finalParams.beta, flag: fitFlags.beta, esd: 'beta' }, { name: 'gamma (°)', value: finalParams.gamma, flag: fitFlags.gamma, esd: 'gamma' }, { name: 'Radiation 1 (Å)', value: finalParams.lambda }, { name: 'Radiation 2 (Å)', value: finalParams.lambda2 }, { name: 'Ratio (I2/I1)', value: finalParams.ratio }, { name: 'Zero Shift (°)', value: finalParams.zeroShift, flag: fitFlags.zeroShift, esd: 'zeroShift' }, { name: '2theta Min (°)', value: parseFloat(controls.tthMinSlider.value) }, { name: '2theta Max (°)', value: parseFloat(controls.tthMaxSlider.value) }];
            paramGroups['Profile Parameters'] = [];
            paramGroups['Background Parameters'] = [];
            if (finalParams.profileType === "4") { paramGroups['Profile Parameters'].push(...[ { name: 'GU', value: finalParams.GU, flag: fitFlags.GU, esd: 'GU' }, { name: 'GV', value: finalParams.GV, flag: fitFlags.GV, esd: 'GV' }, { name: 'GW', value: finalParams.GW, flag: fitFlags.GW, esd: 'GW' }, { name: 'GP', value: finalParams.GP, flag: fitFlags.GP, esd: 'GP' }, { name: 'LX', value: finalParams.LX, flag: fitFlags.LX, esd: 'LX' }, { name: 'eta (Mixing)', value: finalParams.eta, flag: fitFlags.eta, esd: 'eta' }, { name: 'shft (Displ.)', value: finalParams.shft, flag: fitFlags.shft, esd: 'shft' }, { name: 'trns (Transp.)', value: finalParams.trns, flag: fitFlags.trns, esd: 'trns' } ]); } else { paramGroups['Profile Parameters'].push(...[ { name: 'U', value: finalParams.U, flag: fitFlags.U, esd: 'U' }, { name: 'V', value: finalParams.V, flag: fitFlags.V, esd: 'V' }, { name: 'W', value: finalParams.W, flag: fitFlags.W, esd: 'W' }, { name: 'X', value: finalParams.X, flag: fitFlags.X, esd: 'X' }, { name: 'Y', value: finalParams.Y, flag: fitFlags.Y, esd: 'Y' }, { name: 'S/L (Asymm)', value: finalParams.SL, flag: fitFlags.SL, esd: 'SL' }, { name: 'H/L (Asymm)', value: finalParams.HL, flag: fitFlags.HL, esd: 'HL' } ]); if (finalParams.profileType === "3") { paramGroups['Profile Parameters'].push(...[ { name: 'S400', value: finalParams.S400, flag: fitFlags.S400, esd: 'S400' }, { name: 'S040', value: finalParams.S040, flag: fitFlags.S040, esd: 'S040' }, { name: 'S004', value: finalParams.S004, flag: fitFlags.S004, esd: 'S004' }, { name: 'S220', value: finalParams.S220, flag: fitFlags.S220, esd: 'S220' }, { name: 'S202', value: finalParams.S202, flag: fitFlags.S202, esd: 'S202' }, { name: 'S022', value: finalParams.S022, flag: fitFlags.S022, esd: 'S022' } ]); } }
            for (let i = 0; i < 6; i++) { paramGroups['Background Parameters'].push({ name: `B${i}`, value: finalParams[`B${i}`], flag: fitFlags[`B${i}`], esd: `B${i}` }); }
            paramGroups['Background Parameters'].push(...[ { name: 'Hump Height', value: finalParams.hump_H, flag: fitFlags.hump_H, esd: 'hump_H' }, { name: 'Hump Position', value: finalParams.hump_P, flag: fitFlags.hump_P, esd: 'hump_P' }, { name: 'Hump FWHM', value: finalParams.hump_W, flag: fitFlags.hump_W, esd: 'hump_W' } ]);
            
            for (const groupName in paramGroups) {
                paramLines.push(`--- ${groupName} ---`, paramHeader, '-'.repeat(paramHeader.length));
                paramGroups[groupName].forEach(p => {
                    if (p.value != null && !isNaN(p.value)) {
                        const valStr = p.value.toExponential(6);
                        const fitStr = (p.flag === undefined) ? '' : (p.flag ? 'Yes' : 'No');
                        const esdValue = esds[p.esd];
                        const esdStr = (p.flag && typeof esdValue === 'number' && isFinite(esdValue)) ? `(${esdValue.toExponential(2)})` : '';
                        paramLines.push(formatLine([p.name, valStr, fitStr, esdStr], paramWidths));
                    }
                });
                paramLines.push('');
            }
            if (esdWarning) paramLines.push(`NOTE: ${esdWarning}`);

            const reflectionsSection = [];
            if (hklList && hklList.length > 0) {
                const i_calc_header = refinementMode === 'pawley' ? 'I_refined' : 'I_calc';
                const reflWidths = [15, 18, 18, 18, 18];
                const reflHeader = formatLine(['h,k,l', '2th_corr (°)', i_calc_header, 'ESD(I)', 'I_obs'], reflWidths);
                reflectionsSection.push('', '--- Reflections List (Integrated Intensities) ---', reflHeader, '-'.repeat(reflHeader.length));
                
                // *** NEW: Calculate all I_obs values at once using the intensity partitioning method ***
                const i_obs_map = calculateAllObservedIntensities(hklList, finalParams, workingData);

                hklList.filter(hkl => hkl.tth && hkl.tth >= workingData.tth[0] && hkl.tth <= workingData.tth[workingData.tth.length - 1])
                    .forEach(hkl => {
                        const peakShift = calculatePeakShift(hkl.tth, finalParams);
                        const tthCorr = hkl.tth + finalParams.zeroShift + peakShift;
                        
                        // *** NEW: Look up the correctly partitioned I_obs value ***
                        const i_obs = i_obs_map.get(hkl.hkl_list[0]) || 0;
                        
                        const scaled_i_calc_area = hkl.intensity * mainScaleFactor;
                        
                        const hkl_name = `I_(${hkl.h_orig},${hkl.k_orig},${hkl.l_orig})`;
                        const esd_I_val = esds[hkl_name];
                        const esd_I_str = (refinementMode === 'pawley' && typeof esd_I_val === 'number' && isFinite(esd_I_val))
                            ? `(${esd_I_val.toFixed(1)})`
                            : '';

                        if (i_obs > 0.1 || scaled_i_calc_area > 0.1) {
                            reflectionsSection.push(formatLine([
                                hkl.hkl_list[0], tthCorr.toFixed(4), scaled_i_calc_area.toFixed(1), esd_I_str, i_obs.toFixed(1)
                            ], reflWidths));
                        }
                    });
            }

            const dataSection = [];
            if (format === 'full') {
                dataSection.push('', '--- Point-by-Point Intensity Data (Fitted Range Only) ---',
                    ['2theta', 'I_obs', 'I_calc', 'Difference'].join('\t'),
                    '-----------------------------------------------------');
                
                const finalBkg = calculateTotalBackground(workingData.tth, finalParams);
                const finalNetPattern = calculatePattern(workingData.tth, hklList, finalParams);
                for (let i = 0; i < workingData.tth.length; i++) {
                    const i_calc = (finalNetPattern[i] * mainScaleFactor) + finalBkg[i];
                    dataSection.push([
                        workingData.tth[i].toFixed(4),
                        workingData.intensity[i].toFixed(2),
                        i_calc.toFixed(2),
                        (workingData.intensity[i] - i_calc).toFixed(2)
                    ].join('\t'));
                }
            }
            
            return [...header, ...statsSection, ...whAnalysisSection, ...paramLines, ...reflectionsSection, ...dataSection].join('\n');
        }

        // --- EVENT LISTENERS, 8 oct, version 1.0.3

        document.getElementById('le-bail-button').addEventListener('click', () => runFit('le-bail'));
        document.getElementById('pawley-button').addEventListener('click', () => runFit('pawley'));


        // Helper function to handle a full HKL list recalculation, including cache invalidation.
        const handleFullHklRecalculation = () => {
            if (!mainChart || isFitting) return;
            invalidateHklCache();
            generateMasterHklList();
            rescalePlot(false);
            mainChart.update('none');
        };

        // Create a debounced version of the handler for frequent input events.
        const debouncedHklRecalculation = debounce(handleFullHklRecalculation, 400); // 400ms delay

        const debouncedBackgroundUpdate = debounce(updateBackgroundForPreview, 350);


        // Helper function for simple preview updates that DON'T require HKL recalculation.
        const handleSimplePreviewUpdate = () => {
            if (!mainChart || isFitting) return;
            updatePreviewPattern();
            rescalePlot(false);
            mainChart.update('none');
        };
        //1.0.4
        const debouncedSimplePreviewUpdate = debounce(handleSimplePreviewUpdate, 350); 

        // --- Attach Listeners to Specific Controls ---
        // 1. Triggers for FULL Recalculation (these invalidate the cache)
        // These are for single-click events, so they use the direct handler.
        document.getElementById('bravais-lattice').addEventListener('change', handleFullHklRecalculation);
        document.getElementById('space-group-select').addEventListener('change', handleFullHklRecalculation);
        document.getElementById('wavelength').addEventListener('input', handleFullHklRecalculation);
        
        // Use event delegation for dynamically created lattice parameter inputs.
        // it now calls the debounced handler.
        document.getElementById('lattice-parameters-container').addEventListener('input', (event) => {
            if (event.target && event.target.type === 'number' && event.target.id.startsWith('lattice-param-')) {
                debouncedHklRecalculation();
            }
        });
        
        // 2. Triggers for SIMPLE Preview Update (these use the cached HKLs)
const controlsPanel = document.getElementById('controls-panel');
controlsPanel.querySelectorAll('#simple-pvoigt-params-container input, #anisotropy-params-container input').forEach(el => {
    // *** CHANGE IS HERE ***
    // We now call the debounced function for all continuous input events
    // from sliders and number fields within the profile tabs.
    el.addEventListener('input', debouncedSimplePreviewUpdate);
});

// The profile function dropdown should update immediately on change, not after a delay.
// This is a single 'change' event, not a continuous 'input' event, so no debounce is needed.
document.getElementById('profile-function-select').addEventListener('change', handleSimplePreviewUpdate);
 

        
        document.getElementById('zero-shift').addEventListener('input', handleSimplePreviewUpdate);
        document.getElementById('fit-zero-shift').addEventListener('change', handleSimplePreviewUpdate);

        // 3. Background parameters have their own dedicated updater function
        document.getElementById('tab-panel-background').addEventListener('input', (e) => {
            if (e.target.id === 'show-anchors-checkbox') return;
            debouncedBackgroundUpdate();
        });

        // 4. Main File Input: Clears the ENTIRE cache and sets up the application
        controls.fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (evt) => {
                try {
                    const parsedData = detectAndParseFile(file.name, evt.target.result);
                    if (!parsedData || parsedData.tth.length === 0) throw new Error("No valid data points parsed.");

                    // *** CLEAR THE ENTIRE CACHE ON NEW FILE LOAD ***
                    hklIndexCache = {}; 
                    
                    if (parsedData.wavelength) controls.wavelength.value = parsedData.wavelength.toFixed(5);
                    
                    // Convert parsed data to Float64Arrays for performance
                    fullExperimentalData = {
                        tth: new Float64Array(parsedData.tth),
                        intensity: new Float64Array(parsedData.intensity)
                    };
                    lastRawDifference = []; // This can remain a standard array
                    calculatedBackground = new Float64Array(fullExperimentalData.tth.length);
                    
                    workingDataCache.isValid = false;
                    
                    controls.fileName.textContent = file.name;
                    controls.placeholder.style.display = 'none';
                    controls.resultsContainer.style.display = 'flex';
                    
                    document.getElementById('le-bail-button').disabled = false;
                    document.getElementById('pawley-button').disabled = false;
                    
                    initializeChart();
                    
                    const min = fullExperimentalData.tth[0];
                    const max = fullExperimentalData.tth[fullExperimentalData.tth.length - 1];
                    const step = (max - min) / 2000;

                    [controls.tthMinSlider, controls.tthMaxSlider].forEach(slider => {
                        slider.min = min;
                        slider.max = max;
                        slider.step = step;
                        slider.disabled = false;
                    });
                    
                    controls.tthMinSlider.value = min;
                    controls.tthMaxSlider.value = max;
                    controls.tthMinValue.textContent = min.toFixed(2);
                    controls.tthMaxValue.textContent = max.toFixed(2);
                    
                    const estimatedBgParams = estimateBackgroundParameters(fullExperimentalData.tth, fullExperimentalData.intensity);
                    if (estimatedBgParams) {
                        for (let i = 0; i < 5; i++) {
                            const input = document.getElementById(`param-b${i}`);
                            if (input && estimatedBgParams[`B${i}`] !== undefined) {
                                input.value = estimatedBgParams[`B${i}`].toFixed(2);
                            }
                        }
                    }

                    updateWorkingData();
                    updatePlotRange(true);
                    generateMasterHklList();      
                    updateBackgroundForPreview();
                    rescalePlot(false); 
                    mainChart.update('none');

                } catch (error) {
                    alert(`Error reading file: ${error.message}`);
                    console.error(error);
                }
            };
            reader.onerror = () => alert('Error reading file.');
            reader.readAsText(file);
        });

        // 5. General UI Listeners (not related to HKL caching)
        document.querySelector('.tab-buttons').addEventListener('click', (e) => { 
            const clickedTab = e.target.closest('.tab-btn'); 
            if (clickedTab && !clickedTab.disabled) { 
                e.currentTarget.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active')); 
                clickedTab.classList.add('active'); 
                document.querySelectorAll('.tab-content-panel').forEach(panel => panel.classList.remove('active')); 
                document.getElementById(`tab-panel-${clickedTab.dataset.tab}`).classList.add('active'); 
            } 
        });
        
        const resizer = document.getElementById('drag-handle'); 
        const leftPanel = document.getElementById('controls-panel');
        resizer.addEventListener('mousedown', (e) => { 
            e.preventDefault(); 
            document.body.style.cursor = 'col-resize'; 
            const moveHandler = (moveEvent) => { 
                if (moveEvent.clientX > 350 && moveEvent.clientX < window.innerWidth - 350) 
                    leftPanel.style.width = `${moveEvent.clientX}px`; 
            }; 
            const upHandler = () => { 
                document.body.style.cursor = 'default'; 
                window.removeEventListener('mousemove', moveHandler); 
                window.removeEventListener('mouseup', upHandler); 
            }; 
            window.addEventListener('mousemove', moveHandler); 
            window.addEventListener('mouseup', upHandler); 
        });
        
        document.getElementById('anchor-points-list').addEventListener('input', handleAnchorListInteraction);
        document.getElementById('anchor-points-list').addEventListener('click', handleAnchorListInteraction);

        document.getElementById('show-anchors-checkbox').addEventListener('change', (e) => {
            if (mainChart) {
                const isVisible = e.target.checked;
                const anchorDataset = mainChart.data.datasets.find(d => d.label === 'Anchor Points');
                if (anchorDataset) {
                    anchorDataset.hidden = !isVisible;
                    mainChart.update('none');
                }
            }
        });

        controls.mainChartCanvas.addEventListener('click', e => {
            if (e.ctrlKey && mainChart) {
                e.preventDefault();
                e.stopPropagation();
                const currentYMin = mainChart.scales.y.min;
                const currentYMax = mainChart.scales.y.max;
                const rect = controls.mainChartCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const tthValue = mainChart.scales.x.getValueForPixel(x);
                const closestPoint = findClosestExperimentalPoint(tthValue);
                if (closestPoint) {
                    const isAlreadyAdded = backgroundAnchors.some(a => a.index === closestPoint.index);
                    if (!isAlreadyAdded) {
                        backgroundAnchors.push(closestPoint);
                        backgroundAnchors.sort((a, b) => a.tth - b.tth); 
                        renderAnchorList();
                        updateBackgroundForPreview();
                    }
                }
                mainChart.options.scales.y.min = currentYMin;
                mainChart.options.scales.y.max = currentYMax;
                mainChart.update('none');
            }
        });


        controls.iterationsSlider.addEventListener('input', () => controls.iterationsValue.textContent = controls.iterationsSlider.value);
        

        
controls.tthMinSlider.addEventListener('input', () => { 
    let minVal = parseFloat(controls.tthMinSlider.value); 
    let maxVal = parseFloat(controls.tthMaxSlider.value); 
    if (minVal >= maxVal) { 
        minVal = maxVal - parseFloat(controls.tthMinSlider.step); 
        controls.tthMinSlider.value = minVal; 
    } 
    controls.tthMinValue.textContent = minVal.toFixed(2); 

    redrawFitForNewRange();
});

controls.tthMaxSlider.addEventListener('input', () => { 
    let minVal = parseFloat(controls.tthMinSlider.value); 
    let maxVal = parseFloat(controls.tthMaxSlider.value); 
    if (maxVal <= minVal) { 
        maxVal = minVal + parseFloat(controls.tthMaxSlider.step); 
        controls.tthMaxSlider.value = maxVal; 
    } 
    controls.tthMaxValue.textContent = maxVal.toFixed(2); 

    redrawFitForNewRange();
});
        
controls.mainChartCanvas.addEventListener('wheel', e => {
    e.preventDefault();
    const chart = mainChart;
    if (!chart || !chart.chartArea) return;

    const { left, right, top, bottom } = chart.chartArea;
    const xPixel = e.offsetX;
    const yPixel = e.offsetY;
    
    // Zoom in = smaller range (factor < 1), zoom out = larger range (factor > 1)
    const zoomFactor = e.deltaY < 0 ? 0.9 : 1.1;

    // Helper function to perform anchored zoom on a specific axis
    const zoomOnAxis = (axisID, factor, focalPixel) => {
        const axis = chart.scales[axisID];
        if (!axis) return;

        // Get the data value directly under the mouse cursor
        const focalValue = axis.getValueForPixel(focalPixel);
        
        const currentRange = axis.max - axis.min;
        const newRange = currentRange * factor;
        
        // Determine where the mouse is proportionally on the current axis (from 0.0 to 1.0)
        const focalRatio = (focalValue - axis.min) / currentRange;
        
        // Calculate the new min and max to keep the focal point stationary
        const newMin = focalValue - (newRange * focalRatio);
        const newMax = newMin + newRange;
        
        // Apply the new limits directly to the chart options
        chart.options.scales[axisID].min = newMin;
        chart.options.scales[axisID].max = newMax;
    };

    // Determine which axis/axes to zoom based on cursor position
    if (yPixel > bottom) { // Zooming on X-axis
        zoomOnAxis('x', zoomFactor, xPixel);
    } else if (xPixel < left) { // Zooming on Y-axis
        zoomOnAxis('y', zoomFactor, yPixel);
    } else if (xPixel >= left && xPixel <= right && yPixel >= top && yPixel <= bottom) { // Zooming on both
        zoomOnAxis('x', zoomFactor, xPixel);
        zoomOnAxis('y', zoomFactor, yPixel);
    }
   
    chart.update('none');
    rescalePlot(false); 
});


//changé le 04 oct, version 2.3
controls.mainChartCanvas.addEventListener('contextmenu', e => {
    e.preventDefault();
    if (!mainChart) return;

    // 1. Manually reset the X-axis to the CURRENT SLIDER range
    mainChart.options.scales.x.min = parseFloat(controls.tthMinSlider.value); // Use .value
    mainChart.options.scales.x.max = parseFloat(controls.tthMaxSlider.value); // Use .value
    
    // 2. Manually reset the Y-axis using the original max value we stored
    const globalYMax = mainChart.options.globalYMax;
    mainChart.options.scales.y.max = globalYMax;
    mainChart.options.scales.y.min = -(globalYMax * 0.3); // Restore the default 30% space for the diff plot

    // 3. Update the chart to apply these new axis limits and redraw the difference plot
    mainChart.update('none');
    rescalePlot(false);
});


        controls.profileSelect.addEventListener('change', (e) => { const newProfile = e.target.value; saveProfileState(currentProfile); controls.simplePVoigtParamsContainer.classList.toggle('hidden', newProfile !== '4'); controls.anisotropyParamsContainer.classList.toggle('hidden', newProfile !== '3'); restoreProfileState(newProfile); currentProfile = newProfile; if (fullExperimentalData.tth.length > 0) updatePreviewPattern(); });
        
        // This now uses the new helper function
        controls.bravaisLattice.addEventListener('change', updateUIForSystemChange);
        
        controls.paramS400.addEventListener('input', updateStephensAnisotropyUI); controls.fitS400.addEventListener('change', updateStephensAnisotropyUI); controls.paramS220.addEventListener('input', updateStephensAnisotropyUI); controls.fitS220.addEventListener('change', updateStephensAnisotropyUI); controls.paramS202.addEventListener('input', updateStephensAnisotropyUI); controls.fitS202.addEventListener('change', updateStephensAnisotropyUI);


    controls.saveDataButton.addEventListener('click', () => {
    if (!fitResults) {
        showToast("Please run a refinement before saving data.", 'error');
        return;
    }
    const originalText = controls.saveDataButton.textContent;
    controls.saveDataButton.textContent = 'Saving...';
    controls.saveDataButton.disabled = true;
    try {
        const textContent = generateReportContent('full');
        const timestamp = new Date().toISOString().slice(0, 16).replace(/[-:]/g, '').replace('T', '_');
        
        // FIX: Determine the filename based on the refinement mode from the results
        const modeName = fitResults.refinementMode === 'pawley' ? 'Pawley' : 'LeBail';
        downloadTextFile(textContent, `${modeName}-Data-${timestamp}.txt`);

        showToast("Report saved successfully!", 'success');
    } catch (error) {
        console.error("Failed to save data:", error);
    } finally {
        controls.saveDataButton.textContent = 'Save Report';
        controls.saveDataButton.disabled = false;
    }
});


controls.reportButton.addEventListener('click', async () => {
    if (!fitResults) {
        alert("Cannot generate report: Fit results are missing.");
        return;
    }

    const originalText = controls.reportButton.textContent;
    controls.reportButton.textContent = 'Generating...';
    controls.reportButton.disabled = true;

    try {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
        const margin = 15;
        const contentWidth = doc.internal.pageSize.getWidth() - 2 * margin;
        let yPosition = 20;

        const summaryText = generateReportContent('summary');
        const pdfText = summaryText
            .replace(/χ²/g, 'Chi^2')
            .replace(/°/g, 'deg')
            .replace(/β/g, 'Beta');

        const lines = pdfText.split('\n');
        doc.setFont('Courier');

        for (const line of lines) {
            if (yPosition > doc.internal.pageSize.getHeight() - 20) {
                doc.addPage();
                yPosition = 20;
            }
            const isHeader = line.startsWith('---');
            const isTitle = line.includes('Refinement Report');
            let fontSize = 9;
            let fontStyle = 'normal';

            if (isTitle) {
                fontSize = 14;
                fontStyle = 'bold';
                yPosition += 6;
            } else if (isHeader) {
                fontSize = 10;
                fontStyle = 'bold';
                yPosition += 4;
            }
            
            doc.setFontSize(fontSize);
            doc.setFont(undefined, fontStyle);
            doc.text(line, margin, yPosition);
            yPosition += fontSize * 0.4;
        }

        doc.addPage();
        const chartCanvas = await html2canvas(controls.mainChartCanvas, { backgroundColor: '#ffffff', scale: 2 });
        const mainImgData = chartCanvas.toDataURL('image/png', 0.95);
        const mainImgProps = doc.getImageProperties(mainImgData);
        const mainImgHeight = Math.min((mainImgProps.height * contentWidth) / mainImgProps.width, 250); 
        doc.addImage(mainImgData, 'PNG', margin, 20, contentWidth, mainImgHeight);
        
        // FIX: Determine the filename based on the refinement mode from the results
        const { refinementMode } = fitResults;
        const modeName = refinementMode === 'pawley' ? 'Pawley' : 'LeBail';
        doc.save(`${modeName}-Report-${new Date().toISOString().slice(0, 10)}.pdf`);

    } catch (error) {
        alert(`An error occurred while generating the report: ${error.message}`);
    } finally {
        controls.reportButton.textContent = 'Generate PDF';
        if (fitResults) {
            controls.reportButton.disabled = false;
        }
    }
});

        updateUIForSystemChange();
    });

</script>


</body>
</html>