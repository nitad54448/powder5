<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Powder 5</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

        <script src="rules_spaceGroups.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.3/math.min.js"></script>
    <style>
        :root {
            --system-blue: #007AFF;
            --system-gray-1: #8E8E93;
            --system-gray-2: #AEAEB2;
            --system-gray-3: #C7C7CC;
            --system-gray-4: #D1D1D6;
            --system-gray-5: #E5E5EA;
            --system-gray-6: #F2F2F7;
            --system-background: #FFFFFF;
            --system-grouped-background: #F2F2F7;
            --system-material-thin: rgba(255, 255, 255, 0.7);
            --system-material-regular: rgba(255, 255, 255, 0.8);
            --system-label: #000000;
            --system-secondary-label: rgba(60, 60, 67, 0.6);
            --system-tertiary-label: rgba(60, 60, 67, 0.3);
            --system-separator: rgba(60, 60, 67, 0.29);
            --system-fill: rgba(120, 120, 128, 0.2);
            --system-secondary-fill: rgba(120, 120, 128, 0.16);
            --system-shadow: rgba(0, 0, 0, 0.1);
        }

        #fit-button { width: 100%; }

        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif; 
            margin: 0; 
            background-color: var(--system-grouped-background); 
            display: flex; 
            flex-direction: column; 
            height: 100vh; 
            overflow: hidden; 
            color: var(--system-label);
        }
        #app-container { 
            display: flex; 
            width: 100%; 
            flex-grow: 1; 
            min-height: 0; 
            background-color: var(--system-grouped-background);
        }
        
        #controls-panel { 
            width: 380px; 
            min-width: 320px; 
            max-width: 500px; 
            flex-shrink: 0; 
            padding: 16px; 
            background-color: var(--system-background); 
            border-right: 1px solid var(--system-separator); 
            display: flex; 
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            z-index: 20;
            box-shadow: 0 0 20px rgba(0,0,0,0.05);
            border-radius: 0 12px 12px 0;
        }
        
        #drag-handle { 
            width: 6px; 
            cursor: col-resize; 
            background-color: var(--system-gray-5); 
            flex-shrink: 0; 
            transition: background-color 0.2s; 
        }
        #drag-handle:hover, #drag-handle:active { 
            background-color: var(--system-blue); 
        }
        
        #results-area { 
            flex-grow: 1; 
            position: relative; 
            background-color: var(--system-background); 
            min-width: 0; 
            display: flex; 
            flex-direction: column; 
            padding: 20px; 
            z-index: 10;
            border-radius: 12px 0 0 12px;
            margin: 8px 8px 8px 0;
            box-shadow: 0 4px 20px rgba(0,0,0,0.05);
        }
        
        .control-group { 
            padding: 16px; 
            margin-bottom: 16px;
            background-color: var(--system-background);
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .control-group:first-child { 
            padding-top: 0; 
            margin-top: 0;
        }
        .control-label { 
            display: block; 
            font-weight: 500; 
            color: var(--system-secondary-label); 
            font-size: 13px; 
            margin-bottom: 6px;
        }
        
        .control-input, .control-select { 
            width: 100%; 
            background-color: var(--system-gray-6); 
            border: 1px solid var(--system-gray-4); 
            color: var(--system-label); 
            border-radius: 8px; 
            padding: 10px 14px; 
            transition: all 0.2s ease; 
            box-sizing: border-box;
            font-size: 15px;
            height: 40px;
        }
        .control-input:focus, .control-select:focus { 
            outline: none; 
            border-color: var(--system-blue); 
            box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.2); 
        }
        .control-input:disabled { 
            background-color: var(--system-gray-6);
            color: var(--system-tertiary-label);
            cursor: not-allowed; 
        }
        
        .btn { 
            padding: 12px 20px; 
            border-radius: 10px; 
            font-weight: 600; 
            transition: all 0.2s; 
            cursor: pointer; 
            border: none; 
            text-align: center; 
            font-size: 15px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-primary { 
            background-color: var(--system-blue); 
            color: white; 
            box-shadow: 0 1px 3px rgba(0, 122, 255, 0.3);
        }
        .btn-primary:hover:not(:disabled) { 
            background-color: #006ee6; 
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 122, 255, 0.3);
        }
        .btn-primary:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 122, 255, 0.3);
        }

        .btn-secondary { 
    background-color: var(--system-gray-5); /* Darker background */
    color: var(--system-label); 
    border: 1px solid var(--system-gray-4); /* Add solid border */
    box-shadow: none; /* Remove shadow for a cleaner look */
}

.btn-secondary:hover:not(:disabled) { 
    background-color: var(--system-blue);    /* Change background to blue */
    color: white;                           /* Change text to white for contrast */
    border-color: var(--system-blue);       /* Make the border blue as well */
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0, 122, 255, 0.3); /* Optional: Add a blue glow like the primary buttons */
}

        .btn:disabled { 
            background-color: var(--system-gray-6); 
            color: var(--system-tertiary-label);
            cursor: not-allowed; 
            opacity: 0.7; 
            box-shadow: none;
        }
        
       .file-input-label { 
    display: block; 
    padding: 12px 16px; 
    background-color: var(--system-gray-5); /* Match the secondary buttons */
    color: var(--system-label); 
    border-radius: 10px; 
    text-align: center; 
    cursor: pointer; 
    transition: all 0.2s;
    font-weight: 500;
    border: 1px solid var(--system-gray-4); /* Change from dashed to solid */
}

.file-input-label:hover { 
    background-color: var(--system-blue);    /* Change background to blue */
    color: white;                           /* Change text to white */
    border-color: var(--system-blue);       /* Make the border blue */
}

        
        .results-grid { 
            display: grid; 
            grid-template-columns: repeat(3, minmax(80px, 1fr)); 
            gap: 12px; 
        }
        .result-card { 
            background-color: var(--system-gray-6); 
            padding: 12px; 
            border-radius: 10px; 
            text-align: center; 
            transition: all 0.2s; 
        }
        .result-card-label { 
            font-size: 12px; 
            color: var(--system-secondary-label); 
            margin-bottom: 4px;
        }
        .result-card-value { 
            font-size: 18px; 
            font-weight: 700; 
            color: var(--system-label); 
        }
        
        .fit-checkbox { 
            -webkit-appearance: none; 
            appearance: none; 
            background-color: var(--system-gray-6); 
            width: 22px; 
            height: 22px; 
            border: 1px solid var(--system-gray-4); 
            border-radius: 6px; 
            cursor: pointer; 
            display: inline-block; 
            position: relative; 
            transition: all 0.2s;
        }
        .fit-checkbox:checked { 
            background-color: var(--system-blue); 
            border-color: var(--system-blue); 
        }
        .fit-checkbox:checked::after { 
            content: '✓'; 
            color: white; 
            position: absolute; 
            left: 50%; 
            top: 50%; 
            transform: translate(-50%, -50%); 
            font-size: 14px; 
            font-weight: bold;
        }
        
        .tab-buttons { 
            display: flex; 
            background-color: var(--system-gray-6);
            border-radius: 10px;
            padding: 4px;
            margin-bottom: 16px;
        }
        .tab-btn { 
            flex: 1; 
            padding: 8px 12px; 
            background: none; 
            border: none; 
            color: var(--system-secondary-label); 
            font-weight: 500; 
            cursor: pointer; 
            border-radius: 8px;
            transition: all 0.2s; 
            font-size: 14px; 
        }
        .tab-btn:hover { 
            color: var(--system-label); 
            background-color: rgba(255,255,255,0.5);
        }
        .tab-btn.active { 
            color: var(--system-blue); 
            background-color: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .tab-content-panels { 
            position: relative; 
            padding-top: 0; 
        }
        .tab-content-panel { 
            display: none; 
            flex-direction: column; 
        }
        .tab-content-panel.active { 
            display: flex; 
        }

        .tab-content-panel > .control-group {
            border-top: none;
        }

        #lattice-parameters-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .bottom-actions { 
            margin-top: auto; 
            padding-top: 16px;
        }

        .slider-value-track { 
            display: grid; 
            grid-template-columns: 1fr; 
            grid-template-rows: 1fr; 
            align-items: center; 
        }
        .slider-value-track > * { 
            grid-column: 1; 
            grid-row: 1; 
        }
        .slider-value-display { 
            text-align: center; 
            color: var(--system-secondary-label); 
            font-weight: 500; 
            font-size: 13px; 
            pointer-events: none; 
        }
        input[type="range"].custom-slider { 
            -webkit-appearance: none; 
            appearance: none; 
            width: 100%; 
            height: 36px; 
            background: var(--system-gray-6); 
            border-radius: 6px; 
            outline: none; 
            padding: 0; 
            margin: 0; 
        }
        input[type="range"].custom-slider::-webkit-slider-thumb { 
            -webkit-appearance: none; 
            appearance: none; 
            width: 22px; 
            height: 22px; 
            background: var(--system-blue); 
            border-radius: 50%; 
            cursor: pointer; 
            border: 3px solid white; 
            box-sizing: border-box; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        input[type="range"].custom-slider::-moz-range-thumb { 
            width: 22px; 
            height: 22px; 
            background: var(--system-blue); 
            border-radius: 50%; 
            cursor: pointer; 
            border: 3px solid white; 
            box-sizing: border-box; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        input[type="range"].custom-slider:disabled { 
            background: var(--system-gray-6); 
        }
        input[type="range"].custom-slider:disabled::-webkit-slider-thumb { 
            background: var(--system-gray-3); 
        }
        input[type="range"].custom-slider:disabled::-moz-range-thumb { 
            background: var(--system-gray-3); 
        }

        /* --- UNIFIED UI & SPACING STYLES --- */
        #tab-panel-sample > .control-group, #tab-panel-background > .control-group {
            display: flex; 
            flex-direction: column; 
            gap: 16px; 
        } 
        
        /* Add these styles anywhere inside the <style> tag */
        .anchor-point-item {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
            padding: 8px;
            background-color: var(--system-gray-6);
            border-radius: 8px;
        }

        .anchor-point-item span {
    font-size: 15px;
    padding: 0 4px;
    text-align: right;
}

        .anchor-point-item .control-input {
            height: 36px;
            padding: 8px 12px;
        }

        .anchor-remove-btn {
            background-color: transparent;
            border: none;
            color: var(--system-gray-1);
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            padding: 0 8px;
            line-height: 1;
            transition: color 0.2s;
        }
        .anchor-remove-btn:hover {
            color: #ff453a; /* systemRed */
        }

        .control-group h2, .profile-section-header {
            margin: 0 0 16px 0; 
            padding-bottom: 12px; 
            border-bottom: 1px solid var(--system-separator);
            color: var(--system-label); 
            font-size: 17px; 
            font-weight: 600;
        }

.profile-controls-container + .profile-controls-container {
    margin-top: 24px;
}

        .parameter-grid-3col, .parameter-grid-2col, .slider-group, .form-row {
            display: grid; 
            gap: 12px; 
            align-items: center;
        }
        .parameter-grid-3col { 
            grid-template-columns: minmax(100px, auto) 1fr auto; 
        }
        .parameter-grid-2col, .slider-group, .form-row { 
            grid-template-columns: minmax(100px, auto) 1fr; 
        }
        
        .parameter-grid-3col > .control-label, .parameter-grid-2col > .control-label,
        .slider-group > .control-label, .form-row > .control-label {
            grid-column: 1; 
            margin-bottom: 0;
        }
        
        .parameter-grid-2col > *:not(label), .slider-group > .slider-value-track,
        .form-row > *:not(label) { 
            grid-column: 2; 
        }
        .parameter-grid-3col > .control-input { 
            grid-column: 2; 
        }
        .parameter-grid-3col > .fit-checkbox { 
            grid-column: 3; 
            justify-self: center; 
        }

        .profile-controls-container {
            display: grid; 
            grid-template-columns: minmax(100px, auto) 1fr auto;
            gap: 16px 12px; 
            align-items: center;
        }
        .profile-controls-container > .control-label { 
            grid-column: 1; 
            text-align: left; 
            margin-bottom: 0; 
        }
        .profile-controls-container > input[type="number"] { 
            grid-column: 2; 
        }
        .profile-controls-container > input[type="checkbox"] { 
            grid-column: 3; 
            justify-self: center; 
        }
        .profile-controls-container > .profile-section-header { 
            grid-column: 1 / -1; 
        }
        

        /* CSS for Toast Notifications */
        #toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
            display: flex;
            flex-direction: column-reverse;
            gap: 10px;
            pointer-events: none; /* Allow clicking through the container */
        }
        .toast {
            padding: 12px 20px;
            border-radius: 8px;
            color: white;
            font-size: 15px;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            opacity: 0;
            transform: translateX(100%); /* Start off-screen to the right */
            transition: all 0.4s cubic-bezier(0.21, 1.02, 0.73, 1); /* Smooth slide and fade */
        }
        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }
        .toast.error {
            background-color: #ff453a; /* systemRed */
        }
        .toast.success {
            background-color: #34c759; /* systemGreen */
        }


        
        .bottom-actions > .control-group {
            display: grid; 
            grid-template-columns: minmax(100px, auto) 1fr;
            gap: 16px; 
            align-items: center; 
            border: none; 
            padding: 0;
        }
        .bottom-actions > .control-group > h2,
        .bottom-actions > .control-group > .slider-group,
        .bottom-actions > .control-group > #progress-bar-container,
        .bottom-actions > .control-group > .results-grid {
            grid-column: 1 / -1;
        }
        .bottom-actions > .control-group > label[for="algorithm-select"] {
            grid-column: 1; 
            margin-bottom: 0;
        }
        .bottom-actions > .control-group > #algorithm-select {
            grid-column: 2; 
            margin-bottom: 0;
        }
        
        .help-tooltip-container { 
            position: relative; 
            display: inline-block; 
        }
.help-icon { 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    width: 24px; 
    height: 24px; 
    background-color: #4a5568; /* Darker background for icon */
    color: white; /* White question mark */
    border-radius: 50%; 
    font-weight: 500; 
    font-size: 14px; 
    cursor: help; 
    transition: all 0.2s; 
}
.help-icon:hover { 
    background-color: #2d3748; /* Even darker on hover */
    color: white;
}
        
.tooltip-content {
    visibility: hidden; 
    opacity: 0; 
    width: 280px;
    background-color: #2d3748; /* Darker background for better contrast */
    color: #f7fafc; /* Light text color */
    text-align: left;
    border-radius: 10px; 
    padding: 16px;
    position: absolute; 
    z-index: 1001;
    top: -15px;
    right: 115%;
    margin-right: 10px;
    transition: opacity 0.3s; 
    font-size: 15px; 
    border: 1px solid #4a5568; /* Darker border */
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); /* Stronger shadow */
}
.tooltip-content::after {
    content: ""; 
    position: absolute;
    top: 20px;
    left: 100%;
    margin-top: -5px; 
    border-width: 5px; 
    border-style: solid;
    border-color: transparent transparent transparent #2d3748; /* Match tooltip background */
}

.tooltip-content.visible {
    visibility: visible;
    opacity: 1;
}

.tooltip-content h4 { 
    color: #fff; /* White for headings */
    font-size: 15px; 
    margin-top: 0; 
    margin-bottom: 8px; 
    font-weight: 600; 
}
.tooltip-content p { 
    margin-top: 0; 
    margin-bottom: 6px; 
    line-height: 1.4; 
    color: #e2e8f0; /* Lighter gray for paragraph text */
}
.tooltip-content hr { 
    border: none; 
    border-top: 1px solid #4a5568; /* Darker separator */
    margin: 12px 0; 
}
        .hidden { 
            display: none !important; 
        }

        #controls-panel::-webkit-scrollbar { 
            width: 5px; 
        }
        #controls-panel::-webkit-scrollbar-track { 
            background: transparent; 
        }
        #controls-panel::-webkit-scrollbar-thumb { 
            background: var(--system-gray-4); 
            border-radius: 3px; 
        }
        #controls-panel::-webkit-scrollbar-thumb:hover { 
            background: var(--system-gray-3); 
        }

        /* Apple-style progress bar */
        #progress-bar-container {
            height: 5px;
            background-color: var(--system-gray-5);
            border-radius: 3px;
            overflow: hidden;
        }
        #progress-bar {
            height: 100%;
            background-color: var(--system-blue);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        /* Apple-style placeholder */
        #placeholder {
            background-color: var(--system-background);
            border-radius: 12px;
            padding: 40px;
        }
        #placeholder svg {
            color: var(--system-gray-3);
        }

        /* Subtle animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .control-group {
            animation: fadeIn 0.3s ease;
        }

        /* Improved focus states for accessibility */
        .btn:focus-visible,
        .control-input:focus-visible,
        .control-select:focus-visible,
        .fit-checkbox:focus-visible {
            outline: 2px solid var(--system-blue);
            outline-offset: 2px;
        }

    </style>
</head>

<body>

<div id="app-container">
        <div id="controls-panel">
            
            <div class="control-group" style="padding-top: 16px;">
                 <div style="display: flex; align-items: center; gap: 10px;">
                    
                    <label for="file-input" class="file-input-label" style="flex-grow: 1;">
                        <span id="file-name">Select Data File</span>
                    </label>
                     
                    <div class="help-tooltip-container">
    <span class="help-icon">?</span>

    <div class="tooltip-content">
    <h4>Powder 5 Fit</h4>
    <p>Analyze powder XRD using the LeBail or Pawley method. <a href="powder5_help.html" target="_blank" style="color: #6495ED;">Method Guide &rarr;</a></p>
    <hr>
    <h4>Supported File Formats:</h4>
    <p>Generic 2-column (2θ intensity), .xrdml, .brml, .ras, .uxd, .udf, GSAS .esd/.xra</p>
    <hr>
    <h4>Chart Interaction:</h4>
    <p><b>Zoom:</b> Use the mouse wheel over the chart or an axis.</p>
    <p><b>Pan:</b> Click and drag the chart to pan.</p>
    <p><b>Reset View:</b> Right-click on the chart.</p>
    <p><b>Add BG Point:</b> Hold <b>Ctrl</b> and click on the chart to manually add a spline point.</p>
</div>
</div>




                </div>
                <input type="file" id="file-input" class="hidden" accept=".brml,.csv,.ras,.txt,.esd,.gsa,.std,.udf,.xra,.xrdml,.xy">
            </div>

            <div class="tab-buttons">
                <button class="tab-btn active" data-tab="sample">Sample</button>
                <button class="tab-btn" data-tab="background">Background</button>
                <button class="tab-btn" data-tab="profile">Profile</button>
            </div>

            <div class="tab-content-panels">
            <div id="tab-panel-sample" class="tab-content-panel active">
                <div class="control-group">
                    <h2>Structural Parameters</h2>
                    <div class="parameter-grid-2col">
                        <label for="bravais-lattice" class="control-label">System</label>
                        <select id="bravais-lattice" class="control-select">
                            <option value="cubic_F" selected>Cubic (F)</option>
                            <option value="cubic_I">Cubic (I)</option>
                            <option value="cubic_P">Cubic (P)</option>
                            <option value="hexagonal_P">Hexagonal (P)</option>
                            <option value="tetragonal_I">Tetragonal (I)</option>
                            <option value="tetragonal_P">Tetragonal (P)</option>
                            <option value="orthorhombic_F">Orthorhombic (F)</option>
                            <option value="orthorhombic_I">Orthorhombic (I)</option>
                            <option value="orthorhombic_C">Orthorhombic (C)</option>
                            <option value="orthorhombic_P">Orthorhombic (P)</option>
                            <option value="monoclinic_C">Monoclinic (C)</option>
                            <option value="monoclinic_P">Monoclinic (P)</option>
                        </select>
                    </div>
                    <div class="parameter-grid-2col">
                        <label for="space-group-select" class="control-label">Space Group</label>
                        <select id="space-group-select" class="control-select"></select>
                    </div>

                    <div id="lattice-parameters-container">
                        </div>
                </div>

                <div class="control-group">
                    <h2>Instrumental Parameters</h2>
                    <div class="parameter-grid-3col">
                        <label for="zero-shift" class="control-label">Zero (°)</label>
                        <input type="number" id="zero-shift" value="0.0" step="0.001" class="control-input">
                        <input type="checkbox" id="fit-zero-shift" class="fit-checkbox" title="Fit this parameter" >
                    </div>
                    <div class="form-row">
                        <label for="wavelength" class="control-label">Radiation 1 (Å)</label>
                        <input type="number" id="wavelength" value="1.54056" step="0.0001" class="control-input" min="0.01" title="Cu K-alpha 1">
                    </div>
                    <div class="form-row">
                        <label for="wavelength2" class="control-label">Radiation 2 (Å)</label>
                        <input type="number" id="wavelength2" value="1.54439" step="0.0001" class="control-input" min="0.01" title="Cu K-alpha 2">
                    </div>
                    <div class="form-row">
                        <label for="ratio21" class="control-label">Ratio (I₂/I₁)</label>
                        <input type="number" id="ratio21" value="0.497" step="0.01" class="control-input" min="0">
                    </div>
                </div>
            </div> <div id="tab-panel-background" class="tab-content-panel">
                <div class="control-group">
                    <h2>Background (Spline)</h2>
                    <div class="parameter-grid-2col" style="gap: 16px;">
                        <label class="control-label" for="spline-points-slider">Auto-points</label>
                        <div class="slider-value-track">
                            <input type="range" id="spline-points-slider" class="custom-slider" min="10" max="40" value="20" step="1">
                            <span id="spline-points-value" class="slider-value-display">20</span>
                        </div>
                    </div>
                    <button id="auto-spline-button" class="btn btn-secondary" style="width: 100%; margin-top: 12px;">Generate Spline Points</button>
                </div>

                <div class="control-group">
                    <div style="padding-top: 16px; border-top: 1px solid var(--system-separator);">
                        <h2 style="margin-bottom: 6px;">Spline Points</h2>
                        <p class="control-label" style="margin-bottom: 16px;">
                            Define the background spline. Use <b>Generate Spline Points</b>, <b>Ctrl+Click</b> on the chart, or edit the list below.
                        </p>
                        <div class="form-row" style="margin-bottom: 16px;">
                           <label for="show-spline-points-checkbox" class="control-label">Show Points on Chart</label>
                           <input type="checkbox" id="show-spline-points-checkbox" class="fit-checkbox" style="justify-self: start;" checked>
                       </div>
                        <div id="spline-points-list" style="max-height: 230px; overflow-y: auto; border: 1px solid var(--system-gray-4); border-radius: 8px; padding: 8px 0 8px 8px;">
                            </div>
                    </div>
                </div> </div> <div id="tab-panel-profile" class="tab-content-panel">
                 <div class="control-group">
                     <div class="parameter-grid-2col" style="margin-bottom: 24px;">
                         <label for="profile-function-select" class="control-label">Profile Function</label>
                         <select id="profile-function-select" class="control-select">
                            <option value="simple_pvoigt" selected>Simple pVoigt</option>
                            <option value="tch_aniso">TCH (Size/Strain/Aniso)</option>
                            <option value="split_pvoigt">Split pVoigt (Asymmetric)</option>
                         </select>
                    </div>

                    <div id="profile-simple-pvoigt-container" class="profile-controls-container">
                        <h3 class="profile-section-header">Gaussian Broadening</h3>
                        <label class="control-label">GU</label>
                        <input type="number" id="param-gu" value="0.035" step="0.01" class="control-input" min="0">
                        <input type="checkbox" id="fit-gu" class="fit-checkbox">
                        <label class="control-label">GV</label>
                        <input type="number" id="param-gv" value="-0.03" step="0.01" class="control-input">
                        <input type="checkbox" id="fit-gv" class="fit-checkbox" >
                        <label class="control-label">GW</label>
                        <input type="number" id="param-gw" value="0.02" step="0.01" class="control-input" min="0">
                        <input type="checkbox" id="fit-gw" class="fit-checkbox" >
                         <label class="control-label">GP</label>
                        <input type="number" id="param-gp" value="0.0" step="0.001" class="control-input">
                        <input type="checkbox" id="fit-gp" class="fit-checkbox">
                        <h3 class="profile-section-header">Lorentzian Broadening</h3>
                        <label class="control-label">LX</label>
                        <input type="number" id="param-lx" value="0.05" step="0.01" class="control-input" min="0">
                        <input type="checkbox" id="fit-lx" class="fit-checkbox" >
                         <h3 class="profile-section-header">Peak Shape & Position</h3>
                         <label class="control-label">eta (Mixing)</label>
                        <input type="number" id="param-eta" value="0.74" step="0.01" min="0" max="1" class="control-input">
                        <input type="checkbox" id="fit-eta" class="fit-checkbox">
                         <label class="control-label">shft (Displ.)</label>
                        <input type="number" id="param-shft" value="0" step="0.01" class="control-input">
                        <input type="checkbox" id="fit-shft" class="fit-checkbox" >
                         <label class="control-label">trns (Transp.)</label>
                        <input type="number" id="param-trns" value="0" step="0.01" class="control-input">
                        <input type="checkbox" id="fit-trns" class="fit-checkbox">
                    </div>

                    <div id="profile-tch-aniso-container" class="profile-controls-container hidden">
                        <h3 class="profile-section-header">Isotropic Gaussian (TCH)</h3>
                        <label class="control-label">U</label>
                        <input type="number" id="param-u" value="0.04" step="0.01" class="control-input" min="0">
                        <input type="checkbox" id="fit-u" class="fit-checkbox">
                        <label class="control-label">V</label>
                        <input type="number" id="param-v" value="-0.03" step="0.01" class="control-input">
                        <input type="checkbox" id="fit-v" class="fit-checkbox" >
                        <label class="control-label">W</label>
                        <input type="number" id="param-w" value="0.02" step="0.01" class="control-input" min="0">
                        <input type="checkbox" id="fit-w" class="fit-checkbox" >

                        <h3 class="profile-section-header">Isotropic Lorentzian (TCH)</h3>
                        <label class="control-label">X</label>
                        <input type="number" id="param-x" value="0.001" step="0.01" class="control-input" min="0">
                        <input type="checkbox" id="fit-x" class="fit-checkbox" >
                        <label class="control-label">Y</label>
                        <input type="number" id="param-y" value="0.005" step="0.01" class="control-input" min="0">
                        <input type="checkbox" id="fit-y" class="fit-checkbox" >

                        <h3 class="profile-section-header">Peak Asymmetry</h3>
                        <label class="control-label">S/L</label>
                        <input type="number" id="param-sl" value="0.0" step="0.001" class="control-input">
                        <input type="checkbox" id="fit-sl" class="fit-checkbox">
                        <label class="control-label">H/L</label>
                        <input type="number" id="param-hl" value="0.0" step="0.001" class="control-input">
                        <input type="checkbox" id="fit-hl" class="fit-checkbox" >


                        <h3 class="profile-section-header">Anisotropic Broadening (Stephens)</h3>
                        <label class="control-label">S400</label>
                        <input type="number" id="param-s400" value="0.0" step="0.1" class="control-input">
                        <input type="checkbox" id="fit-s400" class="fit-checkbox">
                        <label class="control-label">S040</label>
                        <input type="number" id="param-s040" value="0.0" step="0.1" class="control-input">
                        <input type="checkbox" id="fit-s040" class="fit-checkbox">
                        <label class="control-label">S004</label>
                        <input type="number" id="param-s004" value="0.0" step="0.1" class="control-input">
                        <input type="checkbox" id="fit-s004" class="fit-checkbox">
                        <label class="control-label">S220</label>
                        <input type="number" id="param-s220" value="0.0" step="0.1" class="control-input">
                        <input type="checkbox" id="fit-s220" class="fit-checkbox">
                         <label class="control-label">S202</label>
                        <input type="number" id="param-s202" value="0.0" step="0.1" class="control-input">
                        <input type="checkbox" id="fit-s202" class="fit-checkbox">
                        <label class="control-label">S022</label>
                        <input type="number" id="param-s022" value="0.0" step="0.1" class="control-input">
                        <input type="checkbox" id="fit-s022" class="fit-checkbox">
                    </div>

                    <div id="profile-split-pvoigt-container" class="profile-controls-container hidden">
                        <h3 class="profile-section-header">Gaussian (Left Side)</h3>
                        <label class="control-label">GU-L</label>
                        <input type="number" id="param-gu_l" value="0.035" step="0.01" class="control-input" min="0">
                        <input type="checkbox" id="fit-gu_l" class="fit-checkbox">
                        <label class="control-label">GV-L</label>
                        <input type="number" id="param-gv_l" value="-0.03" step="0.01" class="control-input">
                        <input type="checkbox" id="fit-gv_l" class="fit-checkbox">
                        <label class="control-label">GW-L</label>
                        <input type="number" id="param-gw_l" value="0.02" step="0.01" class="control-input" min="0">
                        <input type="checkbox" id="fit-gw_l" class="fit-checkbox">

                        <h3 class="profile-section-header">Gaussian (Right Side)</h3>
                        <label class="control-label">GU-R</label>
                        <input type="number" id="param-gu_r" value="0.035" step="0.01" class="control-input" min="0">
                        <input type="checkbox" id="fit-gu_r" class="fit-checkbox">
                        <label class="control-label">GV-R</label>
                        <input type="number" id="param-gv_r" value="-0.03" step="0.01" class="control-input">
                        <input type="checkbox" id="fit-gv_r" class="fit-checkbox">
                        <label class="control-label">GW-R</label>
                        <input type="number" id="param-gw_r" value="0.02" step="0.01" class="control-input" min="0">
                        <input type="checkbox" id="fit-gw_r" class="fit-checkbox">

                        <h3 class="profile-section-header">Lorentzian (Left Side)</h3>
                        <label class="control-label">LX-L</label>
                        <input type="number" id="param-lx_l" value="0.05" step="0.01" class="control-input" min="0">
                        <input type="checkbox" id="fit-lx_l" class="fit-checkbox">

                        <h3 class="profile-section-header">Lorentzian (Right Side)</h3>
                        <label class="control-label">LX-R</label>
                        <input type="number" id="param-lx_r" value="0.05" step="0.01" class="control-input" min="0">
                        <input type="checkbox" id="fit-lx_r" class="fit-checkbox">

                         <h3 class="profile-section-header">Peak Shape</h3>
                         <label class="control-label">eta (Mixing)</label>
                        <input type="number" id="param-eta_split" value="0.74" step="0.01" min="0" max="1" class="control-input">
                        <input type="checkbox" id="fit-eta_split" class="fit-checkbox">
                         <label class="control-label">shft (Displ.)</label>
                        <input type="number" id="param-shft_split" value="0" step="0.01" class="control-input">
                        <input type="checkbox" id="fit-shft_split" class="fit-checkbox">
                         <label class="control-label">trns (Transp.)</label>
                        <input type="number" id="param-trns_split" value="0" step="0.01" class="control-input">
                        <input type="checkbox" id="fit-trns_split" class="fit-checkbox">
                    </div>

                 </div> </div> </div>


            <div class="bottom-actions"> 
                 <div class="control-group" style="border-top: none; padding-top: 0;">
                     <h2>Refinement</h2>
                     <label for="algorithm-select" class="control-label">Method</label>
                     <select id="algorithm-select" class="control-select">
                        <option value="lm">Levenberg-Marquardt</option>
                        <option value="sa" selected>Simulated Annealing</option>
                        <option value="pt" selected>Parallel Tempering</option> </select>
                     </select>
                     
                     <div class="slider-group">
                         <label class="control-label">2θ Min</label>
                         <div class="slider-value-track">
                            <input type="range" id="tth-min-slider" class="custom-slider" disabled>
                            <span id="tth-min-value" class="slider-value-display">10.0</span>
                         </div>
                     </div>
                     
                     <div class="slider-group">
                         <label class="control-label">2θ Max</label>
                         <div class="slider-value-track">
                             <input type="range" id="tth-max-slider" class="custom-slider" disabled>
                             <span id="tth-max-value" class="slider-value-display">80.0</span>
                         </div>
                     </div>

                     <div class="slider-group">
                         <label class="control-label">Max Iterations</label>
                         <div class="slider-value-track">
                            <input type="range" id="iterations-slider" min="1" max="80" value="20" step="1" class="custom-slider">
                            <span id="iterations-value" class="slider-value-display">20</span>
                         </div>
                     </div>

                     <div id="progress-bar-container" class="hidden" style="width: 100%; border-radius: 3px; height: 5px;">
                        <div id="progress-bar" style="height: 100%; width: 0%; border-radius: 3px;"></div>
                     </div>
                     <div class="results-grid">
                        <div class="result-card">
                            <div class="result-card-label">Rp (%)</div>
                            <div id="rp-result" class="result-card-value">-</div>
                        </div>
                        <div class="result-card">
                            <div class="result-card-label">Rwp (%)</div>
                            <div id="rwp-result" class="result-card-value">-</div>
                        </div>
                        <div class="result-card">
                            <div class="result-card-label">χ² (GOF)</div>
                            <div id="chi2-result" class="result-card-value">-</div>
                        </div>
                     </div>
                </div>
                <div style="display: flex; flex-direction: column; gap: 16px; margin-top: 16px;">


                    <div style="display: flex; flex-direction: column; gap: 16px; margin-top: 16px;">
    <div style="display: flex; gap: 10px;">
        <button id="le-bail-button" class="btn btn-primary" style="flex: 1;" disabled>Run Le Bail</button>
        <button id="pawley-button" class="btn btn-primary" style="flex: 1;" disabled>Run Pawley</button>
    </div>

    <div style="display: flex; gap: 10px;">
        <button id="save-data-button" class="btn btn-secondary" style="flex: 1;" disabled>Save Report</button>
        <button id="report-button" class="btn btn-secondary" style="flex: 1;" disabled>Generate PDF</button>
    </div>
</div>
                </div>
            </div>
        </div>


        <div id="drag-handle"></div>

<div id="results-area" style="position: relative; flex-grow: 1; min-height: 0;">
    <div id="placeholder" style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; color: var(--system-secondary-label);">
        <svg xmlns="http://www.w3.org/2000/svg" style="width: 64px; height: 64px; margin-bottom: 16px;" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>
        <h2 style="font-size: 22px; font-weight: 600; margin-bottom: 8px;">Awaiting Data</h2>
        <p style="font-size: 16px; color: var(--system-secondary-label);">Load a data file to begin.</p>
    </div>

    <div id="results-container" style="width: 100%; height: 100%; display: none; flex-direction: column; position: relative;">
        <canvas id="main-chart"></canvas>
    </div>

    <div style="position: absolute; bottom: 6px; right: 12px; font-size: 10px; color: var(--system-secondary-label);">
        Powder 5, version 115, 27 Oct 2025
    </div>
</div>





<script>
    document.addEventListener('DOMContentLoaded', () => {      

        const CALCULATION_WINDOW_MULTIPLIER = 6.0; //avant 109 c'estai 8
        const PEAK_HEIGHT_CUTOFF = 0.002; // 0.01 Corresponds to 1%
 
const tooltipContainer = document.querySelector('.help-tooltip-container');
const tooltipContent = document.querySelector('.tooltip-content');
let tooltipTimer;

if (tooltipContainer && tooltipContent) {
    tooltipContainer.addEventListener('mouseenter', () => {
        // If a timer is set to hide the tooltip, cancel it
        clearTimeout(tooltipTimer);
        // Add the 'visible' class to show the tooltip
        tooltipContent.classList.add('visible');
    });

    tooltipContainer.addEventListener('mouseleave', () => {
        // Start a new timer to hide the tooltip after 1 second
        tooltipTimer = setTimeout(() => {
            tooltipContent.classList.remove('visible');
        }, 1000); //  milliseconds 
    });
}


        const controls = {
            fileInput: document.getElementById('file-input'),
            fileName: document.getElementById('file-name'),
            bravaisLattice: document.getElementById('bravais-lattice'),
            spaceGroupSelect: document.getElementById('space-group-select'),

            latticeParamsContainer: document.getElementById('lattice-parameters-container'),
            wavelength: document.getElementById('wavelength'),
      wavelength2: document.getElementById('wavelength2'), // le 29 sept 25, dublet Ka
        ratio21: document.getElementById('ratio21'),      
            zeroShift: document.getElementById('zero-shift'),
            fitZeroShift: document.getElementById('fit-zero-shift'),
 

          profileSelect: document.getElementById('profile-function-select'),
            
            // Profile containers
            profileSimplePVoigtContainer: document.getElementById('profile-simple-pvoigt-container'),
            profileTchAnisoContainer: document.getElementById('profile-tch-aniso-container'),
            profileSplitPVoigtContainer: document.getElementById('profile-split-pvoigt-container'),

            // Simple pVoigt
            paramGU: document.getElementById('param-gu'), fitGU: document.getElementById('fit-gu'),
            paramGV: document.getElementById('param-gv'), fitGV: document.getElementById('fit-gv'),
            paramGW: document.getElementById('param-gw'), fitGW: document.getElementById('fit-gw'),
            paramGP: document.getElementById('param-gp'), fitGP: document.getElementById('fit-gp'),
            paramLX: document.getElementById('param-lx'), fitLX: document.getElementById('fit-lx'),
            paramEta: document.getElementById('param-eta'), fitEta: document.getElementById('fit-eta'),
            paramShft: document.getElementById('param-shft'), fitShft: document.getElementById('fit-shft'),
            paramTrns: document.getElementById('param-trns'), fitTrns: document.getElementById('fit-trns'),

            // TCH Aniso
            paramU: document.getElementById('param-u'), fitU: document.getElementById('fit-u'),
            paramV: document.getElementById('param-v'), fitV: document.getElementById('fit-v'),
            paramW: document.getElementById('param-w'), fitW: document.getElementById('fit-w'),
            paramX: document.getElementById('param-x'), fitX: document.getElementById('fit-x'),
            paramY: document.getElementById('param-y'), fitY: document.getElementById('fit-y'),
            paramSL: document.getElementById('param-sl'), fitSL: document.getElementById('fit-sl'),
            paramHL: document.getElementById('param-hl'), fitHL: document.getElementById('fit-hl'),
            paramS400: document.getElementById('param-s400'), fitS400: document.getElementById('fit-s400'),
            paramS040: document.getElementById('param-s040'), fitS040: document.getElementById('fit-s040'),
            paramS004: document.getElementById('param-s004'), fitS004: document.getElementById('fit-s004'),
            paramS220: document.getElementById('param-s220'), fitS220: document.getElementById('fit-s220'),
            paramS202: document.getElementById('param-s202'), fitS202: document.getElementById('fit-s202'),
            paramS022: document.getElementById('param-s022'), fitS022: document.getElementById('fit-s022'),

            // Split pVoigt (NEW)
            paramGU_L: document.getElementById('param-gu_l'), fitGU_L: document.getElementById('fit-gu_l'),
            paramGV_L: document.getElementById('param-gv_l'), fitGV_L: document.getElementById('fit-gv_l'),
            paramGW_L: document.getElementById('param-gw_l'), fitGW_L: document.getElementById('fit-gw_l'),
            paramLX_L: document.getElementById('param-lx_l'), fitLX_L: document.getElementById('fit-lx_l'),
            paramGU_R: document.getElementById('param-gu_r'), fitGU_R: document.getElementById('fit-gu_r'),
            paramGV_R: document.getElementById('param-gv_r'), fitGV_R: document.getElementById('fit-gv_r'),
            paramGW_R: document.getElementById('param-gw_r'), fitGW_R: document.getElementById('fit-gw_r'),
            paramLX_R: document.getElementById('param-lx_r'), fitLX_R: document.getElementById('fit-lx_r'),
            paramEta_split: document.getElementById('param-eta_split'), fitEta_split: document.getElementById('fit-eta_split'),
            paramShft_split: document.getElementById('param-shft_split'), fitShft_split: document.getElementById('fit-shft_split'),
            paramTrns_split: document.getElementById('param-trns_split'), fitTrns_split: document.getElementById('fit-trns_split'), 
           
           
           
            algorithmSelect: document.getElementById('algorithm-select'),
            iterationsSlider: document.getElementById('iterations-slider'),
            iterationsValue: document.getElementById('iterations-value'),
            tthMinSlider: document.getElementById('tth-min-slider'),
            tthMinValue: document.getElementById('tth-min-value'),
            tthMaxSlider: document.getElementById('tth-max-slider'),
            tthMaxValue: document.getElementById('tth-max-value'),
            fitButton: document.getElementById('fit-button'),
            reportButton: document.getElementById('report-button'),
            saveDataButton: document.getElementById('save-data-button'),
            progressBar: document.getElementById('progress-bar'),
            progressBarContainer: document.getElementById('progress-bar-container'),
            rpResult: document.getElementById('rp-result'),
            rwpResult: document.getElementById('rwp-result'),
            chi2Result: document.getElementById('chi2-result'),
            mainChartCanvas: document.getElementById('main-chart'),
            placeholder: document.getElementById('placeholder'),
            resultsContainer: document.getElementById('results-container'),
                    };

        // --- Global State ---
        let profileParamCache = { "simple_pvoigt": {}, "tch_aniso": {}, "split_pvoigt": {} };
        let currentProfile = "simple_pvoigt";

       
        let isFitting = false;
        let lastGeneratedHklList = [];
        let backgroundAnchors = []; // Stores {tth, y} spline points
         let masterHklList = [];
         let hklIndexCache = {}; //ajouté le 8 oct 25, on met en cache les hkl

        let fullExperimentalData = { tth: new Float64Array(), intensity: new Float64Array() };
        let calculatedBackground = new Float64Array();
        let workingDataCache = { tth: new Float64Array(), intensity: new Float64Array(), background: new Float64Array(), isValid: false };

        let fitResults = null;
        let lastFitResultsCache = null;
        let mainChart;


        // --- Worker Setup --- ADD THIS BLOCK ---
        let refinementWorker = null;
        try {
            refinementWorker = new Worker('refinement_worker.js');
            console.log("Refinement worker created.");

            // --- Worker Message Handler --- ADD THIS ---
            refinementWorker.onmessage = function(e) {
                const { type, value, message, results } = e.data;

                if (type === 'progress') {
                    // Update progress bar smoothly
                    controls.progressBar.style.transition = 'width 0.1s linear'; // Faster transition during updates
                    controls.progressBar.style.width = `${Math.min(100, value * 100)}%`;
                    // Optionally display messages:
                    // if (message) { /* Update a status label */ }
                } else if (type === 'result') {
  //                  console.log("Worker finished, received results:", results);
                    fitResults = results; // Store the complete results object
                    lastFitResultsCache = JSON.parse(JSON.stringify(fitResults)); // Update cache

                    // Calculate display patterns based on worker results
                    // Need to recalculate background and net pattern here for display
                    const displayParams = fitResults.params;
                    const displayHklList = fitResults.hklList;
                    const displayScaleFactor = fitResults.stats.scaleFactor;

                    if (!workerWorkingData) {
                         console.error("Main thread doesn't have workerWorkingData to display results!");
                         showToast("Error displaying results: Data mismatch.", "error");
                         setUIState(false); // Make sure UI unlocks
                         return;
                    }

                     try {
                         // Recalculate background and net pattern using the worker results
                         // Use the SAME working data slice the worker used
                         // *** PASS SPLINE POINTS (backgroundAnchors) TO BACKGROUND CALCULATION ***
                         const finalBackgroundDisplay = calculateTotalBackground(workerWorkingData.tth, displayParams, backgroundAnchors);
                         const finalNetPatternDisplay = calculatePattern(workerWorkingData.tth, displayHklList, displayParams);

                         // Pass the *correct* sliced data to updateUI/updateChart
                         updateUI(
                             displayParams,
                             fitResults.stats,
                             finalNetPatternDisplay, // Net pattern for the *slice*
                             finalBackgroundDisplay, // Background for the *slice*
                             displayScaleFactor,
                             displayHklList
                         );
                     } catch (displayError) {
                          console.error("Error updating UI with worker results:", displayError);
                          showToast(`Error displaying results: ${displayError.message}`, "error");
                     }


                    setUIState(false); // Re-enable UI
                    controls.progressBar.style.transition = 'width 0.3s ease'; // Restore normal transition
                    controls.progressBar.style.width = '100%'; // Ensure it shows 100%

                } else if (type === 'error') {
                    console.error("Worker reported error:", message);
                    showToast(`Refinement Error: ${message}`, 'error');
                    setUIState(false); // Unlock UI on error
                    controls.progressBar.style.width = '0%'; // Reset progress bar
                }
            };

            refinementWorker.onerror = function(e) {
                console.error("Error initializing or communicating with worker:", e.message, e);
                showToast(`Worker Initialization Error: ${e.message}`, 'error');
                isFitting = false; // Ensure fitting state is reset
                setUIState(false);
                refinementWorker = null; // Disable worker functionality
            };

        } catch (e) {
            console.error("Failed to create Web Worker:", e);
            alert("Could not create the refinement Web Worker. Heavy calculations will freeze the browser. Check browser compatibility and file paths.");
            refinementWorker = null;
        }


         updateSpaceGroupUI();



         /**
 * Automatically finds points for the background spline, using local minima
 * refined within a sub-window and smoothed by averaging, ensuring points
 * exist at the current slider min/max tth.
 */
function autoFindSplinePoints(numPoints) {
    const AVERAGE_WINDOW_HALF_WIDTH = 3; // Window size = 2 * half_width + 1 = 7 points
    const REFINE_WINDOW_FRACTION = 0.30; // +/- 30% of chunk width for refinement search

    if (!fullExperimentalData || fullExperimentalData.tth.length < (2 * AVERAGE_WINDOW_HALF_WIDTH + 1)) {
        showToast("Not enough data loaded for background averaging.", "error");
        return;
    }

    const minTth = parseFloat(controls.tthMinSlider.value);
    const maxTth = parseFloat(controls.tthMaxSlider.value);

    if (numPoints < 2) numPoints = 2;

    const internalPointsToFind = numPoints - 2;
    const newSplinePoints = [];
    const tth = fullExperimentalData.tth;
    const intensity = fullExperimentalData.intensity;
    const totalDataPoints = tth.length;

    // --- Find Edge Points (No Averaging) ---
    const firstPoint = findClosestExperimentalPoint(minTth);
    const lastPoint = findClosestExperimentalPoint(maxTth);

    if (!firstPoint || !lastPoint) {
        showToast("Could not find edge points for background.", "error");
        return;
    }
    newSplinePoints.push({ index: firstPoint.index, tth: minTth, y: firstPoint.y });
    newSplinePoints.push({ index: lastPoint.index, tth: maxTth, y: lastPoint.y });

    // --- Find Internal Points (with Refined Minimum and Averaging) ---
    if (internalPointsToFind > 0) {
        let startIndex = fullExperimentalData.tth.findIndex(t => t >= minTth);
        let endIndex = fullExperimentalData.tth.findIndex(t => t > maxTth);
        if (startIndex === -1) startIndex = 0;
        if (endIndex === -1) endIndex = totalDataPoints;

        const relevantLength = endIndex - startIndex;
        if (relevantLength > internalPointsToFind + (2 * AVERAGE_WINDOW_HALF_WIDTH)) {
            const chunkSize = Math.floor(relevantLength / internalPointsToFind);

            for (let i = 0; i < internalPointsToFind; i++) {
                const chunkStartIdx = startIndex + i * chunkSize;
                const chunkEndIdx = (i === internalPointsToFind - 1) ? endIndex - 1 : startIndex + (i + 1) * chunkSize;

                if (chunkStartIdx >= chunkEndIdx) continue;

                // --- Step 1: Find initial minimum index in the chunk ---
                let initialMinVal = Infinity;
                let initialMinIndex = -1;
                for (let j = chunkStartIdx; j < chunkEndIdx; j++) {
                    if (j === firstPoint.index || j === lastPoint.index) continue;
                    if (intensity[j] < initialMinVal) {
                        initialMinVal = intensity[j];
                        initialMinIndex = j;
                    }
                }

                if (initialMinIndex === -1) continue; // No valid minimum found in chunk

                // --- Step 2: Define and search within the refined window ---
                const chunkStartTth = tth[chunkStartIdx];
                const chunkEndTth = tth[Math.max(chunkStartIdx, chunkEndIdx - 1)]; // Ensure valid index
                const chunkWidthTth = chunkEndTth - chunkStartTth;
                const refineRadiusTth = REFINE_WINDOW_FRACTION * chunkWidthTth;
                const refineCenterTth = tth[initialMinIndex];
                const refineMinTth = refineCenterTth - refineRadiusTth;
                const refineMaxTth = refineCenterTth + refineRadiusTth;

                let finalMinVal = Infinity;
                let finalMinIndex = initialMinIndex; // Default to initial minimum

                // Iterate through the original chunk indices BUT check if tth is within refine window
                for (let j = chunkStartIdx; j < chunkEndIdx; j++) {
                     if (j === firstPoint.index || j === lastPoint.index) continue; // Skip edges
                    if (tth[j] >= refineMinTth && tth[j] <= refineMaxTth) {
                        if (intensity[j] < finalMinVal) {
                            finalMinVal = intensity[j];
                            finalMinIndex = j;
                        }
                    }
                }
                // --- End Step 2 ---


                // Check if this final minimum point already exists (by index)
                const exists = newSplinePoints.some(p => p.index === finalMinIndex);
                if (!exists) {
                    // --- Step 3: Calculate Average Intensity around finalMinIndex ---
                    let sumY = 0;
                    let countY = 0;
                    const windowStart = Math.max(0, finalMinIndex - AVERAGE_WINDOW_HALF_WIDTH);
                    const windowEnd = Math.min(totalDataPoints, finalMinIndex + AVERAGE_WINDOW_HALF_WIDTH + 1);

                    for (let k = windowStart; k < windowEnd; k++) {
                        sumY += intensity[k];
                        countY++;
                    }
                    const averageY = (countY > 0) ? sumY / countY : intensity[finalMinIndex];
                    // --- End Step 3 ---

                    newSplinePoints.push({
                        index: finalMinIndex,        // Store refined minimum index
                        tth: tth[finalMinIndex],     // Use tth from the refined minimum point
                        y: averageY                  // Use the calculated average intensity
                    });
                }
            }
        } else {
             console.warn("Not enough data points in the selected range to find distinct internal background points with averaging.");
        }
    }

    // Overwrite the global list, sort by 2-theta
    backgroundAnchors = newSplinePoints.sort((a, b) => a.tth - b.tth);

    renderSplinePointList();
    updateBackgroundForPreview();
    updateSplinePointsOnChart();
}



function updateSplinePointsOnChart() {
    if (!mainChart) return;

    const anchorDataset = mainChart.data.datasets.find(d => d.label === 'Spline Points'); // <-- CHANGED LABEL
    if (anchorDataset) {
        // Map the anchors to the {x, y} format required by Chart.js scatter plots
        anchorDataset.data = backgroundAnchors.map(anchor => ({
            x: anchor.tth,
            y: anchor.y
        }));
       mainChart.update('none'); // Redraw the chart without animation
    }
}


        // function to find the nearest data point to a click
        function findClosestExperimentalPoint(targetTth) {
            if (!fullExperimentalData || fullExperimentalData.tth.length === 0) {
                return null;
            }

            let closestIndex = -1;
            let minDiff = Infinity;

            // This is a simple linear search. .. j'aurais pu utiliser la librairie JS.. mais bon, c'est autonome
            for (let i = 0; i < fullExperimentalData.tth.length; i++) {
                const diff = Math.abs(fullExperimentalData.tth[i] - targetTth);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestIndex = i;
                }
            }

            return {
                index: closestIndex,
                tth: fullExperimentalData.tth[closestIndex],
                y: fullExperimentalData.intensity[closestIndex]
            };
        }


        function renderSplinePointList() {
    const listContainer = document.getElementById('spline-points-list');
    listContainer.innerHTML = '';

    if (backgroundAnchors.length === 0) {
        listContainer.innerHTML = '<p class="control-label" style="text-align: center; padding-right: 8px;">No spline points defined.</p>';
    } else {
        backgroundAnchors.forEach((anchor, index) => {
            const item = document.createElement('div');
            item.className = 'anchor-point-item';

            // Check if it's an edge point
            const isEdgePoint = (index === 0 || index === backgroundAnchors.length - 1);
            const tthDisabled = isEdgePoint ? 'disabled' : '';
            const removeDisabled = isEdgePoint ? 'disabled' : '';
            const removeStyle = isEdgePoint ? 'opacity: 0.3; cursor: not-allowed;' : ''; // Visually disable remove button

            item.innerHTML = `
                <input type="number" class="control-input spline-tth-input" data-index="${index}" value="${anchor.tth.toFixed(4)}" step="0.01" title="2-theta" ${tthDisabled}>
                <input type="number" class="control-input spline-y-input" data-index="${index}" value="${anchor.y.toFixed(1)}" step="1" title="Intensity">
                <button class="anchor-remove-btn" data-index="${index}" title="${isEdgePoint ? 'Cannot remove edge point' : 'Remove point'}" ${removeDisabled} style="${removeStyle}">&times;</button>
            `;
            listContainer.appendChild(item);
        });
    }
    updateSplinePointsOnChart(); // Keep this call
}



function handleSplinePointListInteraction(e) {
    let listNeedsUpdate = false;
    // It's safer to read slider values inside the specific event handlers
    // in case they change between different input events within this function call.
    // const minTth = parseFloat(controls.tthMinSlider.value);
    // const maxTth = parseFloat(controls.tthMaxSlider.value);

    if (e.target.classList.contains('anchor-remove-btn')) {
        const index = parseInt(e.target.dataset.index, 10);
        // Prevent deleting first or last point (index 0 and length-1)
        if (!isNaN(index) && index > 0 && index < backgroundAnchors.length - 1) {
            backgroundAnchors.splice(index, 1);
            listNeedsUpdate = true; // Need to re-render the list with updated indices
        } else if (!isNaN(index) && (index === 0 || index === backgroundAnchors.length - 1)) {
             showToast("Cannot remove edge points.", "error"); // Inform user
        }
    }

    if (e.type === 'input' && e.target.classList.contains('spline-tth-input')) {
        const index = parseInt(e.target.dataset.index, 10);
        const value = parseFloat(e.target.value);
        // Prevent editing tth of first or last point
        if (!isNaN(index) && index > 0 && index < backgroundAnchors.length - 1) {
            if (!isNaN(value) && backgroundAnchors[index]) {
                backgroundAnchors[index].tth = value;
                // Don't re-render on every keystroke, sort internally and update background/points
                backgroundAnchors.sort((a, b) => a.tth - b.tth);
                // We *do* need to re-render if sorting changes the index order in the UI
                listNeedsUpdate = true;
            }
        } else if (!isNaN(index) && backgroundAnchors[index]) {
             // Revert the value if user tried to change edge point tth
             // Read the correct edge value from sliders *now*
             const currentMinTth = parseFloat(controls.tthMinSlider.value);
             const currentMaxTth = parseFloat(controls.tthMaxSlider.value);
             e.target.value = (index === 0 ? currentMinTth : currentMaxTth).toFixed(4);
             showToast("Cannot edit edge point 2θ.", "error");
        }
    }

    if (e.type === 'input' && e.target.classList.contains('spline-y-input')) {
        const index = parseInt(e.target.dataset.index, 10);
        const value = parseFloat(e.target.value);
        if (!isNaN(index) && !isNaN(value) && backgroundAnchors[index]) {
            backgroundAnchors[index].y = value;
            // No need to touch tth here, it's either fixed (edge) or editable via the other input
            updateBackgroundForPreview(); // Recalculate and redraw the background curve
            updateSplinePointsOnChart(); // <-- THIS IS THE ADDED LINE to update scatter points
        }
    }

    // This block is now primarily for handling list structure changes (add/remove/sort)
    if (listNeedsUpdate) {
        renderSplinePointList(); // Rebuilds the HTML list elements
        updateBackgroundForPreview(); // Ensure background curve reflects potential Tth changes
        // updateSplinePointsOnChart() is called inside renderSplinePointList, so not needed again here
    }
}


        function updateStephensAnisotropyUI() {
            const { system } = getSystemAndCentering();
            const sParams = { s400: { input: controls.paramS400, fit: controls.fitS400 }, s040: { input: controls.paramS040, fit: controls.fitS040 }, s004: { input: controls.paramS004, fit: controls.fitS004 }, s220: { input: controls.paramS220, fit: controls.fitS220 }, s202: { input: controls.paramS202, fit: controls.fitS202 }, s022: { input: controls.paramS022, fit: controls.fitS022 }, };
            for (const key in sParams) { sParams[key].input.disabled = false; sParams[key].fit.disabled = false; sParams[key].input.style.backgroundColor = ''; }
            switch (system) {
                case 'cubic':
                    sParams.s040.input.value = sParams.s400.input.value; sParams.s004.input.value = sParams.s400.input.value; sParams.s040.fit.checked = sParams.s400.fit.checked; sParams.s004.fit.checked = sParams.s400.fit.checked; sParams.s202.input.value = sParams.s220.input.value; sParams.s022.input.value = sParams.s220.input.value; sParams.s202.fit.checked = sParams.s220.fit.checked; sParams.s022.fit.checked = sParams.s220.fit.checked;
                    [sParams.s040, sParams.s004, sParams.s202, sParams.s022].forEach(p => { p.input.disabled = true; p.fit.disabled = true; p.input.style.backgroundColor = 'var(--system-gray-5)'; });
                    break;
                case 'hexagonal': case 'tetragonal': case 'rhombohedral':
                    sParams.s040.input.value = sParams.s400.input.value; sParams.s040.fit.checked = sParams.s400.fit.checked; sParams.s022.input.value = sParams.s202.input.value; sParams.s022.fit.checked = sParams.s202.fit.checked;
                    [sParams.s040, sParams.s022].forEach(p => { p.input.disabled = true; p.fit.disabled = true; p.input.style.backgroundColor = 'var(--system-gray-5)'; });
                    break;
            }
        }

        const verticalCursorLine = { id: 'verticalCursorLine', afterDraw: chart => { if (chart.tooltip?._active?.length) { let x = chart.tooltip._active[0].element.x, yAxis = chart.scales.y, ctx = chart.ctx; ctx.save(); ctx.beginPath(); ctx.moveTo(x, yAxis.top); ctx.lineTo(x, yAxis.bottom); ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(156, 163, 175, 0.7)'; ctx.setLineDash([4, 4]); ctx.stroke(); ctx.restore(); } } };
        Chart.register(verticalCursorLine);
        Chart.Tooltip.positioners.experimentalAnchor = function(items) { if (!items.length) return false; const experimentalItem = items.find(item => item.datasetIndex === 0) || items[0]; return { x: experimentalItem.element.x, y: experimentalItem.element.y }; };
        
                function getSystemAndCentering() {
            let [system, centering] = controls.bravaisLattice.value.split('_');
            // 9. r Rhombohedral, maille hex
            if (system === "rhombohedral") {
                centering = "R"; // Force centering to 'R' for rhombohedral system
            }
            return { system, centering };
        }

        function saveProfileState(profileId) {
            const state = {};
            let container;
            switch (profileId) {
                case "simple_pvoigt": container = controls.profileSimplePVoigtContainer; break;
                case "tch_aniso": container = controls.profileTchAnisoContainer; break;
                case "split_pvoigt": container = controls.profileSplitPVoigtContainer; break;
            }
            if (container) {
                container.querySelectorAll('input[type="number"], input[type="checkbox"]').forEach(input => {
                    state[input.id] = (input.type === 'checkbox') ? input.checked : input.value;
                });
            }
            profileParamCache[profileId] = state;
        }

        function restoreProfileState(profileId) {
            const state = profileParamCache[profileId];
            if (!state || Object.keys(state).length === 0) return;
            let container;
            switch (profileId) {
                case "simple_pvoigt": container = controls.profileSimplePVoigtContainer; break;
                case "tch_aniso": container = controls.profileTchAnisoContainer; break;
                case "split_pvoigt": container = controls.profileSplitPVoigtContainer; break;
            }
            if (container) {
                container.querySelectorAll('input[type="number"], input[type="checkbox"]').forEach(input => {
                    if (state[input.id] !== undefined) {
                        input.type === 'checkbox' ? (input.checked = state[input.id]) : (input.value = state[input.id]);
                    }
                });
            }
        }        


        // Data mapping systems to their possible Laue classes...peut etre mieux de les mettres dans la const spaceGroups ?
        const laueClassMap = {
            'cubic': [{ value: 'm-3m', text: 'm-3m' }, { value: 'm-3', text: 'm-3' }],
            'hexagonal': [{ value: '6/mmm', text: '6/mmm' }, { value: '6/m', text: '6/m' }],
            'rhombohedral': [{ value: '-3m', text: '-3m (Rhom. axes)' }, { value: '-3', text: '-3 (Rhom. axes)' }],
            'tetragonal': [{ value: '4/mmm', text: '4/mmm' }, { value: '4/m', text: '4/m' }],
            'orthorhombic': [{ value: 'mmm', text: 'mmm' }],
            'monoclinic': [{ value: '2/m', text: '2/m' }],
        };


function getSpaceGroupCentering(spaceGroupName) {
    const firstLetter = spaceGroupName.charAt(0).toUpperCase();
    if (firstLetter === "R") return "R"; // rhombohedral, mais en axes hex, à vérifier
    return firstLetter; // P, I, F, C, A, etc.
}

    //  updateSpaceGroupUI, v 108
    // les rhombo dans les axes hexa
function updateSpaceGroupUI() {
    const { system } = getSystemAndCentering();
    if (!spaceGroups.length) return; // Wait until data is defined

    const filteredGroups = spaceGroups.filter(sg => {
        // -
        // Create a special case for the hexagonal system to include rhombohedral ('R') groups.
        if (system === 'hexagonal') {
            // Show any group that is either 'hexagonal' OR is 'trigonal' with an 'R' name.
            return sg.system === 'hexagonal' || sg.system === 'trigonal';
        }
        
        // The original logic works correctly for all other systems.
        const selectedCentering = controls.bravaisLattice.value.split('_')[1];
        const sgCentering = sg.name.charAt(0).toUpperCase();
        return sg.system === system && sgCentering === selectedCentering;
    });

    controls.spaceGroupSelect.innerHTML = "";
    filteredGroups.forEach(sg => {
        const opt = document.createElement("option");
        opt.value = sg.number;
        opt.textContent = `${sg.number} – ${sg.name}`;
        controls.spaceGroupSelect.appendChild(opt);
    });
}

        function updateLatticeParamUI() {
            const currentValues = {}; const container = controls.latticeParamsContainer;
            container.querySelectorAll('input[type="number"]').forEach(input => { const name = input.id.replace('lattice-param-', ''); if (input.value) currentValues[name] = input.value; });
            const { system } = getSystemAndCentering(); container.innerHTML = '';
            const createInput = (name, label, defaultValue, step, isAngle = false) => {
                const valueToUse = currentValues[name] !== undefined ? currentValues[name] : defaultValue; const id_base = `lattice-param-${name}`; const unit = isAngle ? '°' : 'Å'; const minAttribute = isAngle ? '' : 'min="0.001"';
                const row = document.createElement('div'); row.className = 'parameter-grid-3col'; row.innerHTML = `<label for="${id_base}" class="control-label">${label} (${unit})</label><input type="number" id="${id_base}" value="${valueToUse}" step="${step}" class="control-input" ${minAttribute}><input type="checkbox" id="fit-lattice-${name}" class="fit-checkbox" title="Fit this parameter" checked>`; container.appendChild(row);
            };
            const params = { cubic: [{ name: 'a', label: 'a', value: 4.23, step: 0.001 }], tetragonal: [{ name: 'a', label: 'a', value: 4.0, step: 0.001 }, { name: 'c', label: 'c', value: 5.0, step: 0.001 }], orthorhombic: [{ name: 'a', label: 'a', value: 4.0, step: 0.001 }, { name: 'b', label: 'b', value: 5.0, step: 0.001 }, { name: 'c', label: 'c', value: 6.0, step: 0.001 }], hexagonal: [{ name: 'a', label: 'a', value: 4.0, step: 0.001 }, { name: 'c', label: 'c', value: 6.0, step: 0.001 }], rhombohedral: [{ name: 'a', label: 'a', value: 5.5, step: 0.001 }, { name: 'c', label: 'c', value: 15.0, step: 0.001 }], monoclinic: [{ name: 'a', label: 'a', value: 4.0, step: 0.001 }, { name: 'b', label: 'b', value: 5.0, step: 0.001 }, { name: 'c', label: 'c', value: 6.0, step: 0.001 }, { name: 'beta', label: 'β', value: 105.0, step: 0.01, isAngle: true }] };
            if(params[system]) params[system].forEach(p => createInput(p.name, p.label, p.value, p.step, p.isAngle));
        }


        function updateUIForSystemChange() {
            updateLatticeParamUI();
            updateSpaceGroupUI();
            updateStephensAnisotropyUI();
        }

        // This event listener triggers all UI updates.
        controls.bravaisLattice.addEventListener('change', updateUIForSystemChange);

/**
         * Smart file detector. It checks for known headers and extensions
         * and falls back to a generic 2-column parser.
         */
        const detectAndParseFile = (fileName, fileContent) => {
            const name = fileName.toLowerCase();
            const lines = fileContent.trim().split(/\r?\n/);
            const firstLine = lines.length > 0 ? lines[0].trim() : '';
            const upperContent = fileContent.substring(0, 500).toUpperCase(); // Check first 500 chars

            // --- Parser Registry ---
            const PARSER_REGISTRY = [
                { // XRDML
                    test: (name, content) => name.endsWith('.xrdml') || (content.includes('<?xml') && content.includes('<xrdMeasurement')),
                    parser: parseXrdmlFile
                },
                { // BRML
                    test: (name, content) => name.endsWith('.brml') || (content.includes('<?xml') && content.includes('<RawDataFile')),
                    parser: parseBrukerBrmlFile
                },
                { // Rigaku RASX (try brml parser)
                    test: (name, content) => name.endsWith('.rasx') && content.includes('<?xml'),
                    parser: parseBrukerBrmlFile
                },
                { // UXD
                    test: (name, content, firstLine) => name.endsWith('.uxd') || firstLine.startsWith('_FILEVERSION'),
                    parser: parseUxdFile
                },
                { // Rigaku RAS
                    test: (name, content, firstLine, upper) => name.endsWith('.ras') || upper.includes('*RAS_HEADER_START'),
                    parser: parseRigakuRasFile
                },
                { // Philips UDF/RD/SD
                    test: (name) => name.endsWith('.udf') || name.endsWith('.rd') || name.endsWith('.sd'),
                    parser: parsePhilipsUdfFile
                },
                { // GSAS ESD/XRA
                    test: (name, content, firstLine, upper, allLines) => allLines.some(line => line.trim().toUpperCase().startsWith('BANK')),
                    parser: (content, allLines) => {
                        const bankLine = allLines.find(line => line.trim().toUpperCase().startsWith('BANK'));
                        if (bankLine.toUpperCase().includes('STD')) {
                            return parseGsasXraFile(content);
                        }
                        return parseGsasEsdFile(content);
                    }
                },
                { // Jade MDI (treat as 2-column)
                     test: (name, content, firstLine, upper) => name.endsWith('.mdi') && (upper.includes('2-THETA, INTENSITY') || upper.startsWith('(SAMPLE')),
                     parser: parseDataFile
                }
            ];
            
            // --- Iterate Registry ---
            for (const rule of PARSER_REGISTRY) {
                try {
                    if (rule.test(name, fileContent, firstLine, upperContent, lines)) {
                        // Pass 'content' to parser, but 'lines' to the special GSAS one
                        if (rule.parser.length > 1) {
                             return rule.parser(fileContent, lines); // For GSAS parser
                        }
                        return rule.parser(fileContent);
                    }
                } catch (e) {
                    console.warn(`Parser ${rule.parser.name} failed, trying next...`, e.message);
                }
            }

            // --- Fallback for all other 2-column-like formats ---
            // This will attempt to parse: .xy, .csv, .txt, .dat, .asc, etc.
            return parseDataFile(fileContent, fileName);
        };
    
        /**
         * Generic 2-column parser. This is the fallback for most text files.
         * Includes validation logic for 2-theta (X) and step size (dX).
         */
        const parseDataFile = (text, fileName = "") => {
            const lines = text.trim().split(/\r?\n/);
            const tth = [], intensity = [];
            let last_x = -Infinity;
            let suspicious_steps = 0;
            let positive_x_values = 0;
            let negative_steps = 0;
            let headerLines = 0;
            let dataStarted = false;

            lines.forEach(line => {
                // Skip commented or empty lines
                if (line.startsWith('#') || line.startsWith('//') || line.startsWith('!') || line.startsWith(';') || line.trim() === '') {
                    if (!dataStarted) headerLines++;
                    return;
                }
                
                // Skip non-commented header lines (that contain letters)
                if (!dataStarted) {
                    if (/[a-zA-Z]/.test(line)) { 
                        headerLines++;
                        return;
                    }
                }

                const parts = line.trim().split(/[\s,;]+/);
                if (parts.length < 2) return;

                const x = parseFloat(parts[0]);
                const y = parseFloat(parts[1]);

                // If we get non-numeric data, it's either a header or a bad line
                if (isNaN(x) || isNaN(y)) {
                    if (!dataStarted) headerLines++; // Still in the header
                    return;
                }
                
                dataStarted = true; // First valid numeric pair found

                // --- vérif
                if (x > 0) positive_x_values++;

                if (last_x !== -Infinity) {
                    const dX = x - last_x;
                    if (dX < 0) {
                        negative_steps++; // Data is descending
                    } else if (dX > 0 && (dX < 0.0001 || dX > 0.2)) { 
                        suspicious_steps++; // Step size is weird
                    }
                }
                last_x = x;
                

                tth.push(x);
                intensity.push(y);
            });

            // --- Final checks (log warnings to console) ---
            if (tth.length > 10) { 
                if (positive_x_values / tth.length < 0.5) {
                    console.warn(`Data File (${fileName}) Warning: Most 2-theta (X) values are zero or negative. This is unusual for XRD data.`);
                }
                if (negative_steps / tth.length > 0.8) {
                     console.warn(`Data File (${fileName}) Warning: Data appears to be sorted in descending 2-theta order.`);
                }
                if (suspicious_steps / tth.length > 0.2) {
                    console.warn(`Data File (${fileName}) Warning: Many data points have a step size outside the typical range (0.0001° - 0.2°). Check file format.`);
                }
            } else if (tth.length === 0) {
                 throw new Error(`Could not parse any 2-column data from ${fileName}. File may be binary or have an unknown header.`);
            }

            return { tth, intensity };
        };

        const parseXrdmlFile = (xmlString) => { const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlString, "application/xml"); if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing XRDML file."); } let wavelength = null; const kAlpha1Node = xmlDoc.querySelector("kAlpha1"); if (kAlpha1Node?.textContent) wavelength = parseFloat(kAlpha1Node.textContent); const intensityNode = xmlDoc.querySelector("intensities") || xmlDoc.querySelector("counts"); if (!intensityNode) throw new Error("Could not find <intensities> or <counts> in XRDML file."); const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number); const positionsNode = xmlDoc.querySelector('positions[axis="2Theta"]'); if (!positionsNode) throw new Error("Could not find <positions> in XRDML file."); const startPosNode = positionsNode.querySelector("startPosition"); const endPosNode = positionsNode.querySelector("endPosition"); if (!startPosNode || !endPosNode) throw new Error("Could not find start/end positions in XRDML."); const startPos = parseFloat(startPosNode.textContent); const endPos = parseFloat(endPosNode.textContent); const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * (endPos - startPos) / (intensity.length - 1)); return { tth, intensity, wavelength }; };
        const parseBrukerBrmlFile = (xmlString) => { const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlString, "application/xml"); if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing BRML file."); } let wavelength = null; const wlNode = xmlDoc.querySelector('usedWavelength'); if (wlNode) { const kAlpha1 = wlNode.getAttribute('kAlpha1'); if (kAlpha1) wavelength = parseFloat(kAlpha1); } const intensityNode = xmlDoc.querySelector("dataPoints > counts"); if (!intensityNode) throw new Error("No <counts> data found in BRML file."); const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number); const startPosNode = xmlDoc.querySelector('startPosition[axis="TwoTheta"]'); const stepSizeNode = xmlDoc.querySelector('increment[axis="TwoTheta"]'); if (!startPosNode || !stepSizeNode) throw new Error("Could not find scan parameters in BRML file."); const startPos = parseFloat(startPosNode.textContent); const stepSize = parseFloat(stepSizeNode.textContent); const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * stepSize); return { tth, intensity, wavelength }; };
        const parseRigakuRasFile = (text) => { const lines = text.trim().split(/\r?\n/); const tth = [], intensity = []; let inDataSection = false; let wavelength = null; for (const line of lines) { const upperLine = line.toUpperCase(); if (upperLine.startsWith('*WAVE_LENGTH') || upperLine.startsWith('*MEAS_COND_XG_WAVE_LENGTH')) { const parts = line.trim().split(/\s+/); if (parts.length > 1) { const wl = parseFloat(parts[1]); if (!isNaN(wl)) wavelength = wl; } } if (upperLine.startsWith('*RAS_INT_START')) { inDataSection = true; continue; } if (upperLine.startsWith('*RAS_INT_END')) break; if (inDataSection) { const parts = line.trim().split(/[\s,]+/); if (parts.length >= 2) { const x = parseFloat(parts[0]); const y = parseFloat(parts[1]); if (!isNaN(x) && !isNaN(y)) { tth.push(x); intensity.push(y); } } } } if (tth.length === 0) throw new Error("No data found in RAS file data section."); return { tth, intensity, wavelength }; };
        const parseGsasEsdFile = (text) => { const lines = text.trim().split(/\r?\n/); let wavelength = null; let startTth, stepSize; let dataStartIndex = -1; lines.forEach((line, index) => { const upperLine = line.toUpperCase(); if (upperLine.includes('WAVELENGTH')) { const match = line.match(/wavelength\s+([0-9.]+)/i); if (match && match[1]) wavelength = parseFloat(match[1]); } if (upperLine.startsWith('BANK')) { const parts = line.trim().split(/\s+/); if (parts.length >= 6 && parts[4].toUpperCase() === 'CONST') { startTth = parseFloat(parts[5]) / 100.0; stepSize = parseFloat(parts[6]) / 100.0; dataStartIndex = index + 1; } } }); if (startTth === undefined || stepSize === undefined) throw new Error("GSAS Parse Error: Could not find a valid 'BANK' line with CONST scan parameters."); if (dataStartIndex !== -1 && lines[dataStartIndex]?.toUpperCase().includes('STD')) dataStartIndex++; if (dataStartIndex === -1 || dataStartIndex >= lines.length) throw new Error("GSAS Parse Error: Found scan parameters but no subsequent data lines."); const intensity = []; for (let i = dataStartIndex; i < lines.length; i++) { const parts = lines[i].trim().split(/\s+/); for (let j = 1; j < parts.length; j += 2) { const val = parseFloat(parts[j]); if (!isNaN(val)) intensity.push(val); } } if (intensity.length === 0) throw new Error("GSAS Parse Error: No intensity data could be parsed."); const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize); return { tth, intensity, wavelength }; };
        
        const parseGsasXraFile = (text) => {
    const lines = text.trim().split(/\r?\n/);
    let wavelength = null;
    let startTth, stepSize;
    let dataStartIndex = -1;
    lines.forEach((line, index) => {
        const upperLine = line.toUpperCase();
        if (upperLine.includes('WAVELENGTH')) {
            const match = line.match(/wavelength\s+([0-9.]+)/i);
            if (match && match[1]) wavelength = parseFloat(match[1]);
        }
        if (upperLine.startsWith('BANK')) {
            const parts = line.trim().split(/\s+/);
            if (parts.length >= 7 && parts[4].toUpperCase() === 'CONST') {
                startTth = parseFloat(parts[5]) / 100.0;
                stepSize = parseFloat(parts[6]) / 100.0;
                dataStartIndex = index + 1;
            }
        }
    });

    if (startTth === undefined || stepSize === undefined) throw new Error("GSAS XRA Parse Error: Could not find a valid 'BANK' line with CONST scan parameters.");
    if (dataStartIndex === -1 || dataStartIndex >= lines.length) throw new Error("GSAS XRA Parse Error: Found scan parameters but no subsequent data lines.");

    const intensity = [];
    for (let i = dataStartIndex; i < lines.length; i++) {
        if (lines[i].trim() === '') continue;
        const parts = lines[i].trim().split(/\s+/);
        for (let j = 0; j < parts.length; j++) {
            const val = parseFloat(parts[j]);
            if (!isNaN(val)) intensity.push(val);
        }
    }
    if (intensity.length === 0) throw new Error("GSAS XRA Parse Error: No intensity data could be parsed.");
    const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize);
    return { tth, intensity, wavelength };
};
        
        const parseUxdFile = (text) => { const lines = text.trim().split(/\r?\n/); const intensity = []; let startTth, stepSize, wavelength; let inDataSection = false; for (const line of lines) { const trimmedLine = line.trim(); if (inDataSection) { const parts = trimmedLine.split(/\s+/); parts.forEach(part => { const val = parseFloat(part); if (!isNaN(val)) intensity.push(val); }); } else { if (trimmedLine.toUpperCase().startsWith('_START=')) startTth = parseFloat(trimmedLine.substring(7)); else if (trimmedLine.toUpperCase().startsWith('_STEPSIZE=')) stepSize = parseFloat(trimmedLine.substring(10)); else if (trimmedLine.toUpperCase().startsWith('_WL1=')) wavelength = parseFloat(trimmedLine.substring(5)); else if (trimmedLine.toUpperCase() === '_COUNTS') inDataSection = true; } } if (startTth === undefined || stepSize === undefined) throw new Error("Could not find _START and _STEPSIZE in UXD file."); if (intensity.length === 0) throw new Error("No intensity data found after _COUNTS in UXD file."); const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize); return { tth, intensity, wavelength }; };
        const parsePhilipsUdfFile = (text) => { const lines = text.trim().split(/\r?\n/); const tth = [], intensity = []; let inDataSection = false; let wavelength = null; for (const line of lines) { const trimmedLine = line.trim(); if (trimmedLine.toUpperCase().startsWith('LAMBDA')) { const parts = trimmedLine.split('='); if (parts.length > 1) wavelength = parseFloat(parts[1]); } if (trimmedLine.toUpperCase() === '[DATA]') { inDataSection = true; continue; } if (trimmedLine.startsWith('[') && trimmedLine.toUpperCase() !== '[DATA]') inDataSection = false; if (inDataSection) { const parts = trimmedLine.split(/,/).map(p => p.trim()); if(parts.length >= 2) { const x = parseFloat(parts[0]); const y = parseFloat(parts[1]); if (!isNaN(x) && !isNaN(y)) { tth.push(x); intensity.push(y); } } } } if (tth.length === 0) throw new Error("No [Data] section found in UDF file."); return { tth, intensity, wavelength }; };



        // Global cache for the data used in fitting, 
        let workingData = {
            tth: [],
            intensity: [],
            weights: [],
            startIndex: 0, // Store the starting index from the full dataset
            lastRawDifference: [],
            isValid: false
        };

        /**
         * This function is the single source of truth for refinement data.
         * It slices the fullExperimentalData based on slider values and, critically,
         * pre-calculates the weights array using Float64Array for performance.
         */
        function updateWorkingData() {
            if (fullExperimentalData.tth.length === 0) {
                workingData.isValid = false;
                return;
            }
            const minTth = parseFloat(controls.tthMinSlider.value);
            const maxTth = parseFloat(controls.tthMaxSlider.value);

            // Find the start and end indices in the master 'fullExperimentalData' array
            let startIndex = fullExperimentalData.tth.findIndex(t => t >= minTth);
            if (startIndex === -1) startIndex = 0;

            let endIndex = fullExperimentalData.tth.findIndex(t => t > maxTth);
            if (endIndex === -1) endIndex = fullExperimentalData.tth.length;

            // Slice the master typed arrays; .slice() on a typed array returns a new typed array
            workingData.tth = fullExperimentalData.tth.slice(startIndex, endIndex);
            workingData.intensity = fullExperimentalData.intensity.slice(startIndex, endIndex);
            workingData.startIndex = startIndex; // Store the offset

            // Pre-calculate weights into a new Float64Array for performance
            const n = workingData.intensity.length;
            workingData.weights = new Float64Array(n);
            
            const yMax = Math.max(...workingData.intensity);
            const floor = 0.001 * yMax; // Floor is 0.1% of maximum, similar to GSAS

            for (let i = 0; i < n; i++) {
                let weight = 1 / Math.max(floor, workingData.intensity[i]);
                workingData.weights[i] = weight;
            }

            workingData.isValid = true;
        }



        function evaluateExpression(expr, h, k, l) {
            switch (expr.trim()) {
                case 'h+k': return h + k;
                case 'k+l': return k + l;
                case 'h+l': return h + l;
                case 'h+k+l': return h + k + l;
                case '-h+k+l': return -h + k + l;
                case 'h-k+l': return h - k + l;
                case '2h+l': return 2 * h + l;
                case 'h': return h;
                case 'k': return k;
                case 'l': return l;
                default: return NaN; // Return NaN for unknown expressions
            }
        }

        /**
 * Main entry point to check if a reflection is allowed by the space group rules.
 * @returns {boolean} True if the reflection is allowed.
 */
function isReflectionAllowed(h, k, l, spaceGroup) {
    const ruleTree = spaceGroup.rule_tree;

    // If no rules, all reflections are allowed
    if (!ruleTree || Object.keys(ruleTree).length === 0) {
        return true;
    }

    return evaluateRuleTree(h, k, l, ruleTree);
}

/**
 * Recursively evaluates the rule tree for a given reflection.
 * @returns {boolean} The result of the rule evaluation.
 */
function evaluateRuleTree(h, k, l, node) {
    // Handle logical operators (AND/OR)
    if (node.logic) {
        if (node.logic === "AND") {
            return node.rules.every(rule => evaluateRuleTree(h, k, l, rule));
        } else if (node.logic === "OR") {
            return node.rules.some(rule => evaluateRuleTree(h, k, l, rule));
        }
    }

    // Handle individual rule types
    if (node.type === "family_check") {
        const inFamily = isInFamily(h, k, l, node.family);
        // The 'inverse' flag means the rule applies if the reflection is NOT in the family
        return node.inverse ? !inFamily : inFamily;
    }

    if (node.type === "expression_check") {
        const value = evaluateExpression(h, k, l, node.expression);
        // The condition is met if the expression result is an even multiple of the divisor
        return !isNaN(value) && value % node.divisor === 0;
    }

    if (node.type === "parity") {
        if (node.rule === "all_even") {
            return h % 2 === 0 && k % 2 === 0 && l % 2 === 0;
        } else if (node.rule === "all_odd") {
            return h % 2 !== 0 && k % 2 !== 0 && l % 2 !== 0;
        }
    }

    // If a node doesn't match any known type, it's considered a pass
    return true;
}

/**
 * Checks if a given hkl triplet belongs to a specific reflection family.
 * @returns {boolean} True if the hkl is in the family.
 */
function isInFamily(h, k, l, family) {
    switch (family) {
        case "h00": return k === 0 && l === 0;
        case "0k0": return h === 0 && l === 0;
        case "00l": return h === 0 && k === 0;
        case "h0l": return k === 0;
        case "hk0": return l === 0;
        case "0kl": return h === 0;
        case "hhl": return h === k;
        case "hkk": return k === l;
        case "hhh": return h === k && k === l;
        default:    return false;
    }
}

/**
 * Safely evaluates a predefined crystallographic expression.
 * @returns {number|NaN} The result of the expression, or NaN if unknown.
 */
function evaluateExpression(h, k, l, expr) {
    // Ensure expr is a string before calling trim
    const expression = typeof expr === 'string' ? expr.trim() : '';
    switch (expression) {
        case 'h+k':   return h + k;
        case 'k+l':   return k + l;
        case 'h+l':   return h + l;
        case 'h+k+l': return h + k + l;
        case '-h+k+l':return -h + k + l;
         case 'h-k+l': return h - k + l; // Added missing case
        case '2h+l':  return 2 * h + l;
        case 'h':     return h;
        case 'k':     return k;
        case 'l':     return l;
        default:      return NaN; // Return NaN for unknown expressions
    }
}

/**
 * Recursively evaluates the rule tree for a given reflection.
 * @returns {boolean} The result of the rule evaluation.
 */
function evaluateRuleTree(h, k, l, node) {
    // Handle logical operators (AND/OR)
    if (node.logic) {
        if (node.logic === "AND") {
            // Ensure node.rules exists and is an array
            return Array.isArray(node.rules) && node.rules.every(rule => evaluateRuleTree(h, k, l, rule));
        } else if (node.logic === "OR") {
            // Ensure node.rules exists and is an array
            return Array.isArray(node.rules) && node.rules.some(rule => evaluateRuleTree(h, k, l, rule));
        }
    }

    // Handle individual rule types
    if (node.type === "family_check") {
        const inFamily = isInFamily(h, k, l, node.family);
        // The 'inverse' flag means the rule applies if the reflection is NOT in the family
        return node.inverse ? !inFamily : inFamily;
    }

    if (node.type === "expression_check") {
        const value = evaluateExpression(h, k, l, node.expression);
         // Check if divisor is valid before modulo operation
         if (node.divisor === undefined || node.divisor === 0) return false; // Rule cannot be satisfied
        // The condition is met if the expression result is an even multiple of the divisor
        return !isNaN(value) && value % node.divisor === 0;
    }

    if (node.type === "parity") {
        if (node.rule === "all_even") {
            return h % 2 === 0 && k % 2 === 0 && l % 2 === 0;
        } else if (node.rule === "all_odd") {
             // Check absolute values for oddness if negative indices are possible
            return Math.abs(h) % 2 !== 0 && Math.abs(k) % 2 !== 0 && Math.abs(l) % 2 !== 0;
        }
    }

    return true; // Default to allowing reflection if rule is unhandled/malformed
}


/**
 * Main entry point to check if a reflection is allowed by the space group rules.
 * @returns {boolean} True if the reflection is allowed.
 */
function isReflectionAllowed(h, k, l, spaceGroup) {
     if (!spaceGroup || !spaceGroup.rule_tree) {
         // console.warn("isReflectionAllowed: Invalid spaceGroup or missing rule_tree for SG:", spaceGroup?.number);
         return true; // Allow if rules are missing
     }
    const ruleTree = spaceGroup.rule_tree;

    // If no rules defined in the tree, allow all reflections
    if (Object.keys(ruleTree).length === 0) {
        return true;
    }

    return evaluateRuleTree(h, k, l, ruleTree);
}

// --- Multiplicity Calculation (Keep in Main Thread for Preview) ---
// (This function was previously removed, add it back)
function getMultiplicityAndCanonicalHKL(h, k, l, laue_class) {
    if (h === 0 && k === 0 && l === 0) {
        return { multiplicity: 1, canonical_hkl_obj: [0, 0, 0] };
    }

    let m = 0;
     // Use absolute values for comparisons to handle negative indices correctly
     const abs_h = Math.abs(h);
     const abs_k = Math.abs(k);
     const abs_l = Math.abs(l);

     // Sort absolute values: h' >= k' >= l'
     let [h_p, k_p, l_p] = [abs_h, abs_k, abs_l].sort((a, b) => b - a);


    switch (laue_class) {
         case 'm-3m':
             if (h_p > k_p && k_p > l_p && l_p >= 0) m = 48;        // h > k > l > 0
             else if (h_p === k_p && k_p > l_p && l_p >= 0) m = 24;  // h = k > l >= 0
             else if (h_p > k_p && k_p === l_p && l_p >= 0) m = 24;  // h > k = l >= 0
             // else if (h_p > l_p && k_p > l_p && h_p === k_p) m = 24; // Redundant with h=k>l
             else if (h_p === k_p && k_p === l_p && l_p > 0) m = 8;   // h = k = l > 0
             else if (h_p > 0 && k_p === 0 && l_p === 0) m = 6;       // h00
             else if (h_p === k_p && l_p === 0 && h_p > 0) m = 12;      // hh0
             else if (h_p > k_p && k_p > 0 && l_p === 0) m = 24;      // hk0 (h>k>0)
             else m = 1; // Should not happen for non-zero hkl
             break;
         case 'm-3':
              if (h_p > k_p && k_p > l_p && l_p >= 0) m = 24;        // h > k > l >= 0
              else if ((h_p === k_p && k_p > l_p && l_p >= 0) || (h_p > k_p && k_p === l_p && l_p >= 0)) m = 12; // h=k>l>=0 or h>k=l>=0
              else if (h_p === k_p && k_p === l_p && l_p > 0) m = 8;   // h=k=l>0
              else if (h_p > 0 && k_p === 0 && l_p === 0) m = 6;       // h00
              else if (h_p === k_p && l_p === 0 && h_p > 0) m = 12;      // hh0 - Correction: m-3 has 12 for hh0
              else if (h_p > k_p && k_p > 0 && l_p === 0) m = 12;      // hk0 (h>k>0) - Correction: m-3 has 12 for hk0
              else m = 1;
              break;
         case '6/mmm':
             if (l_p > 0) { // l != 0
                  if (abs_h === 0 && abs_k === 0) m = 2; // 00l
                  else if (abs_h > 0 && abs_k === 0) m = 12; // h0l
                  else if (abs_h === abs_k && abs_k > 0) m = 12; // hhl
                  else if (abs_h > abs_k && abs_k >= 0) m = 24; // hkl, h>k>=0
                   // Need to consider 2hk.l, h h 2h .l etc for hexagonal? Usually handled by checking h,k,i=-h-k
                   // Assuming standard 3-index notation for now.
                  else m = 24; // Fallback general
              } else { // l=0 plane
                  if (abs_h === 0 && abs_k === 0) m = 1; // Origin
                  else if (abs_h > 0 && abs_k === 0) m = 6; // h00
                  else if (abs_h === abs_k && abs_k > 0) m = 6; // hh0
                  else if (abs_h > abs_k && abs_k >= 0) m = 12; // hk0, h>k>=0
                  else m = 12; // Fallback general hk0
              }
              break;
         case '6/m':
              if (l_p > 0) m = (abs_h > 0 || abs_k > 0) ? 12 : 2; // 00l vs hkl/h0l/hhl etc.
              else m = (abs_h > 0 || abs_k > 0) ? 6 : 1; // Origin vs hk0/h00/hh0
              break;
        case '-3m': // Needs careful check for rhombohedral vs hexagonal indexing
             // Using hexagonal axes convention
             if (l_p !== 0) { // l != 0
                 if (abs_h === 0 && abs_k === 0) { m = 2; } // 00l
                 // Special conditions like h-k+l = 3n or -h+k+l = 3n might matter for R centering, handled by isReflectionAllowed
                 // Multiplicity based purely on Laue group symmetry:
                 else if (abs_h === 0 || abs_k === 0 || abs_h === abs_k) { m = 12; } // h0l, hhl, 0kl forms
                 else { m = 24; } // General hkl
             } else { // l=0 plane
                 if (abs_h === 0 && abs_k === 0) { m = 1; } // Origin
                 else if (abs_h === 0 || abs_k === 0 || abs_h === abs_k) { m = 6; } // h00, hh0 forms
                 else { m = 12; } // General hk0
             }
             break;
         case '-3':
             if (abs_h === 0 && abs_k === 0 && l_p === 0) m = 1; // Origin
             else if (abs_h === 0 && abs_k === 0) m = 2; // 00l
             else m = 6; // General hkl and hk0
             break;
         case '4/mmm':
             if (l_p > 0) { // l != 0
                 if (abs_h === 0 && abs_k === 0) m = 2; // 00l
                 else if (abs_h === 0 || abs_k === 0 || abs_h === abs_k) m = 8; // h0l, hhl forms
                 else m = 16; // General hkl
             } else { // l=0 plane
                 if (abs_h === 0 && abs_k === 0) m = 1; // Origin
                 else if (abs_h === 0 || abs_k === 0 || abs_h === abs_k) m = 4; // h00, hh0 forms
                 else m = 8; // General hk0
             }
             break;
         case '4/m':
              if (l_p > 0) m = (abs_h > 0 || abs_k > 0) ? 8 : 2; // 00l vs hkl/h0l/hhl
              else m = (abs_h > 0 || abs_k > 0) ? 4 : 1; // Origin vs hk0/h00/hh0
              break;
         case 'mmm':
              if (abs_h > 0 && abs_k > 0 && l_p > 0) m = 8; // hkl
              else if ((abs_h > 0 && abs_k > 0 && l_p === 0) || (abs_h > 0 && abs_k === 0 && l_p > 0) || (abs_h === 0 && abs_k > 0 && l_p > 0)) m = 4; // hk0, h0l, 0kl
              else if (abs_h > 0 || abs_k > 0 || l_p > 0) m = 2; // h00, 0k0, 00l
              else m = 1; // Origin
              break;
         case '2/m': // Assumes unique axis b
              if (abs_k > 0) m = 4; // hkl, 0kl
              else if (abs_k === 0 && (abs_h !== 0 || l_p !== 0)) m = 2; // h0l (including h00, 00l)
              else m = 1; // Origin
              break;
         case '-1':
              if (abs_h === 0 && abs_k === 0 && l_p === 0) m = 1; // Origin
              else m = 2; // General hkl
              break;
        default:
            console.warn("Unknown Laue class in getMultiplicity:", laue_class, "- assuming multiplicity 1");
            m = 1;
            break;
    }
    // Simple canonical: return original h,k,l for now
    return { multiplicity: m, canonical_hkl_obj: [h, k, l] };
}


        /**
         * Generates the list of raw HKL indices {h, k, l, multiplicity} for PREVIEW.
         * This version runs in the main thread and does NOT use the worker's cache.
         * @returns {Array} A list of raw HKL reflection objects.
         */
        function generateAndCacheHklIndices(spaceGroup, maxTth, params) {
            // NOTE: This version runs in the main thread for PREVIEW ONLY.
            if (!spaceGroup || !spaceGroup.number) {
                 console.error("Preview HKL Gen: Invalid spaceGroup object provided.");
                 return [];
            }
            const sgNumber = spaceGroup.number;

            const { a, b, c, lambda } = params;
            const { system, laue_class } = spaceGroup;
             if (!lambda || lambda <= 0 || !laue_class || !a || a <=0) {
                 console.error("Preview HKL Gen: Missing lambda, laue_class or invalid 'a'.");
                 return [];
             }

             const maxDim = Math.max(a || 0, b || a || 0, c || a || 0);
             if (maxDim <= 0) return [];

            // --- OPTIMIZATION: Calculate max 1/d^2 for pruning ---
            const sinThetaMax_preview = Math.sin(maxTth * Math.PI / 360);
            if (sinThetaMax_preview <= 0) return []; 
            const dMin_preview = lambda / (2 * sinThetaMax_preview);
            const inv_d_sq_max = 1.0 / (dMin_preview * dMin_preview);
            const maxIndex = Math.ceil(maxDim / dMin_preview) + 5; // Generous max index
            
            // Pre-calculate params squared
            const a_sq = a * a;
            const b_sq = (b && b > 0) ? b * b : a_sq;
            const c_sq = (c && c > 0) ? c * c : a_sq;
            // --- End Optimization Setup ---


            let rawReflections = [];
            const addedHKLs = new Set();
            const getKey = (h, k, l) => `${h},${k},${l}`;

            const loopAndAdd = (h, k, l) => {
                if (h === 0 && k === 0 && l === 0) return;
                const key = getKey(h, k, l);
                if (addedHKLs.has(key)) return;

                if (isReflectionAllowed(h, k, l, spaceGroup)) {
                    const { multiplicity } = getMultiplicityAndCanonicalHKL(h, k, l, laue_class);
                     if (multiplicity > 0) {
                         rawReflections.push({
                            h_orig: h, k_orig: k, l_orig: l,
                            hkl_list: [`(${h},${k},${l})`],
                            multiplicity: multiplicity
                        });
                        addedHKLs.add(key);
                     }
                }
            };

            const maxI = maxIndex;

            if (system === 'monoclinic' || system === 'triclinic') {
                // Pruning is too complex due to h*l term, use original loop ranges
                // This is the correct asymmetric unit for 2/m (unique axis b)
                for (let h = -maxI; h <= maxI; h++) {
                    for (let k = 0; k <= maxI; k++) {
                        for (let l = 0; l <= maxI; l++) {
                            loopAndAdd(h, k, l);
                        }
                    }
                }
            } else if (system === 'orthorhombic') {
                if (b_sq <= 0 || c_sq <= 0) return []; // Need all params
                for (let h = 0; h <= maxI; h++) {
                    const h_term = (h*h) / a_sq;
                    if (h_term > inv_d_sq_max && h > 0) break; // Prune

                    for (let k = 0; k <= maxI; k++) {
                        const hk_term = h_term + (k*k) / b_sq;
                        if (hk_term > inv_d_sq_max && k > 0) break; // Prune

                        for (let l = 0; l <= maxI; l++) {
                            if (h === 0 && k === 0 && l === 0) continue;
                            const hkl_term = hk_term + (l*l) / c_sq;
                            if (hkl_term > inv_d_sq_max) {
                                 if (l === 0) break; 
                                 break; // Prune
                            }
                            loopAndAdd(h, k, l);
                        }
                    }
                }
            } else if (system === 'hexagonal' || system === 'trigonal' || system === 'rhombohedral') {
                if (c_sq <= 0) return []; // Need a and c
                const a_term_prefactor = 4.0 / (3.0 * a_sq);
                for (let h = 0; h <= maxI; h++) {
                    const h_term_only = a_term_prefactor * (h*h);
                    if (h_term_only > inv_d_sq_max && h > 0) break;

                    for (let k = 0; k <= h; k++) { // Use h >= k >= 0
                        const hk_term = a_term_prefactor * (h*h + h*k + k*k);
                        if (hk_term > inv_d_sq_max && k > 0) break; 

                        for (let l = 0; l <= maxI; l++) { // Use l >= 0
                            if (h === 0 && k === 0 && l === 0) continue;
                            const hkl_term = hk_term + (l*l) / c_sq;
                            if (hkl_term > inv_d_sq_max) {
                                if (l === 0) break;
                                break;
                            }
                            loopAndAdd(h, k, l);
                        }
                    }
                }
            } else { // Cubic, Tetragonal
                const isTetragonal = (system === 'tetragonal');
                if (isTetragonal && c_sq <= 0) return []; // Tet needs c

                for (let h = 0; h <= maxI; h++) {
                    const h_term = (h*h) / a_sq;
                    if (h_term > inv_d_sq_max && h > 0) break;

                    for (let k = 0; k <= h; k++) { // Use h >= k
                        const hk_term_base = (h*h + k*k);
                        if (isTetragonal) {
                             if (hk_term_base / a_sq > inv_d_sq_max && k > 0) break;
                        } else {
                             if (hk_term_base / a_sq > inv_d_sq_max && k > 0) break;
                        }

                        for (let l = 0; l <= k; l++) { // Use k >= l
                            if (h === 0 && k === 0 && l === 0) continue;
                            
                            let hkl_term;
                            if (isTetragonal) {
                                hkl_term = (h*h + k*k) / a_sq + (l*l) / c_sq;
                            } else { // Cubic
                                hkl_term = (h*h + k*k + l*l) / a_sq;
                            }

                            if (hkl_term > inv_d_sq_max) {
                                if (l === 0) break;
                                break;
                            }
                            loopAndAdd(h, k, l);
                        }
                    }
                }
            }

            return rawReflections;
        }



        // --- HKL Position Calculation (Needed for Preview in Main Thread) ---
        function updateHklPositions(hklList, params, system) {
            const { a, b, c, alpha, beta, lambda } = params;
            // Add validation checks at the beginning
            if (!hklList || hklList.length === 0) return; // No HKLs to update
            if (!params || !lambda || lambda <= 0 || !a || a <= 0) {
                 // console.warn("updateHklPositions: Invalid parameters (lambda or a).");
                 // Set all tth/d to null if params are bad
                 hklList.forEach(peak => { if(peak) { peak.tth = null; peak.d = null; } });
                 return;
             }


            const deg2rad = Math.PI / 180;
            const lambda_sq_over_4 = (lambda * lambda) / 4.0;
            const a_sq = a * a;

            let b_sq, c_sq, sin_beta_sq, cos_beta;
            if (system === 'monoclinic') {
                const beta_rad = (beta || 90) * deg2rad; // Default to 90 if undefined
                sin_beta_sq = Math.sin(beta_rad);
                sin_beta_sq *= sin_beta_sq;
                cos_beta = Math.cos(beta_rad);
                // Use 'a' as default if b or c are missing/invalid
                b_sq = (b && b > 0) ? (b * b) : a_sq;
                c_sq = (c && c > 0) ? (c * c) : a_sq;
                 // Add check for sin_beta_sq being too small (beta near 0 or 180)
                 if (Math.abs(sin_beta_sq) < 1e-9) {
                     // console.warn("updateHklPositions: Monoclinic beta angle is too close to 0 or 180.");
                     hklList.forEach(peak => { if(peak) { peak.tth = null; peak.d = null; } });
                     return;
                 }
            } else if (system === 'tetragonal' || system === 'hexagonal' || system === 'rhombohedral' || system === 'trigonal') {
                 c_sq = (c && c > 0) ? (c * c) : a_sq; // Use 'a' if c is invalid
            } else if (system === 'orthorhombic') {
                 b_sq = (b && b > 0) ? (b * b) : a_sq;
                 c_sq = (c && c > 0) ? (c * c) : a_sq;
            }


            hklList.forEach(peak => {
                if (!peak || peak.h_orig === undefined || peak.k_orig === undefined || peak.l_orig === undefined) {
                     if(peak) { peak.tth = null; peak.d = null; } // Invalidate if indices missing
                     return;
                }
                const h = peak.h_orig;
                const k = peak.k_orig;
                const l = peak.l_orig;
                const h2 = h * h;
                const k2 = k * k;
                const l2 = l * l;

                let inv_d_sq = 0;
                try { // Add try-catch for safety
                    switch(system) {
                        case 'cubic':
                            inv_d_sq = (h2 + k2 + l2) / a_sq;
                            break;
                        case 'tetragonal':
                            inv_d_sq = (h2 + k2) / a_sq + l2 / c_sq;
                            break;
                        case 'orthorhombic':
                            inv_d_sq = h2/a_sq + k2/b_sq + l2/c_sq;
                            break;
                        case 'hexagonal':
                        case 'rhombohedral': // Using hexagonal axes
                        case 'trigonal':     // Using hexagonal axes
                             // Check for division by zero
                             if (a_sq <= 0 || c_sq <= 0) throw new Error("Invalid lattice param");
                            inv_d_sq = 4 * (h2 + h*k + k2) / (3 * a_sq) + l2 / c_sq;
                            break;
                        case 'monoclinic':
                             // Check for division by zero (already checked sin_beta_sq)
                             if (a_sq <= 0 || b_sq <= 0 || c_sq <= 0 || a <= 0 || c <= 0) throw new Error("Invalid lattice param");
                            inv_d_sq = (1/sin_beta_sq) * (h2/a_sq + k2*sin_beta_sq/b_sq + l2/c_sq - (2*h*l*cos_beta)/(a*c));
                            break;
                         // Add triclinic if needed, complex formula
                         // case 'triclinic': ...
                        default:
                            throw new Error(`Unknown system: ${system}`);
                    }

                    // Validate inv_d_sq
                    if (!isFinite(inv_d_sq) || inv_d_sq <= 1e-12) { // Allow slightly negative due to float errors? No, should be positive.
                        peak.tth = null;
                        peak.d = null;
                    } else {
                        const sinThetaSq = lambda_sq_over_4 * inv_d_sq;
                        if (sinThetaSq <= 1 && sinThetaSq > 0) {
                             const thetaRad = Math.asin(Math.sqrt(sinThetaSq));
                             peak.tth = 2 * thetaRad / deg2rad; // Convert back to degrees
                            peak.d = 1 / Math.sqrt(inv_d_sq);
                        } else {
                            peak.tth = null; // Cannot calculate angle (sin^2 > 1 or <= 0)
                            peak.d = null;
                        }
                    }
                } catch (error) {
                     // console.error(`Error calculating d-spacing for HKL (${h},${k},${l}) in ${system}: ${error.message}`);
                     peak.tth = null;
                     peak.d = null;
                }

            }); // end forEach peak
        }
        // --- END HKL Position Calculation ---


        // --- Calculation Functions (Needed for Preview/Tooltips in Main Thread) ---

        /**
         * Calculates the total background contribution from a Linear Spline and an Amorphous Hump.
         * Runs in the main thread for preview updates.
         * @param {Float64Array} tthAxis - The array of 2-theta values.
         * @param {object} params - The object containing all refinement parameters.
         * @returns {Float64Array} A new array containing the calculated background intensity at each point.
         */
        function calculateTotalBackground(tthAxis, params) {
            const n = tthAxis.length;
            if (n === 0) {
                return new Float64Array();
            }

            const background = new Float64Array(n); // Allocate the typed array upfront
            const splinePoints = backgroundAnchors; // Use the global spline points

            // --- 1. Calculate Linear Spline Background ---
            if (splinePoints && splinePoints.length > 1) {
                // Ensure points are sorted by tth
                const sortedPoints = [...splinePoints].sort((a, b) => a.tth - b.tth);
                const numSplinePoints = sortedPoints.length;
                
                let p_idx = 0; // Current spline point segment index

                for (let i = 0; i < n; i++) {
                    const tth = tthAxis[i];

                    // Find the segment [p1, p2] that brackets tth
                    while (p_idx < numSplinePoints - 2 && sortedPoints[p_idx + 1].tth < tth) {
                        p_idx++;
                    }

                    const p1 = sortedPoints[p_idx];
                    const p2 = sortedPoints[p_idx + 1];

                    let y_spline = 0;
                    if (tth <= p1.tth) {
                        // Before the first point, extrapolate flat
                        y_spline = p1.y;
                    } else if (tth >= p2.tth) {
                        // After the second-to-last point, check if we're past the end
                        if (p_idx === numSplinePoints - 2 && tth >= sortedPoints[numSplinePoints - 1].tth) {
                            // After the last point, extrapolate flat
                            y_spline = sortedPoints[numSplinePoints - 1].y;
                        } else {
                            // This case should be handled by the 'while' loop, but as a fallback:
                            y_spline = p2.y; 
                        }
                    } else {
                        // We are between p1 and p2, interpolate
                        const tth_diff = p2.tth - p1.tth;
                        if (tth_diff > 1e-9) {
                            y_spline = p1.y + (p2.y - p1.y) * (tth - p1.tth) / tth_diff;
                        } else {
                            y_spline = p1.y; // Points are too close, just take p1
                        }
                    }
                    background[i] = y_spline;
                }
            } else if (splinePoints && splinePoints.length === 1) {
                // Only one point, make background flat
                const y_flat = splinePoints[0].y;
                for(let i=0; i<n; i++) background[i] = y_flat;
            } else {
                // No points, background is zero
                // (array is already zero-filled)
            }
            
         
            return background;
        }


        // --- Profile Shape & Width (Needed for Preview/Tooltips) ---
        function calculatePeakShift(tth, params) {
             if (!params || !params.profileType) return 0;
            const profileType = params.profileType;
            
            const calcShift = (tth, shft, trns) => {
                const thetaRad = tth * (Math.PI / 180) / 2;
                if (Math.abs(thetaRad - Math.PI / 2.0) < 1e-6) return 0;
                const cosTheta = Math.cos(thetaRad);
                const sin2Theta = Math.sin(2 * thetaRad);
                const displacementShift = -(shft / 1000) * cosTheta * (180 / Math.PI);
                const transparencyShift = trns * sin2Theta * (180 / Math.PI);
                const totalShift = displacementShift + transparencyShift;
                return isFinite(totalShift) ? totalShift : 0;
            };

            switch (profileType) {
                case "simple_pvoigt":
                    return calcShift(tth, params.shft || 0, params.trns || 0);
                case "split_pvoigt":
                    return calcShift(tth, params.shft_split || 0, params.trns_split || 0);
                case "tch_aniso":
                default:
                    return 0; // No shift for TCH profile
            }
        }

        function calculateProfileWidths(tth, hkl, params, side = 'center') {
             if (!params || !params.profileType) return { gamma_G: 1e-4, gamma_L: 1e-4 };
            
            const profileType = params.profileType;
            const thetaRad = tth * (Math.PI / 180) / 2;

            const MAX_ANGLE_RAD = Math.PI / 2.0 - 1e-6;
            const safeThetaRad = Math.min(thetaRad, MAX_ANGLE_RAD);
             if (safeThetaRad < 1e-6) {
                 return { gamma_G: 1e-4, gamma_L: 1e-4 };
             }

            const tanTheta = Math.tan(safeThetaRad);
            const cosTheta = Math.cos(safeThetaRad);
            const cosTheta_safe = Math.max(cosTheta, 1e-9);
            const cosThetaSq_safe = Math.max(cosTheta * cosTheta, 1e-9);

            let gamma_G = 1e-4;
            let gamma_L = 1e-4;

            switch (profileType) {
                case "simple_pvoigt": {
                    const GU = params.GU || 0;
                    const GV = params.GV || 0;
                    const GW = params.GW || 0;
                    const GP = params.GP || 0;
                    const LX = params.LX || 0;
                    const gamma_G_sq = GU * tanTheta * tanTheta + GV * tanTheta + GW + GP / cosThetaSq_safe;
                    if (gamma_G_sq > 0 && isFinite(gamma_G_sq)) gamma_G = Math.sqrt(gamma_G_sq);
                    const calculated_L = LX / cosTheta_safe;
                    if (calculated_L > 0 && isFinite(calculated_L)) gamma_L = calculated_L;
                    break;
                }
                
                case "split_pvoigt": {
                    let GU, GV, GW, LX;
                    if (side === 'left') {
                        GU = params.GU_L || 0;
                        GV = params.GV_L || 0;
                        GW = params.GW_L || 0;
                        LX = params.LX_L || 0;
                    } else { // 'right' or 'center'
                        GU = params.GU_R || 0;
                        GV = params.GV_R || 0;
                        GW = params.GW_R || 0;
                        LX = params.LX_R || 0;
                    }
                    const gamma_G_sq = GU * tanTheta * tanTheta + GV * tanTheta + GW; // No GP for split
                    if (gamma_G_sq > 0 && isFinite(gamma_G_sq)) gamma_G = Math.sqrt(gamma_G_sq);
                    const calculated_L = LX / cosTheta_safe;
                    if (calculated_L > 0 && isFinite(calculated_L)) gamma_L = calculated_L;
                    break;
                }

                case "tch_aniso": {
                     const U = params.U || 0;
                     const V = params.V || 0;
                     const W = params.W || 0;
                     const X = params.X || 0;
                     const Y = params.Y || 0;
                    const gamma_G_sq = U * tanTheta * tanTheta + V * tanTheta + W;
                    if (gamma_G_sq > 0 && isFinite(gamma_G_sq)) gamma_G = Math.sqrt(gamma_G_sq);
                    const calculated_L = X * tanTheta + Y / cosTheta_safe;
                    if (calculated_L > 0 && isFinite(calculated_L)) gamma_L = calculated_L;

                    if (hkl && hkl.d && hkl.h_orig !== undefined) {
                         const d_sq = hkl.d * hkl.d;
                         if (d_sq > 1e-9) {
                            const d_inv_sq = 1 / d_sq;
                            const h_val = hkl.h_orig, k_val = hkl.k_orig, l_val = hkl.l_orig;
                            const h2 = h_val*h_val, k2 = k_val*k_val, l2 = l_val*l_val;
                            const h4 = h2*h2, k4 = k2*k2, l4 = l2*l2;

                            const S400 = params.S400 || 0, S040 = params.S040 || 0, S004 = params.S004 || 0;
                            const S220 = params.S220 || 0, S202 = params.S202 || 0, S022 = params.S022 || 0;

                            let H_aniso = S400*h4 + S040*k4 + S004*l4 + S220*h2*k2 + S202*h2*l2 + S022*k2*l2;
                            H_aniso *= d_inv_sq * d_inv_sq;
                            if(isFinite(H_aniso) && H_aniso > 0) gamma_L += H_aniso / 1000.0;
                        }
                    }
                    break;
                }
            }

            return {
                gamma_G: Math.max(1e-4, isFinite(gamma_G) ? gamma_G : 1e-4),
                gamma_L: Math.max(1e-4, isFinite(gamma_L) ? gamma_L : 1e-4)
            };
        }


        /**
         * Calculates the total FWHM of a pseudo-Voigt peak from its Gaussian and Lorentzian components.
         * Runs in main thread for previews.
         */
        function getPeakFWHM(gamma_G, gamma_L) {
            // Ensure inputs are positive numbers
            const gG = Math.max(1e-9, gamma_G || 1e-9);
            const gL = Math.max(1e-9, gamma_L || 1e-9);

            // Thompson-Cox-Hastings approximation
            const fwhm_g_5 = Math.pow(gG, 5);
            const fwhm_l_5 = Math.pow(gL, 5);
            const fwhm_g_4_l = Math.pow(gG, 4) * gL;
            const fwhm_g_3_l_2 = Math.pow(gG, 3) * Math.pow(gL, 2);
            const fwhm_g_2_l_3 = Math.pow(gG, 2) * Math.pow(gL, 3);
            const fwhm_g_l_4 = gG * Math.pow(gL, 4);

            const fwhm_pow5 = fwhm_g_5 +
                              2.69269 * fwhm_g_4_l +
                              2.42843 * fwhm_g_3_l_2 +
                              4.47163 * fwhm_g_2_l_3 +
                              0.07842 * fwhm_g_l_4 +
                              fwhm_l_5;

             if (fwhm_pow5 < 0 || !isFinite(fwhm_pow5)) return Math.max(gG, gL, 1e-6); // Fallback

             const fwhm = Math.pow(fwhm_pow5, 0.2);
             return Math.max(1e-6, fwhm); // Ensure minimum positive FWHM
        }

        /**
         * Calculates the integrated area under a pseudo-Voigt peak shape.
         * Runs in main thread for previews.
         */
        function getPseudoVoigtArea(tth_peak, hkl, params) {
            const GAUSS_AREA_CONST = 1.0644677;
            const LORENTZ_AREA_CONST = 1.5707963;

            if (!params || !params.profileType) return 1.0;
            const profileType = params.profileType;

            switch (profileType) {
                case "simple_pvoigt": {
                    const { gamma_G, gamma_L } = calculateProfileWidths(tth_peak, hkl, params, 'center');
                    const gG = Math.max(1e-9, gamma_G);
                    const gL = Math.max(1e-9, gamma_L);
                    const area_G = gG * GAUSS_AREA_CONST;
                    const area_L = gL * LORENTZ_AREA_CONST;
                    const currentEta = Math.max(0, Math.min(1, params.eta || 0.5));
                    const totalArea = currentEta * area_L + (1 - currentEta) * area_G;
                    return isFinite(totalArea) && totalArea > 0 ? totalArea : 1.0;
                }
                
                case "split_pvoigt": {
                    // We must approximate the area of the split function.
                    // We'll average the areas calculated from the left and right widths.
                    const { gamma_G: gG_L, gamma_L: gL_L } = calculateProfileWidths(tth_peak, hkl, params, 'left');
                    const { gamma_G: gG_R, gamma_L: gL_R } = calculateProfileWidths(tth_peak, hkl, params, 'right');
                    
                    const currentEta = Math.max(0, Math.min(1, params.eta_split || 0.5));
                    
                    const area_G_L = Math.max(1e-9, gG_L) * GAUSS_AREA_CONST;
                    const area_L_L = Math.max(1e-9, gL_L) * LORENTZ_AREA_CONST;
                    const totalArea_L = currentEta * area_L_L + (1 - currentEta) * area_G_L;

                    const area_G_R = Math.max(1e-9, gG_R) * GAUSS_AREA_CONST;
                    const area_L_R = Math.max(1e-9, gL_R) * LORENTZ_AREA_CONST;
                    const totalArea_R = currentEta * area_L_R + (1 - currentEta) * area_G_R;
                    
                    const totalArea = (totalArea_L + totalArea_R) / 2.0;
                    return isFinite(totalArea) && totalArea > 0 ? totalArea : 1.0;
                }

                case "tch_aniso": {
                    const { gamma_G, gamma_L } = calculateProfileWidths(tth_peak, hkl, params, 'center');
                    const gG = Math.max(1e-9, gamma_G);
                    const gL = Math.max(1e-9, gamma_L);
                    
                    const fwhm = getPeakFWHM(gG, gL);
                    const ratio = (fwhm > 1e-9) ? gL / fwhm : 0;
                    const eta_calc = 1.36603 * ratio - 0.47719 * (ratio * ratio) + 0.11116 * Math.pow(ratio, 3);
                    const currentEta = Math.max(0, Math.min(1, eta_calc));
                    const area_G_combined = fwhm * GAUSS_AREA_CONST;
                    const area_L_combined = fwhm * LORENTZ_AREA_CONST;
                    const totalArea = currentEta * area_L_combined + (1 - currentEta) * area_G_combined;
                    return isFinite(totalArea) && totalArea > 0 ? totalArea : 1.0;
                }
            }
            return 1.0; // Default
        }


        /**
         * Applies asymmetry correction. Runs in main thread for previews.
         */
        function applyAsymmetry(x, x0, tth_peak, params) {
            if (!params) return x - x0;
            const profileType = params.profileType;

            switch (profileType) {
                case "tch_aniso": {
                    if (!params.SL && !params.HL) return x - x0;
                    
                    const delta_2theta = x - x0;
                    if (Math.abs(delta_2theta) < 1e-9) return 0;
                    if (tth_peak < 0.1 || tth_peak >= 180) return delta_2theta;

                    const theta_rad = tth_peak * (Math.PI / 180) / 2.0;
                    const safe_theta_rad = Math.max(1e-6, Math.min(Math.PI / 2.0 - 1e-6, theta_rad));
                    const tan_theta = Math.tan(safe_theta_rad);
                    if (Math.abs(tan_theta) < 1e-9) return delta_2theta;
                    const cot_theta = 1.0 / tan_theta;

                    const SL = params.SL || 0;
                    const HL = params.HL || 0;
                    const asymmetry_param = SL * cot_theta + HL;
                    if (!isFinite(asymmetry_param)) return delta_2theta;

                    const correction_term = asymmetry_param * Math.abs(delta_2theta);
                    const MAX_CORRECTION_EFFECT = 0.95;
                    const asymmetry_factor = Math.max(1e-6, 1.0 - Math.min(Math.abs(correction_term), MAX_CORRECTION_EFFECT));
                    const corrected = delta_2theta / asymmetry_factor;
                    return isFinite(corrected) ? corrected : delta_2theta;
                }
                
                case "simple_pvoigt":
                case "split_pvoigt":
                default:
                    // Asymmetry for these profiles is handled by shift/transparency,
                    // which is already applied to x0.
                    return x - x0; 
            }
        }


        /**
         * Calculates the pseudo-Voigt peak shape value. Runs in main thread for previews.
         */
        function pseudoVoigt(x, x0, tth_peak, hkl, params) {
             if (!params) return 0.0;

            const corrected_delta = applyAsymmetry(x, x0, tth_peak, params);
            const Cg = 2.772588722239781; // 4 * ln(2)
            let result = 0.0;

            try {
                switch (params.profileType) {
                    case "simple_pvoigt": {
                        const { gamma_G, gamma_L } = calculateProfileWidths(tth_peak, hkl, params, 'center');
                        const H_G = Math.max(1e-9, gamma_G);
                        const H_L = Math.max(1e-9, gamma_L);
                        if (Math.abs(corrected_delta) > 10 * (H_G + H_L)) return 0.0;

                        const currentEta = Math.max(0, Math.min(1, params.eta || 0.5));
                        const delta_over_Hg_sq = Math.pow(corrected_delta / H_G, 2);
                        const delta_over_Hl_sq = Math.pow(corrected_delta / H_L, 2);
                        const gaussianShape = Math.exp(-Cg * delta_over_Hg_sq);
                        const lorentzianShape = 1 / (1 + 4 * delta_over_Hl_sq);
                        result = currentEta * lorentzianShape + (1 - currentEta) * gaussianShape;
                        break;
                    }
                    
                    case "split_pvoigt": {
                        let H_G, H_L;
                        if (corrected_delta < 0) { // Left side
                            const { gamma_G, gamma_L } = calculateProfileWidths(tth_peak, hkl, params, 'left');
                            H_G = Math.max(1e-9, gamma_G);
                            H_L = Math.max(1e-9, gamma_L);
                        } else { // Right side
                            const { gamma_G, gamma_L } = calculateProfileWidths(tth_peak, hkl, params, 'right');
                            H_G = Math.max(1e-9, gamma_G);
                            H_L = Math.max(1e-9, gamma_L);
                        }
                        if (Math.abs(corrected_delta) > 10 * (H_G + H_L)) return 0.0;

                        const currentEta = Math.max(0, Math.min(1, params.eta_split || 0.5));
                        const delta_over_Hg_sq = Math.pow(corrected_delta / H_G, 2);
                        const delta_over_Hl_sq = Math.pow(corrected_delta / H_L, 2);
                        const gaussianShape = Math.exp(-Cg * delta_over_Hg_sq);
                        const lorentzianShape = 1 / (1 + 4 * delta_over_Hl_sq);
                        result = currentEta * lorentzianShape + (1 - currentEta) * gaussianShape;
                        break;
                    }

                    case "tch_aniso": {
                        const { gamma_G, gamma_L } = calculateProfileWidths(tth_peak, hkl, params, 'center');
                        const H_G = Math.max(1e-9, gamma_G);
                        const H_L = Math.max(1e-9, gamma_L);
                        if (Math.abs(corrected_delta) > 10 * (H_G + H_L)) return 0.0;

                        const fwhm = getPeakFWHM(H_G, H_L);
                        if (fwhm <= 1e-9) return Math.abs(corrected_delta) < 1e-6 ? 1.0 : 0.0;

                        const ratio = H_L / fwhm;
                        const eta_calc = 1.36603 * ratio - 0.47719 * (ratio * ratio) + 0.11116 * Math.pow(ratio, 3);
                        const currentEta = Math.max(0, Math.min(1, eta_calc));
                        const delta_over_fwhm_sq = Math.pow(corrected_delta / fwhm, 2);
                        const gaussianShape = Math.exp(-Cg * delta_over_fwhm_sq);
                        const lorentzianShape = 1 / (1 + 4 * delta_over_fwhm_sq);
                        result = currentEta * lorentzianShape + (1 - currentEta) * gaussianShape;
                        break;
                    }
                }
            } catch (calcError) {
                 console.warn("Error in pseudoVoigt calculation:", calcError);
                 return 0.0;
            }
             return (isFinite(result) && result >= 0) ? result : 0.0;
        }


        /**
         * Calculates the overall diffraction pattern. Runs in main thread for previews.
         */

        /**
         * Calculates the overall diffraction pattern. Runs in main thread for previews.
         * [CORRECTED FOR PAWLEY STABILITY]
         */
        function calculatePattern(tthAxis, hklList, params) {
            const n_points = tthAxis ? tthAxis.length : 0;
            if (n_points === 0 || !hklList || hklList.length === 0 || !params) {
                return new Float64Array(n_points);
            }

            const pattern = new Float64Array(n_points);
            const deg2rad = Math.PI / 180;
            const lambda1 = params.lambda || 1.54056;
            const lambda2 = params.lambda2 || 0;
            const ratio21 = params.ratio || 0;
            const zeroShift = params.zeroShift || 0;
            const WINDOW_MULT = CALCULATION_WINDOW_MULTIPLIER;
            const HEIGHT_CUTOFF = PEAK_HEIGHT_CUTOFF;

            // --- K-alpha 1 ---
            hklList.forEach(peak => {
                if (!peak || !peak.intensity || peak.intensity <= 0 || !peak.tth || peak.tth < 0 || peak.tth > 180) return;

                const basePos1 = peak.tth + zeroShift;
                const shift1 = calculatePeakShift(basePos1, params);
                const peakPos1 = basePos1 + shift1;

                // REMOVED shapeArea1 calculation.
                
                // Get widths just for the window approximation
                const { gamma_G, gamma_L } = calculateProfileWidths(peak.tth, peak, params, 'center');
                const fwhm_approx1 = getPeakFWHM(gamma_G, gamma_L); // This is an approximation but fine for the window
                
                const window1 = WINDOW_MULT * Math.max(0.01, fwhm_approx1);
                const min_tth1 = peakPos1 - window1;
                const max_tth1 = peakPos1 + window1;

                let startIndex = 0;
                while (startIndex < n_points && tthAxis[startIndex] < min_tth1) startIndex++;
                if (startIndex === n_points) return;

                for (let i = startIndex; i < n_points; i++) {
                    const current_tth = tthAxis[i];
                    if (current_tth > max_tth1) break;
                    
                    const intensityAtPoint = pseudoVoigt(current_tth, peakPos1, basePos1, peak, params); 
                    if (intensityAtPoint > HEIGHT_CUTOFF) {
                        // CHANGED: Use peak.intensity directly as Height, v 114
                        pattern[i] += peak.intensity * intensityAtPoint;
                    }
                }
            });

            // --- K-alpha 2 ---
            const doubletEnabled = ratio21 > 1e-6 && lambda2 > 1e-6 && Math.abs(lambda1 - lambda2) > 1e-6;
            if (doubletEnabled) {
                const lambdaRatio = lambda2 / lambda1;
                hklList.forEach(peak => {
                    if (!peak || !peak.intensity || peak.intensity <= 0 || !peak.tth || peak.tth <= 0 || peak.tth >= 180) return;

                    const sinTheta1 = Math.sin(peak.tth * deg2rad / 2.0);
                    const sinTheta2 = sinTheta1 * lambdaRatio;
                    if (Math.abs(sinTheta2) >= 1) return;

                    const tth2 = 2 * Math.asin(sinTheta2) / deg2rad;
                    const basePos2 = tth2 + zeroShift;
                    const shift2 = calculatePeakShift(basePos2, params);
                    const peakPos2 = basePos2 + shift2;
                    
                    // REMOVED shapeArea2 calculation.

                    const { gamma_G: gG2, gamma_L: gL2 } = calculateProfileWidths(tth2, peak, params, 'center');
                    const fwhm_approx2 = getPeakFWHM(gG2, gL2);

                    const window2 = WINDOW_MULT * Math.max(0.01, fwhm_approx2);
                    const min_tth2 = peakPos2 - window2;
                    const max_tth2 = peakPos2 + window2;

                    let startIndex2 = 0;
                    while (startIndex2 < n_points && tthAxis[startIndex2] < min_tth2) startIndex2++;
                    if (startIndex2 === n_points) return;

                    for (let i = startIndex2; i < n_points; i++) {
                        const current_tth = tthAxis[i];
                        if (current_tth > max_tth2) break;
                        
                        const intensityAtPoint = pseudoVoigt(current_tth, peakPos2, basePos2, peak, params);
                        if (intensityAtPoint > HEIGHT_CUTOFF) {
                            // CHANGED: Use peak.intensity directly as Height, problem Pawley unstable
                            pattern[i] += peak.intensity * ratio21 * intensityAtPoint;
                        }
                    }
                });
            }

            for (let i = 0; i < n_points; i++) {
                if (!isFinite(pattern[i])) {
                    pattern[i] = 0;
                }
            }
            return pattern;
        }


        // --- END Calculation Functions for Main Thread ---

        // master HKL, 1.0.3 et ensuite
        // This function now uses the cache to get raw indices and then calculates positions.
function generateMasterHklList() {
    if (fullExperimentalData.tth.length === 0 || spaceGroups.length === 0) {
        masterHklList = [];
        updatePreviewPattern();
        return;
    }

    const selectedSgNumber = parseInt(controls.spaceGroupSelect.value, 10);
    const selectedSg = spaceGroups.find(sg => sg.number === selectedSgNumber);
    if (!selectedSg) {
        masterHklList = [];
        console.error("Cannot generate HKL list: selected space group not found.");
        updatePreviewPattern();
        return;
    }

    const maxTth = Math.max(...fullExperimentalData.tth) + 2.0;
    const params = getAllParams();

   // console.log("Params for HKL gen:", JSON.stringify(params));
    //console.log("Selected SG object:", JSON.stringify(selectedSg));


    // 1. Get raw HKL indices. This is the key step that uses the new caching function.
    const rawHklIndices = generateAndCacheHklIndices(selectedSg, maxTth, params);

    // 2. Create a deep copy to work with, so we don't modify the cached version.
    let workingHklList = JSON.parse(JSON.stringify(rawHklIndices));

    // 3. Calculate the 2-theta positions for the current parameters.
    updateHklPositions(workingHklList, params, selectedSg.system);

    // 4. Filter out peaks that are outside the range, sort them, and assign to the global list.
    masterHklList = workingHklList
        .filter(peak => peak.tth !== null && peak.tth <= maxTth)
        .sort((a, b) => a.tth - b.tth);

    // Add a default intensity property for preview purposes
    masterHklList.forEach(peak => {
        peak.intensity = peak.intensity || 0;
    });

    updatePreviewPattern();
}



        function updateBackgroundForPreview() {
            if (fullExperimentalData.tth.length === 0 || isFitting) return;

            const params = getAllParams();
            // *** PASS SPLINE POINTS (backgroundAnchors) TO BACKGROUND CALCULATION ***
            calculatedBackground = calculateTotalBackground(fullExperimentalData.tth, params, backgroundAnchors);

            if (mainChart) {
                // ---Save the current Y-axis zoom state ---
                const currentYMin = mainChart.scales.y.min;
                const currentYMax = mainChart.scales.y.max;

                const backgroundDataset = mainChart.data.datasets.find(d => d.label === 'Background');
                if (backgroundDataset) {
                    backgroundDataset.data = fullExperimentalData.tth.map((t, i) => ({ x: t, y: calculatedBackground[i] }));
                }
                
                updatePreviewPattern(); 
                
                // --Restore the Y-axis zoom state before updating ---
                mainChart.options.scales.y.min = currentYMin;
                mainChart.options.scales.y.max = currentYMax;
                
                mainChart.update('none');
            }
        }





/**
 * Performs a Williamson-Hall analysis using the refined TCH profile parameters.
 * @param {object} params - The final refined parameters object (containing U, X, Y, lambda).
 * @param {Array<object>} hklList - The list of HKL reflections with their 2-theta positions.
 * @returns {object|null} An object with size, strain, and R-squared, or null if calculation fails.
 */
function calculateWilliamsonHall(params, hklList) {
    // This analysis is only valid for the TCH profile which separates size/strain contributions.
    if (params.profileType === "4" || params.U === undefined || params.X === undefined || params.Y === undefined) {
        return null;
    }

    const points = [];
    const deg2rad = Math.PI / 180;
    const workingTthMin = workingData.tth[0];
    const workingTthMax = workingData.tth[workingData.tth.length - 1];

    hklList.forEach(peak => {
        // Only include peaks within the currently fitted range for the analysis.
        if (!peak.tth || peak.tth < workingTthMin || peak.tth > workingTthMax) {
            return;
        }

        const theta_rad = peak.tth * deg2rad / 2.0;
        const cosTheta = Math.cos(theta_rad);
        const tanTheta = Math.tan(theta_rad);

        // Step 1: Calculate sample-only breadth components (in degrees) by ignoring instrumental V and W.
        const beta_G_sq = (params.U || 0) * tanTheta * tanTheta;
        const beta_G = beta_G_sq > 0 ? Math.sqrt(beta_G_sq) : 0;
        const beta_L = (params.X || 0) * tanTheta + (params.Y || 0) / cosTheta;
        
        // Step 2: Combine them using the TCH FWHM approximation to get the total sample breadth.
        const fwhm_g_5 = Math.pow(beta_G, 5);
        const fwhm_l_5 = Math.pow(beta_L, 5);
        const fwhm_g_4_l = 2.69269 * Math.pow(beta_G, 4) * beta_L;
        const fwhm_g_3_l_2 = 2.42843 * Math.pow(beta_G, 3) * Math.pow(beta_L, 2);
        const fwhm_g_2_l_3 = 4.47163 * Math.pow(beta_G, 2) * Math.pow(beta_L, 3);
        const fwhm_g_l_4 = 0.07842 * beta_G * Math.pow(beta_L, 4);
        const beta_sample_deg = Math.pow(fwhm_g_5 + fwhm_g_4_l + fwhm_g_3_l_2 + fwhm_g_2_l_3 + fwhm_g_l_4 + fwhm_l_5, 0.2);

        if (beta_sample_deg <= 1e-6) return; // Ignore zero-width peaks.

        // Step 3: Convert breadth to radians for the W-H equation.
        const beta_sample_rad = beta_sample_deg * deg2rad;

        // Step 4: Calculate the coordinates for the W-H plot.
        const x = Math.sin(theta_rad);          // x-axis is sin(theta)
        const y = beta_sample_rad * cosTheta;   // y-axis is beta * cos(theta)
        points.push({ x, y });
    });

    if (points.length < 2) return null; // Need at least 2 points for a linear fit.

    // Step 5: Perform a linear regression (y = mx + c) to find slope (m) and intercept (c).
    let sum_x = 0, sum_y = 0, sum_xy = 0, sum_x_sq = 0, sum_y_sq = 0;
    const n = points.length;
    points.forEach(p => {
        sum_x += p.x;
        sum_y += p.y;
        sum_xy += p.x * p.y;
        sum_x_sq += p.x * p.x;
        sum_y_sq += p.y * p.y;
    });

    const m_slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x_sq - sum_x * sum_x);
    const c_intercept = (sum_y - m_slope * sum_x) / n;

    // Calculate R-squared for goodness of fit.
    const ss_xx = sum_x_sq - (sum_x * sum_x) / n;
    const ss_yy = sum_y_sq - (sum_y * sum_y) / n;
    const ss_xy = sum_xy - (sum_x * sum_y) / n;
    const r_squared = (ss_xx === 0 || ss_yy === 0) ? 1 : Math.pow(ss_xy, 2) / (ss_xx * ss_yy);

    // Step 6: Extract physical parameters from the slope and intercept.
    const K_scherrer = 0.9; // Scherrer constant, typically 0.9.
    const lambda = params.lambda;

    // From intercept: c = K * lambda / L  => L = K * lambda / c
    const crystallite_size_A = (c_intercept > 1e-9) ? (K_scherrer * lambda) / c_intercept : Infinity;
    const crystallite_size_nm = crystallite_size_A / 10.0;

    // From slope: m = 4 * epsilon => epsilon = m / 4
    const microstrain = m_slope / 4.0;
    const microstrain_percent = microstrain * 100;

    return {
        size_nm: crystallite_size_nm,
        strain_percent: microstrain_percent,
        r_squared: r_squared
    };
}


        function redrawFitForNewRange() {
            if (!mainChart) return; 

            const currentYMin = mainChart.scales.y.min;
            const currentYMax = mainChart.scales.y.max;

            updateWorkingData();

            if (!fitResults) {
                updatePreviewPattern();
            } else {
                const params = fitResults.params;
                const scaleFactor = fitResults.stats.scaleFactor;
                
                // *** PASS SPLINE POINTS (backgroundAnchors) TO BACKGROUND CALCULATION ***
                const background_sliced = calculateTotalBackground(workingData.tth, params, backgroundAnchors);
                const unscaledPeakPattern_sliced = calculatePattern(workingData.tth, fitResults.hklList, params);

                const totalCalcPattern = math.add(math.multiply(Array.from(unscaledPeakPattern_sliced), scaleFactor), Array.from(background_sliced));
            
const diff = math.subtract(Array.from(workingData.intensity), totalCalcPattern);

                workingData.lastRawDifference = diff;
                
                const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
                
                const calculatedData = [];
                const backgroundData = [];
                for(let i = 0; i < workingData.tth.length; i++) {
                    calculatedData.push({ x: workingData.tth[i], y: totalCalcPattern[i] });
                    backgroundData.push({ x: workingData.tth[i], y: background_sliced[i] });
                }

                findDataset('Calculated').data = calculatedData;
                findDataset('Background').data = backgroundData;
                findDataset('Simulation (Manual)').data = [];
            }
            
            rescalePlot(false);
            
            mainChart.options.scales.x.min = parseFloat(controls.tthMinSlider.value);
            mainChart.options.scales.x.max = parseFloat(controls.tthMaxSlider.value);
            mainChart.options.scales.y.min = currentYMin;
            mainChart.options.scales.y.max = currentYMax;
            
            mainChart.update('none');
        }


        // runFit function - NOW SENDS DATA TO WORKER, depuis le 24 oct 2025
        let workerWorkingData = null; // Store the data sent to the worker for result display

        function runFit(refinementMode) {
            if (isFitting) {
                 console.warn("Fit already in progress.");
                 return;
            }
             if (!refinementWorker) {
                 showToast("Refinement worker is not available. Cannot start fit.", "error");
                 return; // Prevent running if worker failed to load
             }


            isFitting = true;
            setUIState(true);
            updateWorkingData(); // Prepare the data slice

            if (masterHklList.length === 0) {
                 showToast("Could not find a list of reflections. Please select a space group first. Aborting fit.", "error");
                 isFitting = false; setUIState(false); return;
            }

            const currentParams = getAllParams();
            const fitFlags = getFitFlags();
            const selectedSgNumber = parseInt(controls.spaceGroupSelect.value, 10);
            const selectedSg = spaceGroups.find(sg => sg.number === selectedSgNumber);
            if (!selectedSg) {
                 showToast("Error: Could not find selected space group data.", "error");
                 isFitting = false; setUIState(false); return;
             }

            const system = selectedSg.system; // Make sure this matches worker logic
            const maxIterations = parseInt(controls.iterationsSlider.value);
            const algorithm = controls.algorithmSelect.value;

            if (!workingData.isValid || workingData.tth.length === 0) {
                showToast("No data in the selected 2-theta range. Aborting fit.", "error");
                isFitting = false; setUIState(false); return;
            }

             // Store the data being sent FOR LATER when displaying results
             workerWorkingData = {
                 tth: workingData.tth.slice(), // Send copies
                 intensity: workingData.intensity.slice(),
                 weights: workingData.weights.slice(),
                 startIndex: workingData.startIndex
             };

            // --- Prepare data payload for the worker ---
             const workerPayload = {
                 initialParams: currentParams,
                 fitFlags: fitFlags,
                 workingData: workerWorkingData, // Send the sliced data
                 masterHklList: JSON.parse(JSON.stringify(masterHklList)), // Send a deep copy
                 spaceGroupsData: spaceGroups, // Send all space group definitions
                 selectedSgNumber: selectedSgNumber,
                 system: system,
                 maxIterations: maxIterations,
                 algorithm: algorithm,
                 refinementMode: refinementMode,
                 backgroundAnchors: JSON.parse(JSON.stringify(backgroundAnchors)) // <-- ADD THIS LINE
             };

            // --- Send data to worker ---
            try {
               /* console.log("Sending data to worker:", { // Log subset for brevity
                     algorithm: algorithm,
                     mode: refinementMode,
                     numPoints: workerPayload.workingData.tth.length,
                     numHkls: workerPayload.masterHklList.length,
                     params: Object.keys(workerPayload.initialParams).length
                }); */
                 refinementWorker.postMessage(workerPayload);
                 controls.progressBar.style.width = '0%'; // Reset progress bar visually
                 controls.progressBar.style.transition = 'none'; // Disable transition for reset
            } catch (error) {
                console.error("Error sending message to worker:", error);
                showToast(`Error starting refinement: ${error.message}`, "error");
                isFitting = false;
                setUIState(false);
            }
        }


        const getAllParams = () => {
            const profileType = controls.profileSelect.value;
            let params = {
                lambda: parseFloat(controls.wavelength.value),
                lambda2: parseFloat(controls.wavelength2.value), 
                ratio: parseFloat(controls.ratio21.value),       
                zeroShift: parseFloat(controls.zeroShift.value),
                profileType: profileType
            };

    //        console.log("getAllParams - Wavelength read:", params.lambda);
            
            document.querySelectorAll('#lattice-parameters-container input[type="number"]').forEach(input => {
                if (input.id.startsWith('lattice-param-')) {
                    const paramName = input.id.replace('lattice-param-', '');
                    params[paramName] = parseFloat(input.value);
                }
            });

            const { system } = getSystemAndCentering();
            switch(system) {
                case 'cubic': case 'tetragonal': case 'orthorhombic': 
                    params.alpha = params.beta = params.gamma = 90; 
                    break;
                case 'rhombohedral':
                case 'hexagonal': 
                    params.alpha = params.beta = 90; params.gamma = 120; 
                    break;
                case 'monoclinic': 
                    params.alpha = params.gamma = 90; 
                    break;
            }

            switch (profileType) {
                case "simple_pvoigt":
                    Object.assign(params, { 
                        GU: parseFloat(controls.paramGU.value), GV: parseFloat(controls.paramGV.value), 
                        GW: parseFloat(controls.paramGW.value), GP: parseFloat(controls.paramGP.value), 
                        LX: parseFloat(controls.paramLX.value), eta: parseFloat(controls.paramEta.value), 
                        shft: parseFloat(controls.paramShft.value), trns: parseFloat(controls.paramTrns.value) 
                    });
                    break;
                case "tch_aniso":
                    Object.assign(params, { 
                        U: parseFloat(controls.paramU.value), V: parseFloat(controls.paramV.value), 
                        W: parseFloat(controls.paramW.value), X: parseFloat(controls.paramX.value), 
                        Y: parseFloat(controls.paramY.value), SL: parseFloat(controls.paramSL.value), 
                        HL: parseFloat(controls.paramHL.value), S400: parseFloat(controls.paramS400.value), 
                        S040: parseFloat(controls.paramS040.value), S004: parseFloat(controls.paramS004.value), 
                        S220: parseFloat(controls.paramS220.value), S202: parseFloat(controls.paramS202.value), 
                        S022: parseFloat(controls.paramS022.value) 
                    });
                    break;
                case "split_pvoigt":
                    Object.assign(params, { 
                        GU_L: parseFloat(controls.paramGU_L.value), GV_L: parseFloat(controls.paramGV_L.value), 
                        GW_L: parseFloat(controls.paramGW_L.value), LX_L: parseFloat(controls.paramLX_L.value),
                        GU_R: parseFloat(controls.paramGU_R.value), GV_R: parseFloat(controls.paramGV_R.value), 
                        GW_R: parseFloat(controls.paramGW_R.value), LX_R: parseFloat(controls.paramLX_R.value),
                        eta_split: parseFloat(controls.paramEta_split.value),
                        shft_split: parseFloat(controls.paramShft_split.value), 
                        trns_split: parseFloat(controls.paramTrns_split.value) 
                    });
                    break;
            }


            return params;
        };

        const getFitFlags = () => {
            const profileType = controls.profileSelect.value;
            let flags = {
                a: document.getElementById('fit-lattice-a')?.checked ?? false,
                b: document.getElementById('fit-lattice-b')?.checked ?? false,
                c: document.getElementById('fit-lattice-c')?.checked ?? false,
                alpha: document.getElementById('fit-lattice-alpha')?.checked ?? false,
                beta: document.getElementById('fit-lattice-beta')?.checked ?? false,
                gamma: document.getElementById('fit-lattice-gamma')?.checked ?? false,
                zeroShift: controls.fitZeroShift.checked,
            };

            switch (profileType) {
                case "simple_pvoigt":
                    Object.assign(flags, { 
                        GU: controls.fitGU.checked, GV: controls.fitGV.checked, GW: controls.fitGW.checked, 
                        GP: controls.fitGP.checked, LX: controls.fitLX.checked, eta: controls.fitEta.checked, 
                        shft: controls.fitShft.checked, trns: controls.fitTrns.checked 
                    });
                    break;
                case "tch_aniso":
                    Object.assign(flags, { 
                        U: controls.fitU.checked, V: controls.fitV.checked, W: controls.fitW.checked, 
                        X: controls.fitX.checked, Y: controls.fitY.checked, SL: controls.fitSL.checked, 
                        HL: controls.fitHL.checked, S400: controls.fitS400.checked, 
                        S040: controls.fitS040.checked, S004: controls.fitS004.checked, 
                        S220: controls.fitS220.checked, S202: controls.fitS202.checked, 
                        S022: controls.fitS022.checked 
                    });
                    const { system } = getSystemAndCentering();
                    switch (system) {
                        case 'cubic': flags.S040 = flags.S004 = flags.S202 = flags.S022 = false; break;
                        case 'hexagonal': case 'tetragonal': case 'rhombohedral': flags.S040 = flags.S022 = false; break;
                    }
                    break;
                case "split_pvoigt":
                     Object.assign(flags, { 
                        GU_L: controls.fitGU_L.checked, GV_L: controls.fitGV_L.checked, 
                        GW_L: controls.fitGW_L.checked, LX_L: controls.fitLX_L.checked,
                        GU_R: controls.fitGU_R.checked, GV_R: controls.fitGV_R.checked, 
                        GW_R: controls.fitGW_R.checked, LX_R: controls.fitLX_R.checked,
                        eta_split: controls.fitEta_split.checked,
                        shft_split: controls.fitShft_split.checked, 
                        trns_split: controls.fitTrns_split.checked 
                    });
                    break;
            }

            return flags;
        };



/**
 * Clears the cached HKL index list for the currently selected space group.
 * This forces a full recalculation on the next request.
 */
function invalidateHklCache() {
    const selectedSgNumber = parseInt(controls.spaceGroupSelect.value, 10);
    if (selectedSgNumber && hklIndexCache[selectedSgNumber]) {
        delete hklIndexCache[selectedSgNumber];
    }
}


/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was invoked.
 * @param {Function} func The function to debounce.
 * @param {number} wait The number of milliseconds to delay.
 * @returns {Function} Returns the new debounced function.
 */
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
};



        function enforceSymmetryConstraints(params) { const { system } = getSystemAndCentering(); switch (system) { case 'cubic': if (params.S400 !== undefined) params.S040 = params.S004 = params.S400; if (params.S220 !== undefined) params.S202 = params.S022 = params.S220; break; case 'hexagonal': case 'tetragonal': case 'rhombohedral': if (params.S400 !== undefined) params.S040 = params.S400; if (params.S202 !== undefined) params.S022 = params.S202; break; } }


        function updatePreviewPattern() {
            if (!mainChart || !workingData.isValid || isFitting) return;

            const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
            const params = getAllParams();
            if (isNaN(params.lambda) || params.lambda <= 0 || isNaN(params.a) || params.a <= 0) return;
            
            const selectedSg = spaceGroups.find(sg => sg.number === parseInt(controls.spaceGroupSelect.value, 10));
            if (!selectedSg) return;

            let hklList = JSON.parse(JSON.stringify(masterHklList));
            updateHklPositions(hklList, params, selectedSg.system);
            lastGeneratedHklList = hklList; 

            if (lastFitResultsCache && lastFitResultsCache.hklList) {
                const intensityMap = new Map(
                    lastFitResultsCache.hklList.map(p => [p.hkl_list[0], p.intensity])
                );
                hklList.forEach(p => {
                    p.intensity = intensityMap.get(p.hkl_list[0]) || 0;
                });
            } else {
                hklList.forEach(p => p.intensity = 1000); 
            }
            
            const minTth = parseFloat(controls.tthMinSlider.value); 
            const maxTth = parseFloat(controls.tthMaxSlider.value);

            findDataset('HKL Markers').data = hklList
                .filter(hkl => {
                    if (!hkl.tth) return false;
                    const peakPos = hkl.tth + params.zeroShift;
                    return peakPos >= minTth && peakPos <= maxTth;
                })
                .map(hkl => ({
                    x: hkl.tth + params.zeroShift,
                    hkl: `${hkl.hkl_list[0]} [m=${hkl.multiplicity}]`
                }));

            // *** PASS SPLINE POINTS (backgroundAnchors) TO BACKGROUND CALCULATION ***
            const background_sliced = calculateTotalBackground(workingData.tth, params, backgroundAnchors);
            const unscaledPeakPattern_sliced = calculatePattern(workingData.tth, hklList, params);
            const y_obs_net_sliced = new Float64Array(workingData.intensity.length);
            for(let i = 0; i < y_obs_net_sliced.length; i++) {
                y_obs_net_sliced[i] = Math.max(0, workingData.intensity[i] - background_sliced[i]);
            }
            
            const sum_obs_calc = math.dot(Array.from(y_obs_net_sliced), Array.from(unscaledPeakPattern_sliced));
const sum_calc_sq = math.dot(Array.from(unscaledPeakPattern_sliced), Array.from(unscaledPeakPattern_sliced));
            const scaleFactor = (sum_calc_sq > 1e-9) ? sum_obs_calc / sum_calc_sq : 1.0;

            const totalCalcPattern = math.add(math.multiply(Array.from(unscaledPeakPattern_sliced), scaleFactor), Array.from(background_sliced));
const diff = math.subtract(Array.from(workingData.intensity), totalCalcPattern);

            workingData.lastRawDifference = diff;

            const simulationData = [];
            for (let i = 0; i < workingData.tth.length; i++) {
                simulationData.push({ x: workingData.tth[i], y: totalCalcPattern[i] });
            }
            findDataset('Simulation (Manual)').data = simulationData;
            findDataset('Calculated').data = [];
        }


        function updatePawleyButtonState() {
    if (!controls || !controls.algorithmSelect || !document.getElementById('pawley-button')) {
         console.error("Cannot update Pawley button: Controls not ready.");
         return; // Safety check
    }
    const selectedAlgorithm = controls.algorithmSelect.value;
    const pawleyButton = document.getElementById('pawley-button');
    const fileLoaded = fullExperimentalData && fullExperimentalData.tth.length > 0;

    // Disable Pawley if algorithm is SA or PT, OR if no file is loaded, OR if currently fitting
    if (selectedAlgorithm === 'sa' || selectedAlgorithm === 'pt' || !fileLoaded || isFitting) {
        pawleyButton.disabled = true;
        if (selectedAlgorithm === 'sa' || selectedAlgorithm === 'pt') {
             // Optionally add a title to explain why it's disabled
             pawleyButton.title = "Pawley refinement is recommended only with Levenberg-Marquardt.";
        } else {
             pawleyButton.title = ""; // Clear title if disabled for other reasons
        }
    } else {
        // Enable Pawley only for LM when a file is loaded and not fitting
        pawleyButton.disabled = false;
        pawleyButton.title = ""; // Clear title
    }
}



        // setUIState function
        function setUIState(fitting) {
        isFitting = fitting;
        const leBailButton = document.getElementById('le-bail-button');
        // const pawleyButton = document.getElementById('pawley-button'); // We handle this in updatePawleyButtonState

        // Disable Le Bail if fitting OR no file loaded
        leBailButton.disabled = fitting || (fullExperimentalData && fullExperimentalData.tth.length === 0);

        // Disable Report/Save if fitting OR no results exist
        controls.reportButton.disabled = fitting || !fitResults;
        controls.saveDataButton.disabled = fitting || !fitResults;

        // Update text content during refinement
        if (fitting) {
            leBailButton.textContent = 'Refining...';
            // Update Pawley button text too, even if disabled
            document.getElementById('pawley-button').textContent = 'Refining...';
            controls.rpResult.textContent = '...';
            controls.rwpResult.textContent = '...';
            controls.chi2Result.textContent = '...';
        } else {
            // Restore button text when not fitting
            leBailButton.textContent = 'Run Le Bail';
            document.getElementById('pawley-button').textContent = 'Run Pawley';
            if(fitResults) {
                 // Report/Save enabled state handled above based on !fitting and fitResults
            }
             // Clear background color highlights for results
            controls.rwpResult.parentElement.parentElement.querySelectorAll('.result-card').forEach(c => c.style.background = '');
        }

        controls.progressBarContainer.classList.toggle('hidden', !fitting);
        document.body.style.cursor = fitting ? 'wait' : 'default';
        if (!fitting) {
            controls.progressBar.style.width = '0%';
        }

   
        // Update Pawley button based on algorithm AND current fitting state
        updatePawleyButtonState();
    }
        
    function updateUI(params, stats, netPeakPattern_full, background_full, scaleFactor, hklList) {
            const safeUpdate = (paramValue, controlElement, digits) => { 
                if (controlElement && typeof paramValue === 'number' && isFinite(paramValue)) {
                    controlElement.value = paramValue.toFixed(digits);
                }
            };
            
            if (stats && typeof stats.r_p === 'number') controls.rpResult.textContent = stats.r_p.toFixed(2);
            if (stats && typeof stats.rwp === 'number') controls.rwpResult.textContent = stats.rwp.toFixed(2);
            if (stats && typeof stats.chi2 === 'number') controls.chi2Result.textContent = stats.chi2.toFixed(3);
            
            safeUpdate(params.a, document.getElementById('lattice-param-a'), 4);
            safeUpdate(params.b, document.getElementById('lattice-param-b'), 4);
            safeUpdate(params.c, document.getElementById('lattice-param-c'), 4);
            safeUpdate(params.alpha, document.getElementById('lattice-param-alpha'), 3);
            safeUpdate(params.beta, document.getElementById('lattice-param-beta'), 3);
            safeUpdate(params.gamma, document.getElementById('lattice-param-gamma'), 3);
            safeUpdate(params.zeroShift, controls.zeroShift, 4);
            
            const profileType = params.profileType || controls.profileSelect.value;
            switch(profileType) {
                case "simple_pvoigt":
                    safeUpdate(params.GU, controls.paramGU, 4); safeUpdate(params.GV, controls.paramGV, 4);
                    safeUpdate(params.GW, controls.paramGW, 4); safeUpdate(params.GP, controls.paramGP, 4);
                    safeUpdate(params.LX, controls.paramLX, 4); safeUpdate(params.eta, controls.paramEta, 4);
                    safeUpdate(params.shft, controls.paramShft, 4); safeUpdate(params.trns, controls.paramTrns, 4);
                    break;
                case "tch_aniso":
                    safeUpdate(params.U, controls.paramU, 4); safeUpdate(params.V, controls.paramV, 4);
                    safeUpdate(params.W, controls.paramW, 4); safeUpdate(params.X, controls.paramX, 4);
                    safeUpdate(params.Y, controls.paramY, 4); safeUpdate(params.SL, controls.paramSL, 4);
                    safeUpdate(params.HL, controls.paramHL, 4);
                    safeUpdate(params.S400, controls.paramS400, 4); safeUpdate(params.S040, controls.paramS040, 4);
                    safeUpdate(params.S004, controls.paramS004, 4); safeUpdate(params.S220, controls.paramS220, 4);
                    safeUpdate(params.S202, controls.paramS202, 4); safeUpdate(params.S022, controls.paramS022, 4);
                    break;
                case "split_pvoigt":
                    safeUpdate(params.GU_L, controls.paramGU_L, 4); safeUpdate(params.GV_L, controls.paramGV_L, 4);
                    safeUpdate(params.GW_L, controls.paramGW_L, 4); safeUpdate(params.LX_L, controls.paramLX_L, 4);
                    safeUpdate(params.GU_R, controls.paramGU_R, 4); safeUpdate(params.GV_R, controls.paramGV_R, 4);
                    safeUpdate(params.GW_R, controls.paramGW_R, 4); safeUpdate(params.LX_R, controls.paramLX_R, 4);
                    safeUpdate(params.eta_split, controls.paramEta_split, 4);
                    safeUpdate(params.shft_split, controls.paramShft_split, 4); 
                    safeUpdate(params.trns_split, controls.paramTrns_split, 4);
                    break;
            }
            

            if (netPeakPattern_full && background_full && hklList && mainChart) {
                updateChart(netPeakPattern_full, background_full, hklList, params, scaleFactor);
            }
        }

        //updateChart, sans Y auto zoom, le 7 oct 25
        function updateChart(netPeakPattern_sliced, background_sliced, hklList, params, scaleFactor = 1.0) {
            if (!mainChart || !workingData.isValid) return;

            // Store the current Y-axis zoom state BEFORE making any changes
            const currentYMin = mainChart.scales.y.min;
            const currentYMax = mainChart.scales.y.max;
            
            // --- ADDED THIS BLOCK ---
            // Store the current X-axis zoom state as well
            const currentXMin = mainChart.scales.x.min;
            const currentXMax = mainChart.scales.x.max;
            // --- END OF ADDED BLOCK ---

            const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
            
            // 1. Hide the manual simulation line, as we now have a real fit
            findDataset('Simulation (Manual)').data = [];

            // 2. Calculate the total pattern and the raw difference array
            const totalCalcPattern = math.add(math.multiply(Array.from(netPeakPattern_sliced), scaleFactor), Array.from(background_sliced));
const diff = math.subtract(Array.from(workingData.intensity), totalCalcPattern);

            // This global variable is now ready for rescalePlot to use
            workingData.lastRawDifference = diff; 

            // 3. Prepare the data for the 'Calculated' and 'Background' datasets
            const calculatedData = [];
            const backgroundData = [];
            for(let i = 0; i < workingData.tth.length; i++) {
                calculatedData.push({ x: workingData.tth[i], y: totalCalcPattern[i] });
                backgroundData.push({ x: workingData.tth[i], y: background_sliced[i] });
            }
            findDataset('Calculated').data = calculatedData;
            findDataset('Background').data = backgroundData;


            // 4. Restore the Y-axis zoom state FIRST. This sets the final "frame" for the chart.
            mainChart.options.scales.y.min = currentYMin;
            mainChart.options.scales.y.max = currentYMax;

           
            // 4b. Restore the X-axis zoom state.
            mainChart.options.scales.x.min = currentXMin;
            mainChart.options.scales.x.max = currentXMax;
           
            rescalePlot(false); 
            
            mainChart.update('none');
        }

        function getPeakInfoAt(tth) {
            if (!lastGeneratedHklList || lastGeneratedHklList.length === 0 || !mainChart) return { peak: null, inRegion: false };
            let closestPeak = null, minDiff = Infinity; const currentParams = getAllParams(); const zeroShift = currentParams.zeroShift || 0;
            for (const hkl of lastGeneratedHklList) { const peakShift = calculatePeakShift(hkl.tth, currentParams); const peakPos = hkl.tth + zeroShift + peakShift; const diff = Math.abs(tth - peakPos); if (diff < minDiff) { minDiff = diff; closestPeak = hkl; } }
            if (closestPeak) { 
                const threshold = 0.2;
                   if (minDiff < threshold) return { peak: closestPeak, inRegion: true }; }
            return { peak: null, inRegion: false };
        }


        function initializeChart() {
            if (mainChart) mainChart.destroy();

            const experimentalPoints = [];
            for (let i = 0; i < fullExperimentalData.tth.length; i++) {
                experimentalPoints.push({ x: fullExperimentalData.tth[i], y: fullExperimentalData.intensity[i] });
            }
            
            const yMax = Math.max(...fullExperimentalData.intensity) || 1000;
            mainChart = new Chart(controls.mainChartCanvas, {
                type: 'line',
                data: { 
                    datasets: [
                        { label: 'Experimental', data: experimentalPoints, borderColor: 'rgba(107, 114, 128, 0.7)', borderWidth: 0.5, pointRadius: 1, pointBackgroundColor: 'rgba(107, 114, 128, 0.7)', order: 1 },
                        { label: 'Simulation (Manual)', data: [], borderColor: 'rgba(249, 115, 22, 0.8)', borderWidth: 2, pointRadius: 0, borderDash: [8, 4], order: 2 },
                        { label: 'Calculated', data: [], borderColor: 'rgba(59, 130, 246, 1)', borderWidth: 2, pointRadius: 0, order: 3 },
                        { label: 'Background', data: [], borderColor: 'rgba(2, 9, 206, 0.8)', borderWidth: 1.5, pointRadius: 0, borderDash: [5, 5], order: 4 },
                        { label: 'Difference', data: [], borderColor: 'rgba(239, 68, 68, 0.8)', borderWidth: 1.5, pointRadius: 0, order: 5 },
                        { label: 'Difference Zero', data: [], borderColor: 'rgba(156, 163, 175, 0.8)', borderWidth: 1, pointRadius: 0, borderDash: [2, 2], order: 6 },
                        { type: 'bar', label: 'HKL Markers', data: [], backgroundColor: 'rgba(22, 163, 74, 0.9)', barThickness: 1, categoryPercentage: 1.0, barPercentage: 1.0, order: 0 },
                        {
                            label: 'Spline Points', // <-- RENAMED LABEL
                            type: 'scatter',
                            data: [], // Initially empty
                            showLine: false,
                            pointBackgroundColor: 'rgba(34, 197, 94, 1)', // A vibrant green
                            pointBorderColor: 'rgba(255, 255, 255, 0.9)',
                            pointRadius: 5,
                            pointHoverRadius: 7,
                            pointBorderWidth: 1.5,
                            order: -1 // Render on top of everything
                        }
                    ]
                },
                options: {
                    responsive: true, maintainAspectRatio: false, animation: false,
                    scales: {
                        x: { type: 'linear', title: { display: true, text: '2θ (degrees)', font: { size: 14 }}},
                        y: { type: 'linear', position: 'left', title: { display: true, text: 'Intensity (a.u.)', font: { size: 14 }},
                            min: -yMax * 0.3, max: Math.ceil(yMax * 1.1),
                            ticks: { callback: function(value, index, ticks) { return value >= 0 ? value.toFixed(1) : null; }}
                        }
                    },
                    plugins: {
                        zoom: {
                            pan: { enabled: true, mode: 'xy', threshold: 5, onPanComplete: () => rescalePlot(false) },
                            zoom: { wheel: { enabled: false }, pinch: { enabled: true }, drag: { enabled: false }, onZoomComplete: () => rescalePlot(false) }
                        },
                        legend: { labels: { filter: item => item.text !== 'Difference Zero' && item.text !== 'Simulation (Manual)' && item.text !== 'Spline Points'}},
                        tooltip: {
                            enabled: true,
                            mode: 'nearest',
                            intersect: false,
                            position: 'experimentalAnchor',
                            filter: function(tooltipItem) {
                                const tth = tooltipItem.parsed.x;
                                const peakInfo = getPeakInfoAt(tth);
                                return peakInfo.inRegion;
                            },
                            callbacks: {
                                title: function(tooltipItems) {
                                    if (!tooltipItems.length) return '';
                                    const tth = tooltipItems[0].parsed.x;
                                    const peakInfo = getPeakInfoAt(tth);
                                    if (peakInfo.inRegion) {
                                        const closestPeak = peakInfo.peak;
                                        return `d: ${closestPeak.d.toFixed(2)} Å, HKL: ${closestPeak.hkl_list[0]}`;
                                    }
                                    return '';
                                },
                                label: function(context) {
                                    return null;
                                }
                            }
                        }
                    }
                }
            });
            mainChart.options.globalYMax = yMax;
        }


    function updatePlotRange(recalculateYMax = false) {
            if (!mainChart || workingData.tth.length === 0) {
                return;
            }
            const minTth = parseFloat(controls.tthMinSlider.value);
            const maxTth = parseFloat(controls.tthMaxSlider.value);

            // Explicitly set the x-axis limits
            mainChart.options.scales.x.min = minTth;
            mainChart.options.scales.x.max = maxTth;

            // Recalculate Y-axis if needed
            if (recalculateYMax) {
                // Find the max intensity within the current workingData range
                const currentMaxY = Math.max(...workingData.intensity);
                let newYMax = currentMaxY * 1.1; // Add 10% padding
                if (newYMax < 100) newYMax = 100; // Minimum Y-max

                // Constant negative space for difference plot
                mainChart.options.globalYMax = newYMax; // Store this globally
                mainChart.options.scales.y.max = newYMax;
                mainChart.options.scales.y.min = -(newYMax * 0.3); // Allocate 30% for difference plot
            }
            
            mainChart.update('none');
        }        

        function rescalePlot(updateY = false) {
        // === CONFIGURABLE PARAMETERS FOR DIFFERENCE PLOT ===
        const DIFF_PLOT_MIN_RATIO = 0.1;  // Minimum allocation: 10% of Y scale
        const DIFF_PLOT_MAX_RATIO = 0.3;  // Maximum allocation: 30% of Y scale
        const DIFF_PLOT_PADDING = 1.1;     // Padding factor (1.1 = 10% extra space)
        // =======

        if (!mainChart || !workingData.isValid) return;

        const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
        const globalYMax = mainChart.options.globalYMax;

        // --- DYNAMIC DIFFERENCE PLOT ALLOCATION ---
        let diffPlotHeightRatio = 0.15; // Default allocation

        // This is the source of truth for the difference plot's magnitude
        const diffData = workingData.lastRawDifference || [];
        
        if (diffData.length > 0) {
            const maxAbsDiff = Math.max(...diffData.map(Math.abs));
            if (globalYMax > 0) {
                const requiredRatio = (maxAbsDiff * DIFF_PLOT_PADDING) / globalYMax;
                diffPlotHeightRatio = Math.max(DIFF_PLOT_MIN_RATIO, Math.min(DIFF_PLOT_MAX_RATIO, requiredRatio));
            }
        }

        const constantNegSpaceHeight = globalYMax * diffPlotHeightRatio;

        // Update Y-axis 
        if (updateY) {
            mainChart.options.scales.y.max = globalYMax;
            // --- This line was moved inside the if(updateY) block ---
            mainChart.options.scales.y.min = -constantNegSpaceHeight;
        }
        
        // --- The problematic line was REMOVED from here ---
        
        // Draw HKL Markers
        const hklDataset = findDataset('HKL Markers');
        if (hklDataset && hklDataset.data.length > 0) {
            const HKL_MARKER_PIXEL_HEIGHT = 20;
            const y_scale = mainChart.scales.y;
            const zeroLineValue = 0; 
            const bottomPixel = y_scale.getPixelForValue(zeroLineValue);
            const topPixel = bottomPixel + HKL_MARKER_PIXEL_HEIGHT;
            const markerBottom = zeroLineValue;
            const markerTop = y_scale.getValueForPixel(topPixel);
            hklDataset.data.forEach(point => point.y = [markerTop, markerBottom]);
        }


        // --- Plot TRUE difference from the stored `lastRawDifference` array ---
        if (diffData.length > 0 && diffData.length === workingData.tth.length) {
            const constantDiffPlotSpaceTop = -(constantNegSpaceHeight * 0.25);
            const diffPlotZeroLine = -constantNegSpaceHeight + (constantNegSpaceHeight - constantDiffPlotSpaceTop) / 2;

            const differenceDataPoints = [];
            for (let i = 0; i < workingData.tth.length; i++) {
                const difference = diffData[i];
                differenceDataPoints.push({ x: workingData.tth[i], y: difference + diffPlotZeroLine });
            }
            findDataset('Difference').data = differenceDataPoints;

            findDataset('Difference Zero').data = [
                { x: workingData.tth[0], y: diffPlotZeroLine },
                { x: workingData.tth[workingData.tth.length - 1], y: diffPlotZeroLine }
            ];
        } else {
            // If there's no valid difference data, clear the lines.
            findDataset('Difference').data = [];
            findDataset('Difference Zero').data = [];
        }
    }

        function downloadTextFile(content, filename) {
            const element = document.createElement('a');
            const file = new Blob([content], {type: 'text/plain;charset=utf-8'});
            element.href = URL.createObjectURL(file);
            element.download = filename;
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
        }


        function showToast(message, type = 'error', duration = 4000) {
            let container = document.getElementById('toast-container');
            if (!container) {
                container = document.createElement('div');
                container.id = 'toast-container';
                document.body.appendChild(container);
            }

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;

            container.appendChild(toast);

            // Trigger the slide-in animation
            setTimeout(() => {
                toast.classList.add('show');
            }, 10);

            // Set a timer to hide and then remove the toast
            setTimeout(() => {
                toast.classList.remove('show');
                // Remove the element from the DOM after the fade-out transition completes
                toast.addEventListener('transitionend', () => toast.remove());
            }, duration);
        }

        /**
         * Calculates the observed integrated intensity for all peaks by partitioning the net
         * experimental intensity at each point according to the *full calculated (Ka1+Ka2) profile*.
         * This correctly handles overlapping reflections for Pawley reports.
         * @param {Array<object>} hklList - The list of HKL reflections (with .intensity as Height).
         * @param {object} params - The final refined parameters object.
         * @param {object} expData - The working experimental data {tth, intensity}.
         * @returns {Map<string, number>} A map where keys are HKL strings and values are the calculated I_obs.
         */
        function calculateAllObservedIntensities(hklList, params, expData) {
            const n_points = expData.tth.length;
            if (n_points === 0) return new Map();

            // This array will hold the (Height * (Shape_Ka1 + ratio * Shape_Ka2)) value
            const peak_profiles_scaled = new Array(hklList.length);
            
            // This will be the sum of all scaled profiles, i.e., the net calculated pattern
            const total_profile_sum_scaled = new Array(n_points).fill(0);

            // 1. Pre-calculate the theoretical (Height * [Shape_Ka1 + ratio*Shape_Ka2]) profile for every peak
            const deg2rad = Math.PI / 180;
            const lambda1 = params.lambda || 1.54056;
            const lambda2 = params.lambda2 || 0;
            const ratio21 = params.ratio || 0;
            const doubletEnabled = ratio21 > 1e-6 && lambda2 > 1e-6 && Math.abs(lambda1 - lambda2) > 1e-6;

            hklList.forEach((peak, j) => {
                const current_peak_profile = new Array(n_points).fill(0);
                const refined_height = peak.intensity || 0; 

                if (!peak.tth || refined_height <= 1e-9) { // Skip if peak has no height
                    peak_profiles_scaled[j] = current_peak_profile;
                    return;
                }
                
                // --- Get Ka1 info ---
                const basePos1 = peak.tth + params.zeroShift;
                const shift1 = calculatePeakShift(basePos1, params);
                const peakPos1 = basePos1 + shift1;
                const { gamma_G: gG1, gamma_L: gL1 } = calculateProfileWidths(basePos1, peak, params);
                const window1 = CALCULATION_WINDOW_MULTIPLIER * Math.max(0.01, gG1 + gL1);
                const min_tth1 = peakPos1 - window1;
                const max_tth1 = peakPos1 + window1;

                // --- Get Ka2 info ---
                let tth2 = null, basePos2 = null, peakPos2 = null, min_tth2 = 0, max_tth2 = 0;
                if (doubletEnabled) {
                    const sinTheta1 = Math.sin(peak.tth * deg2rad / 2.0);
                    const sinTheta2 = sinTheta1 * (lambda1 > 1e-6 ? (lambda2 / lambda1) : 1.0);
                    if (Math.abs(sinTheta2) < 1) {
                        tth2 = 2 * Math.asin(sinTheta2) / deg2rad;
                        basePos2 = tth2 + params.zeroShift;
                        const shift2 = calculatePeakShift(basePos2, params);
                        peakPos2 = basePos2 + shift2;
                        const { gamma_G: gG2, gamma_L: gL2 } = calculateProfileWidths(basePos2, peak, params);
                        const window2 = CALCULATION_WINDOW_MULTIPLIER * Math.max(0.01, gG2 + gL2);
                        min_tth2 = peakPos2 - window2;
                        max_tth2 = peakPos2 + window2;
                    } else {
                        tth2 = null; // Ka2 not calculable
                    }
                }
                
                // --- Loop over data points to build the full (Ka1+Ka2) scaled profile ---
                for (let i = 0; i < n_points; i++) {
                    const current_tth = expData.tth[i];
                    let total_scaled_val = 0;

                    // Ka1 contribution
                    if (current_tth >= min_tth1 && current_tth <= max_tth1) {
                        const shape_val1 = pseudoVoigt(current_tth, peakPos1, basePos1, peak, params);
                        total_scaled_val += refined_height * shape_val1;
                    }
                    
                    // Ka2 contribution
                    if (tth2 && current_tth >= min_tth2 && current_tth <= max_tth2) {
                        const shape_val2 = pseudoVoigt(current_tth, peakPos2, basePos2, peak, params);
                        total_scaled_val += refined_height * ratio21 * shape_val2;
                    }

                    // Use a small cutoff to store the value
                    if (total_scaled_val > 1e-5 * refined_height) {
                         current_peak_profile[i] = total_scaled_val;
                         total_profile_sum_scaled[i] += total_scaled_val;
                    }
                }
                peak_profiles_scaled[j] = current_peak_profile;
            });

            // 2. Partition the experimental intensity and integrate
            // *** PASS SPLINE POINTS (backgroundAnchors) TO BACKGROUND CALCULATION ***
            const finalBkg = calculateTotalBackground(expData.tth, params, backgroundAnchors);
            const i_obs_map = new Map();

            for (let i = 1; i < n_points; i++) {
                const step_width = expData.tth[i] - expData.tth[i-1];
                if (step_width <= 0) continue;

                const prev_y_obs_net = Math.max(0, expData.intensity[i-1] - finalBkg[i-1]);
                const current_y_obs_net = Math.max(0, expData.intensity[i] - finalBkg[i]);

                hklList.forEach((peak, j) => {
                    const hkl_string = peak.hkl_list[0];
                    if (!i_obs_map.has(hkl_string)) {
                        i_obs_map.set(hkl_string, 0);
                    }

                    // The fraction is now based on the full (Ka1+Ka2) scaled profile
                    const prev_fraction = total_profile_sum_scaled[i-1] > 1e-9 ? peak_profiles_scaled[j][i-1] / total_profile_sum_scaled[i-1] : 0;
                    const current_fraction = total_profile_sum_scaled[i] > 1e-9 ? peak_profiles_scaled[j][i] / total_profile_sum_scaled[i] : 0;
                    
                    const prev_partitioned_I = prev_y_obs_net * prev_fraction;
                    const current_partitioned_I = current_y_obs_net * current_fraction;
                    
                    const trapezoid_area = (prev_partitioned_I + current_partitioned_I) / 2 * step_width;
                    
                    if (isFinite(trapezoid_area) && trapezoid_area > 0) {
                        i_obs_map.set(hkl_string, i_obs_map.get(hkl_string) + trapezoid_area);
                    }
                });
            }
            return i_obs_map;
        }

        function generateReportContent(format = 'summary') {
            // Ensure fit results and necessary data are available
            if (!fitResults || !fitResults.params || !fitResults.stats || !fitResults.fitFlags || !fitResults.hklList) {
                return "Error: Fit results are incomplete or not available.";
            }
             if (fitResults.algorithm === 'lm' && (!workerWorkingData || !workerWorkingData.intensity || workerWorkingData.intensity.length === 0)) {
                 console.warn("generateReportContent: workingData slice not available for ESD calculation.");
            }

            const now = new Date();
            const { params: finalParams, stats, fitFlags, hklList, algorithm, refinementMode, JtJ, parameterInfo, ss_res } = fitResults;
            const mainScaleFactor = stats.scaleFactor || 1.0;

            const formatLine = (cols, widths) => {
                return cols.map((col, i) => {
                     const colStr = (col === null || col === undefined) ? '-' : String(col);
                     // Pad numbers to the left within their column width for alignment
                     if (typeof col === 'number' && i > 0 && widths[i] > 0) {
                         return colStr.padStart(widths[i]);
                     }
                     return colStr.padEnd(widths[i]);
                 }).join(' ');
            };

            const modeName = refinementMode === 'pawley' ? 'Pawley' : 'Le Bail';
            const header = [
                `${modeName} Refinement Report`,
                '========================================================================',
                '',
                `Powder5, version 115, 27 Oct 2025`,
                `Report Generated: ${now.toLocaleString()}`,
                `Data File: ${controls.fileName.textContent || 'N/A'}`,
                ''
            ];

            const algorithmNames = {
                lm: 'Levenberg-Marquardt',
                sa: 'Simulated Annealing',
                pt: 'Parallel Tempering'
            };
            const algorithmName = algorithmNames[algorithm] || 'Unknown';

            const profileNameMap = {
                "simple_pvoigt": "Simple pVoigt",
                "tch_aniso": "TCH (Size/Strain/Aniso)",
                "split_pvoigt": "Split pVoigt (Asymmetric)"
            };
            const profileType = finalParams.profileType || "simple_pvoigt";
            const profileName = profileNameMap[profileType] || "Unknown Profile";

            const selectedSg = spaceGroups.find(sg => sg.number === parseInt(controls.spaceGroupSelect.value, 10));
            const spaceGroupName = selectedSg ? `${selectedSg.number} – ${selectedSg.name}` : 'N/A';

            const statsSection = [
                '--- Refinement Statistics ---',
                `Rp (%):       ${stats.r_p !== undefined ? stats.r_p.toFixed(3) : 'N/A'}`,
                `Rwp (%):      ${stats.rwp !== undefined ? stats.rwp.toFixed(3) : 'N/A'}`,
                `χ² (GOF):     ${stats.chi2 !== undefined ? stats.chi2.toFixed(3) : 'N/A'}`,
                `Algorithm:    ${algorithmName}`,
                `Refinement:   ${modeName}`,
                `Profile:      ${profileName} (${profileType})`,
                `Space Group:  ${spaceGroupName}`,
                ''
            ];

            let whAnalysisSection = [];
            if (profileType === "tch_aniso" && hklList && hklList.length > 0 && workerWorkingData && workerWorkingData.tth) {
                try {
                    const whResults = calculateWilliamsonHall(finalParams, hklList);
                    if (whResults) {
                        whAnalysisSection.push(
                            '--- Williamson-Hall Size/Strain Analysis (Approximate) ---',
                            `Apparent Crystallite Size (nm): ${whResults.size_nm !== undefined ? whResults.size_nm.toFixed(1) : 'N/A'}`,
                            `Apparent Microstrain (%):      ${whResults.strain_percent !== undefined ? whResults.strain_percent.toFixed(4) : 'N/A'}`,
                            `Linear Fit R²:                 ${whResults.r_squared !== undefined ? whResults.r_squared.toFixed(5) : 'N/A'}`,
                            '(Note: Assumes isotropic size/strain broadening via TCH U, X, Y)',
                            ''
                        );
                    }
                 } catch (whError) {
                     console.warn("Could not calculate Williamson-Hall:", whError);
                     whAnalysisSection.push('--- Williamson-Hall Size/Strain Analysis ---', '(Calculation failed)', '');
                 }
            }


            let esds = {};
            let esdWarning = null;
            if (algorithm === 'lm' && JtJ && parameterInfo && ss_res !== undefined && workerWorkingData && workerWorkingData.intensity && workerWorkingData.intensity.length > 0) {
                 const P = parameterInfo.length;
                 const N = workerWorkingData.intensity.length;
                 if (P === 0) {
                     esdWarning = "No parameters were refined.";
                 } else if (N > P) {
                     const degreesOfFreedom = N - P;
                     if (ss_res >= 0 && isFinite(ss_res)) {
                          const reduced_chi_sq = (degreesOfFreedom > 0) ? (ss_res / degreesOfFreedom) : 0;
                          let cov_matrix = null;
                          try {
                               if (Array.isArray(JtJ) && JtJ.length === P && Array.isArray(JtJ[0]) && JtJ[0].length === P) {
                                   const H_inv = math.inv(JtJ);
                                   if (H_inv) {
                                        cov_matrix = math.multiply(H_inv, reduced_chi_sq);
                                   } else {
                                        throw new Error("Matrix inversion returned null.");
                                   }
                               } else {
                                    throw new Error("JtJ matrix has incorrect dimensions or format.");
                               }
                          } catch (invError) {
                               console.error("Matrix inversion error:", invError);
                               cov_matrix = null;
                          }
                          if (cov_matrix) {
                              parameterInfo.forEach((p_info, i) => {
                                   if (cov_matrix[i] && cov_matrix[i][i] !== undefined) {
                                       const variance = cov_matrix[i][i];
                                        if (variance >= 0 && isFinite(variance)) {
                                            const sigma_scaled = Math.sqrt(variance);
                                            const scale = p_info.scale || 1.0;
                                            esds[p_info.name] = sigma_scaled * scale;
                                        } else {
                                             console.warn(`Invalid or negative variance term for parameter ${p_info.name}:`, variance);
                                             esds[p_info.name] = NaN;
                                             esdWarning = esdWarning || 'Negative/invalid variance encountered.';
                                        }
                                   } else {
                                        console.warn(`Missing diagonal element [${i},${i}] in covariance matrix for parameter ${p_info.name}`);
                                        esds[p_info.name] = NaN;
                                        esdWarning = esdWarning || 'Covariance matrix calculation issue.';
                                   }
                              });
                          } else {
                               esdWarning = 'Covariance matrix calculation failed (likely high parameter correlation or singularity).';
                          }
                     } else {
                          esdWarning = "Invalid sum of squared residuals (ss_res) for variance calculation.";
                     }
                 } else {
                     esdWarning = `N (${N}) <= P (${P}), cannot calculate reliable errors.`;
                 }
            } else if (algorithm !== 'lm') {
                esdWarning = "ESDs only available for Levenberg-Marquardt.";
            } else if (!JtJ || !parameterInfo || ss_res === undefined || !workerWorkingData || !workerWorkingData.intensity || !workerWorkingData.intensity.length === 0) {
                 esdWarning = "Required data for ESD calculation is missing (JtJ, parameterInfo, ss_res, or workingData).";
            }

            const paramWidths = [24, 18, 10, 18]; // Name, Value, Fitted, ESD
            const paramHeader = formatLine(['Parameter', 'Value', 'Fitted', 'ESD'], paramWidths);
            const paramLines = [];
            const paramGroups = {};

            const addParam = (group, name, value, flag, esd_key) => {
                 // Check if value is defined and not null before adding
                 if (value !== undefined && value !== null) {
                     group.push({ name: name, value: value, flag: flag, esd_key: esd_key });
                 }
            };

            paramGroups['Structural & Instrumental'] = [];
            addParam(paramGroups['Structural & Instrumental'], 'a (Å)', finalParams.a, fitFlags.a, 'a');
            addParam(paramGroups['Structural & Instrumental'], 'b (Å)', finalParams.b, fitFlags.b, 'b');
            addParam(paramGroups['Structural & Instrumental'], 'c (Å)', finalParams.c, fitFlags.c, 'c');
            addParam(paramGroups['Structural & Instrumental'], 'alpha (°)', finalParams.alpha, fitFlags.alpha, 'alpha');
            addParam(paramGroups['Structural & Instrumental'], 'beta (°)', finalParams.beta, fitFlags.beta, 'beta');
            addParam(paramGroups['Structural & Instrumental'], 'gamma (°)', finalParams.gamma, fitFlags.gamma, 'gamma');
            addParam(paramGroups['Structural & Instrumental'], 'Radiation 1 (Å)', finalParams.lambda, undefined, undefined);
            addParam(paramGroups['Structural & Instrumental'], 'Radiation 2 (Å)', finalParams.lambda2, undefined, undefined);
            addParam(paramGroups['Structural & Instrumental'], 'Ratio (I2/I1)', finalParams.ratio, undefined, undefined);
            addParam(paramGroups['Structural & Instrumental'], 'Zero Shift (°)', finalParams.zeroShift, fitFlags.zeroShift, 'zeroShift');
            addParam(paramGroups['Structural & Instrumental'], '2theta Min (°)', workerWorkingData ? workerWorkingData.tth[0] : null, undefined, undefined);
            addParam(paramGroups['Structural & Instrumental'], '2theta Max (°)', workerWorkingData ? workerWorkingData.tth[workerWorkingData.tth.length - 1] : null, undefined, undefined);

            paramGroups['Profile Parameters'] = [];
            switch (profileType) {
                case "simple_pvoigt":
                    addParam(paramGroups['Profile Parameters'], 'GU', finalParams.GU, fitFlags.GU, 'GU');
                    addParam(paramGroups['Profile Parameters'], 'GV', finalParams.GV, fitFlags.GV, 'GV');
                    addParam(paramGroups['Profile Parameters'], 'GW', finalParams.GW, fitFlags.GW, 'GW');
                    addParam(paramGroups['Profile Parameters'], 'GP', finalParams.GP, fitFlags.GP, 'GP');
                    addParam(paramGroups['Profile Parameters'], 'LX', finalParams.LX, fitFlags.LX, 'LX');
                    addParam(paramGroups['Profile Parameters'], 'eta (Mixing)', finalParams.eta, fitFlags.eta, 'eta');
                    addParam(paramGroups['Profile Parameters'], 'shft (Displ.)', finalParams.shft, fitFlags.shft, 'shft');
                    addParam(paramGroups['Profile Parameters'], 'trns (Transp.)', finalParams.trns, fitFlags.trns, 'trns');
                    break;
                case "tch_aniso":
                    addParam(paramGroups['Profile Parameters'], 'U', finalParams.U, fitFlags.U, 'U');
                    addParam(paramGroups['Profile Parameters'], 'V', finalParams.V, fitFlags.V, 'V');
                    addParam(paramGroups['Profile Parameters'], 'W', finalParams.W, fitFlags.W, 'W');
                    addParam(paramGroups['Profile Parameters'], 'X', finalParams.X, fitFlags.X, 'X');
                    addParam(paramGroups['Profile Parameters'], 'Y', finalParams.Y, fitFlags.Y, 'Y');
                    addParam(paramGroups['Profile Parameters'], 'S/L (Asymm)', finalParams.SL, fitFlags.SL, 'SL');
                    addParam(paramGroups['Profile Parameters'], 'H/L (Asymm)', finalParams.HL, fitFlags.HL, 'HL');
                    addParam(paramGroups['Profile Parameters'], 'S400', finalParams.S400, fitFlags.S400, 'S400');
                    addParam(paramGroups['Profile Parameters'], 'S040', finalParams.S040, fitFlags.S040, 'S040');
                    addParam(paramGroups['Profile Parameters'], 'S004', finalParams.S004, fitFlags.S004, 'S004');
                    addParam(paramGroups['Profile Parameters'], 'S220', finalParams.S220, fitFlags.S220, 'S220');
                    addParam(paramGroups['Profile Parameters'], 'S202', finalParams.S202, fitFlags.S202, 'S202');
                    addParam(paramGroups['Profile Parameters'], 'S022', finalParams.S022, fitFlags.S022, 'S022');
                    break;
                case "split_pvoigt":
                    addParam(paramGroups['Profile Parameters'], 'GU-L', finalParams.GU_L, fitFlags.GU_L, 'GU_L');
                    addParam(paramGroups['Profile Parameters'], 'GV-L', finalParams.GV_L, fitFlags.GV_L, 'GV_L');
                    addParam(paramGroups['Profile Parameters'], 'GW-L', finalParams.GW_L, fitFlags.GW_L, 'GW_L');
                    addParam(paramGroups['Profile Parameters'], 'LX-L', finalParams.LX_L, fitFlags.LX_L, 'LX_L');
                    addParam(paramGroups['Profile Parameters'], 'GU-R', finalParams.GU_R, fitFlags.GU_R, 'GU_R');
                    addParam(paramGroups['Profile Parameters'], 'GV-R', finalParams.GV_R, fitFlags.GV_R, 'GV_R');
                    addParam(paramGroups['Profile Parameters'], 'GW-R', finalParams.GW_R, fitFlags.GW_R, 'GW_R');
                    addParam(paramGroups['Profile Parameters'], 'LX-R', finalParams.LX_R, fitFlags.LX_R, 'LX_R');
                    addParam(paramGroups['Profile Parameters'], 'eta (Mixing)', finalParams.eta_split, fitFlags.eta_split, 'eta_split');
                    addParam(paramGroups['Profile Parameters'], 'shft (Displ.)', finalParams.shft_split, fitFlags.shft_split, 'shft_split');
                    addParam(paramGroups['Profile Parameters'], 'trns (Transp.)', finalParams.trns_split, fitFlags.trns_split, 'trns_split');
                    break;
            }

            // Removed Background Parameters section (Chebyshev/Hump)

            for (const groupName in paramGroups) {
                // Ensure group exists and has items before adding headers
                if (paramGroups[groupName] && paramGroups[groupName].length > 0) {
                    paramLines.push(`--- ${groupName} ---`, paramHeader, '-'.repeat(paramHeader.length));
                    paramGroups[groupName].forEach(p => {
                         // Check value is valid number before formatting
                         if (p.value !== null && !isNaN(p.value)) {
                            const valStr = (typeof p.value === 'number') ? p.value.toExponential(6) : String(p.value);
                            const fitStr = (p.flag === undefined) ? '' : (p.flag ? 'Yes' : 'No');
                            let esdStr = '';
                            if (p.flag && p.esd_key) {
                                const esdValue = esds[p.esd_key];
                                if (typeof esdValue === 'number' && isFinite(esdValue)) {
                                     esdStr = `(${esdValue.toExponential(2)})`;
                                } else if (isNaN(esdValue)) {
                                     esdStr = '(NaN)';
                                }
                            }
                            paramLines.push(formatLine([p.name, valStr, fitStr, esdStr], paramWidths));
                        }
                    });
                    paramLines.push(''); // Add blank line after each group
                }
            }
            if (esdWarning) {
                 paramLines.push(`NOTE regarding ESDs: ${esdWarning}`, ''); // Add blank line after warning
            }


            // --- ADDED: Background Points Section ---
            const backgroundPointsSection = [];
            if (backgroundAnchors && backgroundAnchors.length > 0) {
                 const bgWidths = [15, 18]; // 2theta, Intensity
                 const bgHeader = formatLine(['2theta (°)', 'Intensity'], bgWidths);
                 backgroundPointsSection.push('', '--- Background Spline Points ---', bgHeader, '-'.repeat(bgHeader.length));
                 // Use a copy sorted by tth for the report
                 const sortedAnchors = [...backgroundAnchors].sort((a, b) => a.tth - b.tth);
                 sortedAnchors.forEach(point => {
                     backgroundPointsSection.push(formatLine([
                         point.tth.toFixed(4),
                         point.y.toFixed(2)
                     ], bgWidths));
                 });
                 backgroundPointsSection.push(''); // Add blank line after section
            }
            // --- END ADDED SECTION ---


            const reflectionsSection = [];
            if (hklList && hklList.length > 0 && workerWorkingData && workerWorkingData.tth) {
                const i_calc_header = refinementMode === 'pawley' ? 'I_refined' : 'I_extracted';
                // Adjusted widths slightly for better alignment
                const reflWidths = [15, 18, 18, 18, 18];
                const reflHeader = formatLine(['h,k,l', '2th_corr (°)', i_calc_header, 'ESD(I)', 'I_obs (Area)'], reflWidths);
                reflectionsSection.push('', '--- Reflections List (Integrated Intensities) ---', reflHeader, '-'.repeat(reflHeader.length));

                let i_obs_map = new Map();
                try {
                     i_obs_map = calculateAllObservedIntensities(hklList, finalParams, workerWorkingData);
                } catch(iobsError) {
                     console.error("Error calculating observed intensities:", iobsError);
                     reflectionsSection.push("(Error calculating I_obs)");
                }

                const fitted_tth_min = workerWorkingData.tth[0];
                const fitted_tth_max = workerWorkingData.tth[workerWorkingData.tth.length - 1];

                hklList.filter(hkl => hkl && hkl.tth && hkl.tth >= fitted_tth_min && hkl.tth <= fitted_tth_max)
                    .forEach(hkl => {
                         let tthCorr = hkl.tth;
                         if (finalParams.zeroShift) tthCorr += finalParams.zeroShift;
                         try {
                             tthCorr += calculatePeakShift(hkl.tth, finalParams);
                         } catch { /* ignore shift error */ }

                        const i_calc_height = hkl.intensity || 0;
                        const shapeArea_Ka1 = getPseudoVoigtArea(hkl.tth, hkl, finalParams);
                        let total_calc_area = i_calc_height * shapeArea_Ka1;
                        let total_esd_factor = shapeArea_Ka1;

                        const lambda1 = finalParams.lambda;
                        const lambda2 = finalParams.lambda2;
                        const ratio21 = finalParams.ratio;
                        const doubletEnabled = ratio21 > 1e-6 && lambda2 > 1e-6 && Math.abs(lambda1 - lambda2) > 1e-6;

                        if (doubletEnabled && i_calc_height > 0) {
                            const deg2rad = Math.PI / 180;
                            const sinTheta1 = Math.sin(hkl.tth * deg2rad / 2.0);
                            const sinTheta2 = sinTheta1 * (lambda1 > 1e-6 ? (lambda2 / lambda1) : 1.0);

                            if (Math.abs(sinTheta2) < 1) {
                                const tth2 = 2 * Math.asin(sinTheta2) / deg2rad;
                                const shapeArea_Ka2 = getPseudoVoigtArea(tth2, hkl, finalParams);
                                total_calc_area += i_calc_height * ratio21 * shapeArea_Ka2;
                                total_esd_factor += ratio21 * shapeArea_Ka2;
                            }
                        }

                        const i_obs = i_obs_map.get(hkl.hkl_list[0]) || 0;
                        let esd_I_str = '';

                        if (refinementMode === 'pawley') {
                             const hkl_name = `I_(${hkl.h_orig},${hkl.k_orig},${hkl.l_orig})`;
                             const esd_I_val_height = esds[hkl_name];

                             if (typeof esd_I_val_height === 'number' && isFinite(esd_I_val_height)) {
                                 const esd_I_val_area = esd_I_val_height * total_esd_factor;
                                 esd_I_str = `(${esd_I_val_area.toFixed(1)})`;
                             } else if (isNaN(esd_I_val_height)) {
                                 esd_I_str = '(NaN)';
                             }
                        }

                        if (i_obs > 0.01 || total_calc_area > 0.01) {
                            reflectionsSection.push(formatLine([
                                hkl.hkl_list[0],
                                tthCorr.toFixed(4),
                                total_calc_area.toFixed(1),
                                esd_I_str,
                                i_obs.toFixed(1)
                            ], reflWidths));
                        }
                    });
            }

            const dataSection = [];
            if (format === 'full' && workerWorkingData && workerWorkingData.tth) {
                 dataSection.push('', '--- Point-by-Point Intensity Data (Fitted Range Only) ---',
                     formatLine(['2theta', 'I_obs', 'I_calc', 'Difference', 'Background'], [15, 18, 18, 18, 18]),
                     '-'.repeat(15+18+18+18+18+4));

                 try {
                     const finalBkg = calculateTotalBackground(workerWorkingData.tth, finalParams, backgroundAnchors); // Pass anchors
                     const finalNetPattern = calculatePattern(workerWorkingData.tth, hklList, finalParams);
                     const finalCalcPattern = math.add(math.multiply(Array.from(finalNetPattern), mainScaleFactor), Array.from(finalBkg));

                     for (let i = 0; i < workerWorkingData.tth.length; i++) {
                         const i_obs = workerWorkingData.intensity[i];
                         const i_calc = finalCalcPattern[i];
                         const i_bkg = finalBkg[i];
                          if (isFinite(i_obs) && isFinite(i_calc) && isFinite(i_bkg)) {
                             dataSection.push(formatLine([
                                 workerWorkingData.tth[i].toFixed(4),
                                 i_obs.toFixed(2),
                                 i_calc.toFixed(2),
                                 (i_obs - i_calc).toFixed(2),
                                 i_bkg.toFixed(2)
                             ], [15, 18, 18, 18, 18]));
                          }
                     }
                 } catch (dataError) {
                      console.error("Error generating point data for report:", dataError);
                      dataSection.push("(Error generating point data)");
                 }
            }

            // Assemble the report sections
            return [
                ...header,
                ...statsSection,
                ...whAnalysisSection,
                ...paramLines,
                ...backgroundPointsSection, // <-- Inserted background points here
                ...reflectionsSection,
                ...dataSection
            ].join('\n');
        }

        // --- EVENT LISTENERS, 8 oct, version 1.0.3; update le 24 oct v 111

        document.getElementById('le-bail-button').addEventListener('click', () => runFit('le-bail'));
        document.getElementById('pawley-button').addEventListener('click', () => runFit('pawley'));


        // Helper function to handle a full HKL list recalculation, including cache invalidation.
        const handleFullHklRecalculation = () => {
            if (!mainChart || isFitting) return;
            invalidateHklCache();
            generateMasterHklList();
            rescalePlot(false);
            mainChart.update('none');
        };

        // Create a debounced version of the handler for frequent input events.
        const debouncedHklRecalculation = debounce(handleFullHklRecalculation, 400); // 400ms delay

        const debouncedBackgroundUpdate = debounce(updateBackgroundForPreview, 350);


        // Helper function for simple preview updates that DON'T require HKL recalculation.
        const handleSimplePreviewUpdate = () => {
            if (!mainChart || isFitting) return;
            updatePreviewPattern();
            rescalePlot(false);
            mainChart.update('none');
        };
        //1.0.4
        const debouncedSimplePreviewUpdate = debounce(handleSimplePreviewUpdate, 350); 

        // --- Attach Listeners to Specific Controls ---
        // 1. Triggers for FULL Recalculation (these invalidate the cache)
        // These are for single-click events, so they use the direct handler.
        document.getElementById('bravais-lattice').addEventListener('change', handleFullHklRecalculation);
        document.getElementById('space-group-select').addEventListener('change', handleFullHklRecalculation);
        document.getElementById('wavelength').addEventListener('input', handleFullHklRecalculation);
        
        // Use event delegation for dynamically created lattice parameter inputs.
        // it now calls the debounced handler.
        document.getElementById('lattice-parameters-container').addEventListener('input', (event) => {
            if (event.target && event.target.type === 'number' && event.target.id.startsWith('lattice-param-')) {
                debouncedHklRecalculation();
            }
        });
        
        // 2. Triggers for SIMPLE Preview Update (these use the cached HKLs)
const controlsPanel = document.getElementById('controls-panel');
controlsPanel.querySelectorAll('#profile-simple-pvoigt-container input, #profile-tch-aniso-container input, #profile-split-pvoigt-container input').forEach(el => {
    
    // We now call the debounced function for all continuous input events
    // from sliders and number fields within the profile tabs.
    el.addEventListener('input', debouncedSimplePreviewUpdate);
});

// The profile function dropdown should update immediately on change, not after a delay.
// This is a single 'change' event, not a continuous 'input' event, so no debounce is needed.
document.getElementById('profile-function-select').addEventListener('change', handleSimplePreviewUpdate);
 

        
        document.getElementById('zero-shift').addEventListener('input', handleSimplePreviewUpdate);
        document.getElementById('fit-zero-shift').addEventListener('change', handleSimplePreviewUpdate);

        // 3. Background parameters have their own dedicated updater function
        document.getElementById('tab-panel-background').addEventListener('input', (e) => {
            if (e.target.id === 'show-anchors-checkbox') return;
            debouncedBackgroundUpdate();
        });

        // 4. Main File Input: Clears the ENTIRE cache and sets up the application
        controls.fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (evt) => {
                try {
                    const parsedData = detectAndParseFile(file.name, evt.target.result);
                    if (!parsedData || parsedData.tth.length === 0) throw new Error("No valid data points parsed.");

                    // *** CLEAR THE ENTIRE CACHE ON NEW FILE LOAD ***
                    hklIndexCache = {}; 
                    
                    if (parsedData.wavelength) controls.wavelength.value = parsedData.wavelength.toFixed(5);
                    
                    // Convert parsed data to Float64Arrays for performance
                    fullExperimentalData = {
                        tth: new Float64Array(parsedData.tth),
                        intensity: new Float64Array(parsedData.intensity)
                    };
                    lastRawDifference = []; // This can remain a standard array
                    calculatedBackground = new Float64Array(fullExperimentalData.tth.length);
                    
                    workingDataCache.isValid = false;
                    
                    controls.fileName.textContent = file.name;
                    controls.placeholder.style.display = 'none';
                    controls.resultsContainer.style.display = 'flex';
                    
                    document.getElementById('le-bail-button').disabled = false;
                    updatePawleyButtonState();
                    
                    initializeChart();
                    
                    const min = fullExperimentalData.tth[0];
                    const max = fullExperimentalData.tth[fullExperimentalData.tth.length - 1];
                    const step = (max - min) / 2000;

                    [controls.tthMinSlider, controls.tthMaxSlider].forEach(slider => {
                        slider.min = min;
                        slider.max = max;
                        slider.step = step;
                        slider.disabled = false;
                    });
                    
                    controls.tthMinSlider.value = min;
                    controls.tthMaxSlider.value = max;
                    controls.tthMinValue.textContent = min.toFixed(2);
                    controls.tthMaxValue.textContent = max.toFixed(2);
                    


                    updateWorkingData();
                    updatePlotRange(true);
                    generateMasterHklList();      
                    updateBackgroundForPreview();
                    rescalePlot(false); 
                    mainChart.update('none');

                } catch (error) {
                    alert(`Error reading file: ${error.message}`);
                    console.error(error);
                    document.getElementById('le-bail-button').disabled = true;
                    updatePawleyButtonState();
                }
            };
            reader.onerror = () => alert('Error reading file.');
            reader.readAsText(file);
        });

        // 5. General UI Listeners (not related to HKL caching)
        document.querySelector('.tab-buttons').addEventListener('click', (e) => { 
            const clickedTab = e.target.closest('.tab-btn'); 
            if (clickedTab && !clickedTab.disabled) { 
                e.currentTarget.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active')); 
                clickedTab.classList.add('active'); 
                document.querySelectorAll('.tab-content-panel').forEach(panel => panel.classList.remove('active')); 
                document.getElementById(`tab-panel-${clickedTab.dataset.tab}`).classList.add('active'); 
            } 
        });
        
        const resizer = document.getElementById('drag-handle'); 
        const leftPanel = document.getElementById('controls-panel');
        resizer.addEventListener('mousedown', (e) => { 
            e.preventDefault(); 
            document.body.style.cursor = 'col-resize'; 
            const moveHandler = (moveEvent) => { 
                if (moveEvent.clientX > 350 && moveEvent.clientX < window.innerWidth - 350) 
                    leftPanel.style.width = `${moveEvent.clientX}px`; 
            }; 
            const upHandler = () => { 
                document.body.style.cursor = 'default'; 
                window.removeEventListener('mousemove', moveHandler); 
                window.removeEventListener('mouseup', upHandler); 
            }; 
            window.addEventListener('mousemove', moveHandler); 
            window.addEventListener('mouseup', upHandler); 
        });
        
        document.getElementById('spline-points-list').addEventListener('input', handleSplinePointListInteraction);
document.getElementById('spline-points-list').addEventListener('click', handleSplinePointListInteraction);


controls.mainChartCanvas.addEventListener('click', e => {
    if (e.ctrlKey && mainChart && fullExperimentalData.tth.length > 0) { // Check data exists
        e.preventDefault();
        e.stopPropagation();

        const minTth = parseFloat(controls.tthMinSlider.value); // Get current limits
        const maxTth = parseFloat(controls.tthMaxSlider.value);

        const currentYMin = mainChart.scales.y.min;
        const currentYMax = mainChart.scales.y.max;
        const rect = controls.mainChartCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const tthValue = mainChart.scales.x.getValueForPixel(x);

        // --- ADD RANGE CHECK ---
        if (tthValue < minTth || tthValue > maxTth) {
            showToast("Cannot add points outside the current 2θ range.", "error");
            return; // Stop if outside range
        }
        // --- END CHECK ---

        const closestPoint = findClosestExperimentalPoint(tthValue);
        if (closestPoint) {
            const isAlreadyAdded = backgroundAnchors.some(a => a.index === closestPoint.index);
             // Don't add if it's exactly the first or last point's index
            const isEdgeIndex = (closestPoint.index === backgroundAnchors[0]?.index || closestPoint.index === backgroundAnchors[backgroundAnchors.length - 1]?.index);

            if (!isAlreadyAdded && !isEdgeIndex) {
                backgroundAnchors.push(closestPoint);
                backgroundAnchors.sort((a, b) => a.tth - b.tth);
                renderSplinePointList();
                updateBackgroundForPreview();
            } else if (isEdgeIndex) {
                showToast("Cannot add a point at the exact edge index.", "info");
            }
        }
        // Restore Y zoom state
        mainChart.options.scales.y.min = currentYMin;
        mainChart.options.scales.y.max = currentYMax;
        mainChart.update('none');
    }
});


        controls.iterationsSlider.addEventListener('input', () => controls.iterationsValue.textContent = controls.iterationsSlider.value);
        

document.getElementById('auto-spline-button').addEventListener('click', () => {
    const numPoints = parseInt(document.getElementById('spline-points-slider').value, 10);
    if (fullExperimentalData.tth.length > 0 && !isNaN(numPoints)) {
        autoFindSplinePoints(numPoints);
    } else {
        showToast("Load data first or check slider value.", "error");
    }
});

// Also connect the slider's display value
document.getElementById('spline-points-slider').addEventListener('input', (e) => {
    document.getElementById('spline-points-value').textContent = e.target.value;
});


// MIN SLIDER
controls.tthMinSlider.addEventListener('input', () => {
    let minVal = parseFloat(controls.tthMinSlider.value);
    let maxVal = parseFloat(controls.tthMaxSlider.value);
    if (minVal >= maxVal) {
        minVal = maxVal - parseFloat(controls.tthMinSlider.step);
        controls.tthMinSlider.value = minVal;
    }
    controls.tthMinValue.textContent = minVal.toFixed(2);

    // --- UPDATE FIRST SPLINE POINT ---
    if (backgroundAnchors.length > 0) {
        const firstPointData = findClosestExperimentalPoint(minVal);
        if (firstPointData) {
            backgroundAnchors[0].tth = minVal;
            backgroundAnchors[0].y = firstPointData.y;
            backgroundAnchors[0].index = firstPointData.index; // Update index too
            renderSplinePointList(); // Update UI list
        }
    }
    // --- END UPDATE ---

    redrawFitForNewRange(); // This updates working data and redraws chart/background
});

// MAX SLIDER
controls.tthMaxSlider.addEventListener('input', () => {
    let minVal = parseFloat(controls.tthMinSlider.value);
    let maxVal = parseFloat(controls.tthMaxSlider.value);
    if (maxVal <= minVal) {
        maxVal = minVal + parseFloat(controls.tthMaxSlider.step);
        controls.tthMaxSlider.value = maxVal;
    }
    controls.tthMaxValue.textContent = maxVal.toFixed(2);

    // --- UPDATE LAST SPLINE POINT ---
    if (backgroundAnchors.length > 0) {
        const lastPointData = findClosestExperimentalPoint(maxVal);
        if (lastPointData) {
            const lastIndex = backgroundAnchors.length - 1;
            backgroundAnchors[lastIndex].tth = maxVal;
            backgroundAnchors[lastIndex].y = lastPointData.y;
            backgroundAnchors[lastIndex].index = lastPointData.index; // Update index too
            renderSplinePointList(); // Update UI list
        }
    }
    // --- END UPDATE ---

    redrawFitForNewRange(); // This updates working data and redraws chart/background
});



controls.mainChartCanvas.addEventListener('wheel', e => {
    e.preventDefault();
    const chart = mainChart;
    if (!chart || !chart.chartArea) return;

    const { left, right, top, bottom } = chart.chartArea;
    const xPixel = e.offsetX;
    const yPixel = e.offsetY;
    
    // Zoom in = smaller range (factor < 1), zoom out = larger range (factor > 1)
    const zoomFactor = e.deltaY < 0 ? 0.9 : 1.1;

    // Helper function to perform anchored zoom on a specific axis
    const zoomOnAxis = (axisID, factor, focalPixel) => {
        const axis = chart.scales[axisID];
        if (!axis) return;

        // Get the data value directly under the mouse cursor
        const focalValue = axis.getValueForPixel(focalPixel);
        
        const currentRange = axis.max - axis.min;
        const newRange = currentRange * factor;
        
        // Determine where the mouse is proportionally on the current axis (from 0.0 to 1.0)
        const focalRatio = (focalValue - axis.min) / currentRange;
        
        // Calculate the new min and max to keep the focal point stationary
        const newMin = focalValue - (newRange * focalRatio);
        const newMax = newMin + newRange;
        
        // Apply the new limits directly to the chart options
        chart.options.scales[axisID].min = newMin;
        chart.options.scales[axisID].max = newMax;
    };

    // Determine which axis/axes to zoom based on cursor position
    if (yPixel > bottom) { // Zooming on X-axis
        zoomOnAxis('x', zoomFactor, xPixel);
    } else if (xPixel < left) { // Zooming on Y-axis
        zoomOnAxis('y', zoomFactor, yPixel);
    } else if (xPixel >= left && xPixel <= right && yPixel >= top && yPixel <= bottom) { // Zooming on both
        zoomOnAxis('x', zoomFactor, xPixel);
        zoomOnAxis('y', zoomFactor, yPixel);
    }
   
    chart.update('none');
    rescalePlot(false); 
});


//changé le 04 oct, version 2.3
controls.mainChartCanvas.addEventListener('contextmenu', e => {
    e.preventDefault();
    if (!mainChart) return;

    // 1. Manually reset the X-axis to the CURRENT SLIDER range
    mainChart.options.scales.x.min = parseFloat(controls.tthMinSlider.value); // Use .value
    mainChart.options.scales.x.max = parseFloat(controls.tthMaxSlider.value); // Use .value
    
    // 2. Manually reset the Y-axis using the original max value we stored
    const globalYMax = mainChart.options.globalYMax;
    mainChart.options.scales.y.max = globalYMax;
    mainChart.options.scales.y.min = -(globalYMax * 0.3); // Restore the default 30% space for the diff plot

    // 3. Update the chart to apply these new axis limits and redraw the difference plot
    mainChart.update('none');
    rescalePlot(false);
});

    controls.profileSelect.addEventListener('change', (e) => { 
            const newProfile = e.target.value; 
            saveProfileState(currentProfile); 
            
            controls.profileSimplePVoigtContainer.classList.toggle('hidden', newProfile !== 'simple_pvoigt'); 
            controls.profileTchAnisoContainer.classList.toggle('hidden', newProfile !== 'tch_aniso'); 
            controls.profileSplitPVoigtContainer.classList.toggle('hidden', newProfile !== 'split_pvoigt'); 
            
            restoreProfileState(newProfile); 
            currentProfile = newProfile; 
            if (fullExperimentalData.tth.length > 0) updatePreviewPattern(); 
        });
        
        controls.bravaisLattice.addEventListener('change', updateUIForSystemChange);
        
        controls.paramS400.addEventListener('input', updateStephensAnisotropyUI); controls.fitS400.addEventListener('change', updateStephensAnisotropyUI); controls.paramS220.addEventListener('input', updateStephensAnisotropyUI); controls.fitS220.addEventListener('change', updateStephensAnisotropyUI); controls.paramS202.addEventListener('input', updateStephensAnisotropyUI); controls.fitS202.addEventListener('change', updateStephensAnisotropyUI);


    controls.saveDataButton.addEventListener('click', () => {
    if (!fitResults) {
        showToast("Please run a refinement before saving data.", 'error');
        return;
    }
    const originalText = controls.saveDataButton.textContent;
    controls.saveDataButton.textContent = 'Saving...';
    controls.saveDataButton.disabled = true;
    try {
        const textContent = generateReportContent('full');
        const timestamp = new Date().toISOString().slice(0, 16).replace(/[-:]/g, '').replace('T', '_');
        
        // Determine the filename based on the refinement mode from the results
        const modeName = fitResults.refinementMode === 'pawley' ? 'Pawley' : 'LeBail';
        downloadTextFile(textContent, `${modeName}-Data-${timestamp}.txt`);

        showToast("Report saved successfully!", 'success');
    } catch (error) {
        console.error("Failed to save data:", error);
    } finally {
        controls.saveDataButton.textContent = 'Save Report';
        controls.saveDataButton.disabled = false;
    }
});


document.getElementById('show-spline-points-checkbox').addEventListener('change', (e) => {
    if (mainChart) {
        const isVisible = e.target.checked;
        // Ensure the label matches the one in initializeChart
        const splineDataset = mainChart.data.datasets.find(d => d.label === 'Spline Points');
        if (splineDataset) {
            splineDataset.hidden = !isVisible; // Toggle hidden state based on checkbox
            mainChart.update('none'); // Update chart without animation
        }
    }
});





controls.reportButton.addEventListener('click', async () => {
    if (!fitResults) {
        alert("Cannot generate report: Fit results are missing.");
        return;
    }

    const originalText = controls.reportButton.textContent;
    controls.reportButton.textContent = 'Generating...';
    controls.reportButton.disabled = true;

    try {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
        const margin = 15;
        const contentWidth = doc.internal.pageSize.getWidth() - 2 * margin;
        let yPosition = 20;

        const summaryText = generateReportContent('summary');
        const pdfText = summaryText
            .replace(/χ²/g, 'Chi^2')
            .replace(/°/g, 'deg')
            .replace(/β/g, 'Beta');

        const lines = pdfText.split('\n');
        doc.setFont('Courier');

        for (const line of lines) {
            if (yPosition > doc.internal.pageSize.getHeight() - 20) {
                doc.addPage();
                yPosition = 20;
            }
            const isHeader = line.startsWith('---');
            const isTitle = line.includes('Refinement Report');
            let fontSize = 9;
            let fontStyle = 'normal';

            if (isTitle) {
                fontSize = 14;
                fontStyle = 'bold';
                yPosition += 6;
            } else if (isHeader) {
                fontSize = 10;
                fontStyle = 'bold';
                yPosition += 4;
            }
            
            doc.setFontSize(fontSize);
            doc.setFont(undefined, fontStyle);
            doc.text(line, margin, yPosition);
            yPosition += fontSize * 0.4;
        }

        doc.addPage();
        const chartCanvas = await html2canvas(controls.mainChartCanvas, { backgroundColor: '#ffffff', scale: 2 });
        const mainImgData = chartCanvas.toDataURL('image/png', 0.95);
        const mainImgProps = doc.getImageProperties(mainImgData);
        const mainImgHeight = Math.min((mainImgProps.height * contentWidth) / mainImgProps.width, 250); 
        doc.addImage(mainImgData, 'PNG', margin, 20, contentWidth, mainImgHeight);
        
        // Determine the filename based on the refinement mode from the results
        const { refinementMode } = fitResults;
        const modeName = refinementMode === 'pawley' ? 'Pawley' : 'LeBail';
        doc.save(`${modeName}-Report-${new Date().toISOString().slice(0, 10)}.pdf`);

    } catch (error) {
        alert(`An error occurred while generating the report: ${error.message}`);
    } finally {
        controls.reportButton.textContent = 'Generate PDF';
        if (fitResults) {
            controls.reportButton.disabled = false;
        }
    }
});

        controls.algorithmSelect.addEventListener('change', updatePawleyButtonState);

        updatePawleyButtonState();

        updateUIForSystemChange();
    });

</script>


</body>
</html>